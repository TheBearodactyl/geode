/* automatically generated by rust-bindgen 0.69.4 */

pub type va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
pub type std_less_first_argument_type = u8;
pub type std_less_second_argument_type = u8;
pub type std_less_result_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator__From_primary = u8;
pub type std_allocator_value_type = u8;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
pub type std_allocator_size_type = u32;
pub type std_allocator_difference_type = u32;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Alty = u8;
pub type std_basic_string__Alty_traits = u8;
pub type std_basic_string__Scary_val = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string__Is_elem_cptr = u8;
pub const std_basic_string__Allocation_policy__At_least: std_basic_string__Allocation_policy = 0;
pub const std_basic_string__Allocation_policy__Exactly: std_basic_string__Allocation_policy = 0;
pub type std_basic_string__Allocation_policy = ::std::os::raw::c_int;
pub const std_basic_string__Construct_strategy__From_char: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_ptr: std_basic_string__Construct_strategy = 0;
pub const std_basic_string__Construct_strategy__From_string: std_basic_string__Construct_strategy =
    0;
pub type std_basic_string__Construct_strategy = ::std::os::raw::c_uchar;
pub type std_string = [u32; 6usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_set {
    pub _address: u8,
}
pub type std_set__Mybase = u8;
pub type std_set_key_type = u8;
pub type std_set_key_compare = u8;
pub type std_set_value_compare = u8;
pub type std_set_value_type = u8;
pub type std_set_allocator_type = u8;
pub type std_set_size_type = u8;
pub type std_set_difference_type = u8;
pub type std_set_pointer = u8;
pub type std_set_const_pointer = u8;
pub type std_set_reference = u8;
pub type std_set_const_reference = u8;
pub type std_set_iterator = u8;
pub type std_set_const_iterator = u8;
pub type std_set_reverse_iterator = u8;
pub type std_set_const_reverse_iterator = u8;
pub type std_set__Alnode = u8;
pub type std_set__Alnode_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_map {
    pub _address: u8,
}
pub type std_map__Mybase = u8;
pub type std_map__Nodeptr = u8;
pub type std_map_key_type = u8;
pub type std_map_mapped_type = u8;
pub type std_map_key_compare = u8;
pub type std_map_value_compare = u8;
pub type std_map_value_type = u8;
pub type std_map_allocator_type = u8;
pub type std_map_size_type = u8;
pub type std_map_difference_type = u8;
pub type std_map_pointer = u8;
pub type std_map_const_pointer = u8;
pub type std_map_reference = u8;
pub type std_map_const_reference = u8;
pub type std_map_iterator = u8;
pub type std_map_const_iterator = u8;
pub type std_map_reverse_iterator = u8;
pub type std_map_const_reverse_iterator = u8;
pub type std_map__Alnode = u8;
pub type std_map__Alnode_traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Alty = u8;
pub type std_vector__Alty_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_allocator_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_size_type = u8;
pub type std_vector_difference_type = u8;
pub type std_vector__Scary_val = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub const std_vector__Reallocation_policy__At_least: std_vector__Reallocation_policy = 0;
pub const std_vector__Reallocation_policy__Exactly: std_vector__Reallocation_policy = 0;
pub type std_vector__Reallocation_policy = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {}
pub type std_basic_ostream__Myios = u8;
pub type std_basic_ostream__Mysb = u8;
pub type std_basic_ostream__Iter = u8;
pub type std_basic_ostream__Nput = u8;
pub type std_basic_ostream_int_type = u8;
pub type std_basic_ostream_pos_type = u8;
pub type std_basic_ostream_off_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream__Sentry_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream_sentry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {}
pub type std_basic_istream__Myios = u8;
pub type std_basic_istream__Mysb = u8;
pub type std_basic_istream__Iter = u8;
pub type std_basic_istream__Ctype = u8;
pub type std_basic_istream__Nget = u8;
pub type std_basic_istream_int_type = u8;
pub type std_basic_istream_pos_type = u8;
pub type std_basic_istream_off_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream__Sentry_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _address: u8,
}
#[repr(C)]
pub struct cocos2d_CCDataVisitor__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Visitor that helps to perform action that depends on polymorphic object type\n\n Use cases:\n  - data serialization,\n  - pretty printing of \\a CCObject *\n  - safe value reading from \\a CCArray, \\a CCDictionary, \\a CCSet\n\n Usage:\n  1. subclass CCDataVisitor\n  2. overload visit() methods for object that you need to handle\n  3. handle other objects in \\a visitObject()\n  4. pass your visitor to \\a CCObject::acceptVisitor()\n  @js NA\n  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDataVisitor {
    pub vtable_: *const cocos2d_CCDataVisitor__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDataVisitor() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDataVisitor>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCDataVisitor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDataVisitor>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDataVisitor))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCBool@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit(this: *mut ::std::os::raw::c_void, p: *const cocos2d_CCBool);
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCInteger@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit1(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCInteger,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCFloat@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit2(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCFloat,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCDouble@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit3(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDouble,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCString@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit4(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCString,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCArray@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit5(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCDictionary@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit6(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCDataVisitor@cocos2d@@UAEXPBVCCSet@2@@Z"]
    pub fn cocos2d_CCDataVisitor_visit7(this: *mut ::std::os::raw::c_void, p: *const cocos2d_CCSet);
}
#[doc = "  @js NA\n  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPrettyPrinter {
    pub _base: cocos2d_CCDataVisitor,
    pub _indentLevel: ::std::os::raw::c_int,
    pub _indentStr: std_string,
    pub _result: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPrettyPrinter() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPrettyPrinter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPrettyPrinter>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCPrettyPrinter))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPrettyPrinter>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPrettyPrinter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._indentLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_indentLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._indentStr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_indentStr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPrettyPrinter),
            "::",
            stringify!(_result)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCPrettyPrinter@cocos2d@@QAE@H@Z"]
    pub fn cocos2d_CCPrettyPrinter_CCPrettyPrinter(
        this: *mut cocos2d_CCPrettyPrinter,
        indentLevel: ::std::os::raw::c_int,
    );
}
impl cocos2d_CCPrettyPrinter {
    #[inline]
    pub unsafe fn new(indentLevel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPrettyPrinter_CCPrettyPrinter(__bindgen_tmp.as_mut_ptr(), indentLevel);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?clear@CCPrettyPrinter@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCPrettyPrinter_clear(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?getResult@CCPrettyPrinter@cocos2d@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCPrettyPrinter_getResult(this: *mut ::std::os::raw::c_void) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?visitObject@CCPrettyPrinter@cocos2d@@UAEXPBVCCObject@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visitObject(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCBool@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCBool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCInteger@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit1(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCInteger,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCFloat@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit2(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCFloat,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCDouble@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit3(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDouble,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCString@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit4(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCString,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCArray@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit5(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCDictionary@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit6(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCPrettyPrinter@cocos2d@@UAEXPBVCCSet@2@@Z"]
    pub fn cocos2d_CCPrettyPrinter_visit7(
        this: *mut ::std::os::raw::c_void,
        p: *const cocos2d_CCSet,
    );
}
#[doc = " The max length of CCLog message."]
pub const cocos2d_kMaxLogLen: ::std::os::raw::c_int = 16384;
extern "C" {
    #[doc = "@brief Output Debug message."]
    #[link_name = "\u{1}?CCLog@cocos2d@@YAXPBDZZ"]
    pub fn cocos2d_CCLog(pszFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " lua can not deal with ..."]
    #[link_name = "\u{1}?CCLuaLog@cocos2d@@YAXPBD@Z"]
    pub fn cocos2d_CCLuaLog(pszFormat: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "@brief Pop out a message box"]
    #[link_name = "\u{1}?CCMessageBox@cocos2d@@YAXPBD0@Z"]
    pub fn cocos2d_CCMessageBox(
        pszMsg: *const ::std::os::raw::c_char,
        pszTitle: *const ::std::os::raw::c_char,
    );
}
pub const cocos2d_LanguageType_kLanguageEnglish: cocos2d_LanguageType = 0;
pub const cocos2d_LanguageType_kLanguageChinese: cocos2d_LanguageType = 1;
pub const cocos2d_LanguageType_kLanguageFrench: cocos2d_LanguageType = 2;
pub const cocos2d_LanguageType_kLanguageItalian: cocos2d_LanguageType = 3;
pub const cocos2d_LanguageType_kLanguageGerman: cocos2d_LanguageType = 4;
pub const cocos2d_LanguageType_kLanguageSpanish: cocos2d_LanguageType = 5;
pub const cocos2d_LanguageType_kLanguageDutch: cocos2d_LanguageType = 6;
pub const cocos2d_LanguageType_kLanguageRussian: cocos2d_LanguageType = 7;
pub const cocos2d_LanguageType_kLanguageKorean: cocos2d_LanguageType = 8;
pub const cocos2d_LanguageType_kLanguageJapanese: cocos2d_LanguageType = 9;
pub const cocos2d_LanguageType_kLanguageHungarian: cocos2d_LanguageType = 10;
pub const cocos2d_LanguageType_kLanguagePortuguese: cocos2d_LanguageType = 11;
pub const cocos2d_LanguageType_kLanguageArabic: cocos2d_LanguageType = 12;
#[doc = "@brief Enum the language type supported now"]
pub type cocos2d_LanguageType = ::std::os::raw::c_int;
#[doc = "@brief Enum the language type supported now"]
pub use self::cocos2d_LanguageType as cocos2d_ccLanguageType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_timezone>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?gettimeofday@cocos2d@@YAHPAUtimeval@@PAUtimezone@1@@Z"]
    pub fn cocos2d_gettimeofday(
        arg1: *mut timeval,
        arg2: *mut cocos2d_timezone,
    ) -> ::std::os::raw::c_int;
}
pub const cocos2d_CCObjectType_kCCObjectTypePlayLayer: cocos2d_CCObjectType = 5;
pub const cocos2d_CCObjectType_kCCObjectTypeLevelEditorLayer: cocos2d_CCObjectType = 6;
pub const cocos2d_CCObjectType_kCCObjectTypeMenuLayer: cocos2d_CCObjectType = 15;
#[doc = " @addtogroup base_nodes\n @{"]
pub type cocos2d_CCObjectType = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCCopying__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCCopying {
    pub vtable_: *const cocos2d_CCCopying__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCopying() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCopying>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCCopying))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCopying>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCopying))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?copyWithZone@CCCopying@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCopying_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @addtogroup data_structures\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCObject {
    pub _base: cocos2d_CCCopying,
    pub m_uID: ::std::os::raw::c_uint,
    pub m_nLuaID: ::std::os::raw::c_int,
    pub m_nTag: ::std::os::raw::c_int,
    pub m_uReference: ::std::os::raw::c_uint,
    pub m_uAutoReleaseCount: ::std::os::raw::c_uint,
    pub m_eObjType: cocos2d_CCObjectType,
    pub m_uIndexInArray: ::std::os::raw::c_int,
    pub m_uUnknown: ::std::os::raw::c_int,
    pub m_unknown2: ::std::os::raw::c_int,
    pub m_nZOrder: ::std::os::raw::c_int,
    pub m_uOrderOfArrival: ::std::os::raw::c_int,
    pub m_unknown5: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCObject() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCObject>(),
        52usize,
        concat!("Size of: ", stringify!(cocos2d_CCObject))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCObject>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nLuaID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nLuaID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uReference) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uReference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAutoReleaseCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uAutoReleaseCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eObjType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_eObjType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uIndexInArray) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uIndexInArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uUnknown) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uUnknown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unknown2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_unknown2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nZOrder) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_nZOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uOrderOfArrival) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_uOrderOfArrival)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unknown5) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCObject),
            "::",
            stringify!(m_unknown5)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?release@CCObject@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCObject_release(this: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[link_name = "\u{1}?retain@CCObject@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCObject_retain(this: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[link_name = "\u{1}?autorelease@CCObject@cocos2d@@QAEPAV12@XZ"]
    pub fn cocos2d_CCObject_autorelease(this: *mut cocos2d_CCObject) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?copy@CCObject@cocos2d@@QAEPAV12@XZ"]
    pub fn cocos2d_CCObject_copy(this: *mut cocos2d_CCObject) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?isSingleReference@CCObject@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCObject_isSingleReference(this: *const cocos2d_CCObject) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?createWithCoder@CCObject@cocos2d@@SAPAV12@PAVDS_Dictionary@@@Z"]
    pub fn cocos2d_CCObject_createWithCoder(arg1: *mut DS_Dictionary) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCObject@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCObject_CCObject(this: *mut cocos2d_CCObject);
}
impl cocos2d_CCObject {
    #[inline]
    pub unsafe fn release(&mut self) {
        cocos2d_CCObject_release(self)
    }
    #[inline]
    pub unsafe fn retain(&mut self) {
        cocos2d_CCObject_retain(self)
    }
    #[inline]
    pub unsafe fn autorelease(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_autorelease(self)
    }
    #[inline]
    pub unsafe fn copy(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_copy(self)
    }
    #[inline]
    pub unsafe fn isSingleReference(&self) -> bool {
        cocos2d_CCObject_isSingleReference(self)
    }
    #[inline]
    pub unsafe fn createWithCoder(arg1: *mut DS_Dictionary) -> *mut cocos2d_CCObject {
        cocos2d_CCObject_createWithCoder(arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCObject_CCObject(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??1CCObject@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCObject_CCObject_destructor(this: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[link_name = "\u{1}?isEqual@CCObject@cocos2d@@UAE_NPBV12@@Z"]
    pub fn cocos2d_CCObject_isEqual(
        this: *mut ::std::os::raw::c_void,
        pObject: *const cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?acceptVisitor@CCObject@cocos2d@@UAEXAAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCObject_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?encodeWithCoder@CCObject@cocos2d@@UAEXPAVDS_Dictionary@@@Z"]
    pub fn cocos2d_CCObject_encodeWithCoder(
        this: *mut ::std::os::raw::c_void,
        arg1: *mut DS_Dictionary,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?canEncode@CCObject@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCObject_canEncode(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getTag@CCObject@cocos2d@@UBEHXZ"]
    pub fn cocos2d_CCObject_getTag(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTag@CCObject@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCObject_setTag(this: *mut ::std::os::raw::c_void, nTag: ::std::os::raw::c_int);
}
pub type cocos2d_SEL_SCHEDULE = ::std::option::Option<unsafe extern "thiscall" fn(arg1: f32)>;
pub type cocos2d_SEL_CallFunc = ::std::option::Option<unsafe extern "thiscall" fn()>;
pub type cocos2d_SEL_CallFuncN =
    ::std::option::Option<unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCNode)>;
pub type cocos2d_SEL_CallFuncND = ::std::option::Option<
    unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCNode, arg2: *mut ::std::os::raw::c_void),
>;
pub type cocos2d_SEL_CallFuncO =
    ::std::option::Option<unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCObject)>;
pub type cocos2d_SEL_MenuHandler =
    ::std::option::Option<unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCObject)>;
pub type cocos2d_SEL_EventHandler =
    ::std::option::Option<unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCEvent)>;
pub type cocos2d_SEL_Compare = ::std::option::Option<
    unsafe extern "thiscall" fn(arg1: *mut cocos2d_CCObject) -> ::std::os::raw::c_int,
>;
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPoint() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPoint>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoint),
            "::",
            stringify!(y)
        )
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setPoint@CCPoint@cocos2d@@QAEXMM@Z"]
    pub fn cocos2d_CCPoint_setPoint(this: *mut cocos2d_CCPoint, x: f32, y: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?equals@CCPoint@cocos2d@@QBE_NABV12@@Z"]
    pub fn cocos2d_CCPoint_equals(
        this: *const cocos2d_CCPoint,
        target: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @returns if points have fuzzy equality which means equal with some degree of variance.\n @since v2.1.4\n @lua NA"]
    #[link_name = "\u{1}?fuzzyEquals@CCPoint@cocos2d@@QBE_NABV12@M@Z"]
    pub fn cocos2d_CCPoint_fuzzyEquals(
        this: *const cocos2d_CCPoint,
        target: *const cocos2d_CCPoint,
        variance: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @returns the angle in radians between two vector directions\n@since v2.1.4"]
    #[link_name = "\u{1}?getAngle@CCPoint@cocos2d@@QBEMABV12@@Z"]
    pub fn cocos2d_CCPoint_getAngle(
        this: *const cocos2d_CCPoint,
        other: *const cocos2d_CCPoint,
    ) -> f32;
}
extern "thiscall" {
    #[doc = " Rotates a point counter clockwise by the angle around a pivot\n@param pivot is the pivot, naturally\n@param angle is the angle of rotation ccw in radians\n@returns the rotated point\n@since v2.1.4"]
    #[link_name = "\u{1}?rotateByAngle@CCPoint@cocos2d@@QBE?AV12@ABV12@M@Z"]
    pub fn cocos2d_CCPoint_rotateByAngle(
        this: *const cocos2d_CCPoint,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCPoint_CCPoint(this: *mut cocos2d_CCPoint);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QAE@MM@Z"]
    pub fn cocos2d_CCPoint_CCPoint1(this: *mut cocos2d_CCPoint, x: f32, y: f32);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCPoint_CCPoint2(this: *mut cocos2d_CCPoint, other: *const cocos2d_CCPoint);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPoint@cocos2d@@QAE@ABVCCSize@1@@Z"]
    pub fn cocos2d_CCPoint_CCPoint3(this: *mut cocos2d_CCPoint, size: *const cocos2d_CCSize);
}
impl cocos2d_CCPoint {
    #[inline]
    pub unsafe fn setPoint(&mut self, x: f32, y: f32) {
        cocos2d_CCPoint_setPoint(self, x, y)
    }
    #[inline]
    pub unsafe fn equals(&self, target: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCPoint_equals(self, target)
    }
    #[inline]
    pub unsafe fn fuzzyEquals(&self, target: *const cocos2d_CCPoint, variance: f32) -> bool {
        cocos2d_CCPoint_fuzzyEquals(self, target, variance)
    }
    #[inline]
    pub unsafe fn getAngle(&self, other: *const cocos2d_CCPoint) -> f32 {
        cocos2d_CCPoint_getAngle(self, other)
    }
    #[inline]
    pub unsafe fn rotateByAngle(
        &self,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint {
        cocos2d_CCPoint_rotateByAngle(self, pivot, angle)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: f32, y: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint1(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCPoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(size: *const cocos2d_CCSize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoint_CCPoint3(__bindgen_tmp.as_mut_ptr(), size);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @addtogroup data_structures\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSize {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSize() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSize> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSize>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCSize))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSize>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSize))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSize),
            "::",
            stringify!(height)
        )
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setSize@CCSize@cocos2d@@QAEXMM@Z"]
    pub fn cocos2d_CCSize_setSize(this: *mut cocos2d_CCSize, width: f32, height: f32);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?equals@CCSize@cocos2d@@QBE_NABV12@@Z"]
    pub fn cocos2d_CCSize_equals(
        this: *const cocos2d_CCSize,
        target: *const cocos2d_CCSize,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCSize@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSize_CCSize(this: *mut cocos2d_CCSize);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCSize@cocos2d@@QAE@MM@Z"]
    pub fn cocos2d_CCSize_CCSize1(this: *mut cocos2d_CCSize, width: f32, height: f32);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSize@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCSize_CCSize2(this: *mut cocos2d_CCSize, other: *const cocos2d_CCSize);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSize@cocos2d@@QAE@ABVCCPoint@1@@Z"]
    pub fn cocos2d_CCSize_CCSize3(this: *mut cocos2d_CCSize, point: *const cocos2d_CCPoint);
}
impl cocos2d_CCSize {
    #[inline]
    pub unsafe fn setSize(&mut self, width: f32, height: f32) {
        cocos2d_CCSize_setSize(self, width, height)
    }
    #[inline]
    pub unsafe fn equals(&self, target: *const cocos2d_CCSize) -> bool {
        cocos2d_CCSize_equals(self, target)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(width: f32, height: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize1(__bindgen_tmp.as_mut_ptr(), width, height);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCSize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(point: *const cocos2d_CCPoint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSize_CCSize3(__bindgen_tmp.as_mut_ptr(), point);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCRect {
    pub origin: cocos2d_CCPoint,
    pub size: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRect() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRect>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_CCRect))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRect>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRect),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRect),
            "::",
            stringify!(size)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRect@CCRect@cocos2d@@QAEXMMMM@Z"]
    pub fn cocos2d_CCRect_setRect(
        this: *mut cocos2d_CCRect,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getMinX@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMinX(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the leftmost x-value of current rect"]
    #[link_name = "\u{1}?getMidX@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMidX(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the midpoint x-value of current rect"]
    #[link_name = "\u{1}?getMaxX@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMaxX(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the rightmost x-value of current rect"]
    #[link_name = "\u{1}?getMinY@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMinY(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the bottommost y-value of current rect"]
    #[link_name = "\u{1}?getMidY@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMidY(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the midpoint y-value of current rect"]
    #[link_name = "\u{1}?getMaxY@CCRect@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRect_getMaxY(this: *const cocos2d_CCRect) -> f32;
}
extern "thiscall" {
    #[doc = " return the topmost y-value of current rect"]
    #[link_name = "\u{1}?equals@CCRect@cocos2d@@QBE_NABV12@@Z"]
    pub fn cocos2d_CCRect_equals(this: *const cocos2d_CCRect, rect: *const cocos2d_CCRect) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?containsPoint@CCRect@cocos2d@@QBE_NABVCCPoint@2@@Z"]
    pub fn cocos2d_CCRect_containsPoint(
        this: *const cocos2d_CCRect,
        point: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?intersectsRect@CCRect@cocos2d@@QBE_NABV12@@Z"]
    pub fn cocos2d_CCRect_intersectsRect(
        this: *const cocos2d_CCRect,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCRect@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCRect_CCRect(this: *mut cocos2d_CCRect);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCRect@cocos2d@@QAE@MMMM@Z"]
    pub fn cocos2d_CCRect_CCRect1(
        this: *mut cocos2d_CCRect,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCRect@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCRect_CCRect2(this: *mut cocos2d_CCRect, other: *const cocos2d_CCRect);
}
impl cocos2d_CCRect {
    #[inline]
    pub unsafe fn setRect(&mut self, x: f32, y: f32, width: f32, height: f32) {
        cocos2d_CCRect_setRect(self, x, y, width, height)
    }
    #[inline]
    pub unsafe fn getMinX(&self) -> f32 {
        cocos2d_CCRect_getMinX(self)
    }
    #[inline]
    pub unsafe fn getMidX(&self) -> f32 {
        cocos2d_CCRect_getMidX(self)
    }
    #[inline]
    pub unsafe fn getMaxX(&self) -> f32 {
        cocos2d_CCRect_getMaxX(self)
    }
    #[inline]
    pub unsafe fn getMinY(&self) -> f32 {
        cocos2d_CCRect_getMinY(self)
    }
    #[inline]
    pub unsafe fn getMidY(&self) -> f32 {
        cocos2d_CCRect_getMidY(self)
    }
    #[inline]
    pub unsafe fn getMaxY(&self) -> f32 {
        cocos2d_CCRect_getMaxY(self)
    }
    #[inline]
    pub unsafe fn equals(&self, rect: *const cocos2d_CCRect) -> bool {
        cocos2d_CCRect_equals(self, rect)
    }
    #[inline]
    pub unsafe fn containsPoint(&self, point: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCRect_containsPoint(self, point)
    }
    #[inline]
    pub unsafe fn intersectsRect(&self, rect: *const cocos2d_CCRect) -> bool {
        cocos2d_CCRect_intersectsRect(self, rect)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: f32, y: f32, width: f32, height: f32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect1(__bindgen_tmp.as_mut_ptr(), x, y, width, height);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const cocos2d_CCRect) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRect_CCRect2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}?CCPointZero@cocos2d@@3VCCPoint@1@B"]
    pub static cocos2d_CCPointZero: cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?CCSizeZero@cocos2d@@3VCCSize@1@B"]
    pub static cocos2d_CCSizeZero: cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?CCRectZero@cocos2d@@3VCCRect@1@B"]
    pub static cocos2d_CCRectZero: cocos2d_CCRect;
}
#[doc = "! Default tag"]
pub const kCCActionTagInvalid: cocos2d__bindgen_ty_1 = -1;
pub type cocos2d__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "@brief Base class for CCAction objects."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAction {
    pub _base: cocos2d_CCObject,
    pub m_pOriginalTarget: *mut cocos2d_CCNode,
    #[doc = " The \"target\".\nThe target will be set with the 'startWithTarget' method.\nWhen the 'stop' method is called, target will be set to nil.\nThe target is 'assigned', it is not 'retained'."]
    pub m_pTarget: *mut cocos2d_CCNode,
    #[doc = " The action tag. An identifier of the action"]
    pub m_nTag: ::std::os::raw::c_int,
    pub m_fSpeedMod: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAction() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAction>(),
        68usize,
        concat!("Size of: ", stringify!(cocos2d_CCAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOriginalTarget) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_pOriginalTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTarget) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_pTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTag) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_nTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSpeedMod) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAction),
            "::",
            stringify!(m_fSpeedMod)
        )
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?description@CCAction@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCAction_description(
        this: *mut cocos2d_CCAction,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSpeedMod@CCAction@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCAction_setSpeedMod(this: *mut cocos2d_CCAction, mod_: f32);
}
extern "C" {
    #[doc = " Create an action"]
    #[link_name = "\u{1}?create@CCAction@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCAction_create() -> *mut cocos2d_CCAction;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAction@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAction_CCAction(this: *mut cocos2d_CCAction);
}
impl cocos2d_CCAction {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCAction_description(self)
    }
    #[inline]
    pub unsafe fn setSpeedMod(&mut self, mod_: f32) {
        cocos2d_CCAction_setSpeedMod(self, mod_)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCAction {
        cocos2d_CCAction_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAction_CCAction(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCAction@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAction_CCAction_destructor(this: *mut cocos2d_CCAction);
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAction@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = "! return true if the action has finished"]
    #[link_name = "\u{1}?isDone@CCAction@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCAction_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "! called before the action start. It will also set the target."]
    #[link_name = "\u{1}?startWithTarget@CCAction@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "called after the action has finished. It will set the 'target' to nil.\nIMPORTANT: You should never call \"[action stop]\" manually. Instead, use: \"target->stopAction(action);\""]
    #[link_name = "\u{1}?stop@CCAction@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCAction_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "! called every frame with it's delta time. DON'T override unless you know what you are doing."]
    #[link_name = "\u{1}?step@CCAction@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCAction_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[doc = "called once per frame. time a value between 0 and 1\n\nFor example:\n- 0 means that the action just started\n- 0.5 means that the action is in the middle\n- 1 means that the action is over"]
    #[link_name = "\u{1}?update@CCAction@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCAction_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief\nBase class actions that do have a finite time duration.\nPossible actions:\n- An action with a duration of 0 seconds\n- An action with a duration of 35.5 seconds\n\nInfinite time actions are valid"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFiniteTimeAction {
    pub _base: cocos2d_CCAction,
    #[doc = "! duration in seconds"]
    pub m_fDuration: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFiniteTimeAction() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFiniteTimeAction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFiniteTimeAction>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCFiniteTimeAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFiniteTimeAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFiniteTimeAction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDuration) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFiniteTimeAction),
            "::",
            stringify!(m_fDuration)
        )
    );
}
extern "thiscall" {
    #[doc = " returns a reversed action"]
    #[link_name = "\u{1}?reverse@CCFiniteTimeAction@cocos2d@@UAEPAV12@XZ"]
    pub fn cocos2d_CCFiniteTimeAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
#[doc = "@brief Changes the speed of an action, making it take longer (speed>1)\nor less (speed<1) time.\nUseful to simulate 'slow motion' or 'fast forward' effect.\n@warning This action can't be Sequenceable because it is not an CCIntervalAction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpeed {
    pub _base: cocos2d_CCAction,
    pub m_fSpeed: f32,
    pub m_pInnerAction: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpeed() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSpeed> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpeed>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpeed))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpeed>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpeed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSpeed) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpeed),
            "::",
            stringify!(m_fSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInnerAction) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpeed),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCSpeed@cocos2d@@QAE_NPAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCSpeed_initWithAction(
        this: *mut cocos2d_CCSpeed,
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setInnerAction@CCSpeed@cocos2d@@QAEXPAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCSpeed_setInnerAction(
        this: *mut cocos2d_CCSpeed,
        pAction: *mut cocos2d_CCActionInterval,
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCSpeed@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCSpeed_create(
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> *mut cocos2d_CCSpeed;
}
impl cocos2d_CCSpeed {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> bool {
        cocos2d_CCSpeed_initWithAction(self, pAction, fSpeed)
    }
    #[inline]
    pub unsafe fn setInnerAction(&mut self, pAction: *mut cocos2d_CCActionInterval) {
        cocos2d_CCSpeed_setInnerAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fSpeed: f32,
    ) -> *mut cocos2d_CCSpeed {
        cocos2d_CCSpeed_create(pAction, fSpeed)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCSpeed@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSpeed_CCSpeed_destructor(this: *mut cocos2d_CCSpeed);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpeed@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpeed_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCSpeed@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpeed_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCSpeed@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSpeed_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?step@CCSpeed@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSpeed_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isDone@CCSpeed@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCSpeed_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCSpeed@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSpeed_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCFollow is an action that \"follows\" a node.\n\nEg:\nlayer->runAction(CCFollow::actionWithTarget(hero));\n\nInstead of using CCCamera as a \"follower\", use this action instead.\n@since v0.99.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFollow {
    pub _base: cocos2d_CCAction,
    pub m_pobFollowedNode: *mut cocos2d_CCNode,
    pub m_bBoundarySet: bool,
    pub m_bBoundaryFullyCovered: bool,
    pub m_obHalfScreenSize: cocos2d_CCPoint,
    pub m_obFullScreenSize: cocos2d_CCPoint,
    pub m_fLeftBoundary: f32,
    pub m_fRightBoundary: f32,
    pub m_fTopBoundary: f32,
    pub m_fBottomBoundary: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFollow() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFollow> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFollow>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCFollow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFollow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFollow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobFollowedNode) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_pobFollowedNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBoundarySet) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_bBoundarySet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBoundaryFullyCovered) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_bBoundaryFullyCovered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obHalfScreenSize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_obHalfScreenSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obFullScreenSize) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_obFullScreenSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fLeftBoundary) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fLeftBoundary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRightBoundary) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fRightBoundary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTopBoundary) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fTopBoundary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fBottomBoundary) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFollow),
            "::",
            stringify!(m_fBottomBoundary)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with a set boundary"]
    #[link_name = "\u{1}?initWithTarget@CCFollow@cocos2d@@QAE_NPAVCCNode@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCFollow_initWithTarget(
        this: *mut cocos2d_CCFollow,
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a set boundary,\nIt will work with no boundary if @param rect is equal to CCRectZero."]
    #[link_name = "\u{1}?create@CCFollow@cocos2d@@SAPAV12@PAVCCNode@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCFollow_create(
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCFollow;
}
impl cocos2d_CCFollow {
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCFollow_initWithTarget(self, pFollowedNode, rect)
    }
    #[inline]
    pub unsafe fn create(
        pFollowedNode: *mut cocos2d_CCNode,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCFollow {
        cocos2d_CCFollow_create(pFollowedNode, rect)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCFollow@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCFollow_CCFollow_destructor(this: *mut cocos2d_CCFollow);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFollow@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFollow_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?step@CCFollow@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFollow_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isDone@CCFollow@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCFollow_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCFollow@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCFollow_stop(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAffineTransform {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub tx: f32,
    pub ty: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAffineTransform() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAffineTransform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAffineTransform>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d_CCAffineTransform))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAffineTransform>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAffineTransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ty) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAffineTransform),
            "::",
            stringify!(ty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?__CCAffineTransformMake@cocos2d@@YA?AUCCAffineTransform@1@MMMMMM@Z"]
    pub fn cocos2d___CCAffineTransformMake(
        a: f32,
        b: f32,
        c: f32,
        d: f32,
        tx: f32,
        ty: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?__CCPointApplyAffineTransform@cocos2d@@YA?AVCCPoint@1@ABV21@ABUCCAffineTransform@1@@Z"]
    pub fn cocos2d___CCPointApplyAffineTransform(
        point: *const cocos2d_CCPoint,
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[link_name = "\u{1}?__CCSizeApplyAffineTransform@cocos2d@@YA?AVCCSize@1@ABV21@ABUCCAffineTransform@1@@Z"]
    pub fn cocos2d___CCSizeApplyAffineTransform(
        size: *const cocos2d_CCSize,
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCSize;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformMakeIdentity@cocos2d@@YA?AUCCAffineTransform@1@XZ"]
    pub fn cocos2d_CCAffineTransformMakeIdentity() -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCRectApplyAffineTransform@cocos2d@@YA?AVCCRect@1@ABV21@ABUCCAffineTransform@1@@Z"]
    pub fn cocos2d_CCRectApplyAffineTransform(
        rect: *const cocos2d_CCRect,
        anAffineTransform: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCRect;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformTranslate@cocos2d@@YA?AUCCAffineTransform@1@ABU21@MM@Z"]
    pub fn cocos2d_CCAffineTransformTranslate(
        t: *const cocos2d_CCAffineTransform,
        tx: f32,
        ty: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformRotate@cocos2d@@YA?AUCCAffineTransform@1@ABU21@M@Z"]
    pub fn cocos2d_CCAffineTransformRotate(
        aTransform: *const cocos2d_CCAffineTransform,
        anAngle: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformScale@cocos2d@@YA?AUCCAffineTransform@1@ABU21@MM@Z"]
    pub fn cocos2d_CCAffineTransformScale(
        t: *const cocos2d_CCAffineTransform,
        sx: f32,
        sy: f32,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformConcat@cocos2d@@YA?AUCCAffineTransform@1@ABU21@0@Z"]
    pub fn cocos2d_CCAffineTransformConcat(
        t1: *const cocos2d_CCAffineTransform,
        t2: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformEqualToTransform@cocos2d@@YA_NABUCCAffineTransform@1@0@Z"]
    pub fn cocos2d_CCAffineTransformEqualToTransform(
        t1: *const cocos2d_CCAffineTransform,
        t2: *const cocos2d_CCAffineTransform,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformInvert@cocos2d@@YA?AUCCAffineTransform@1@ABU21@@Z"]
    pub fn cocos2d_CCAffineTransformInvert(
        t: *const cocos2d_CCAffineTransform,
    ) -> cocos2d_CCAffineTransform;
}
extern "C" {
    #[link_name = "\u{1}?CCAffineTransformIdentity@cocos2d@@3UCCAffineTransform@1@B"]
    pub static cocos2d_CCAffineTransformIdentity: cocos2d_CCAffineTransform;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccArray {
    pub num: ::std::os::raw::c_uint,
    pub max: ::std::os::raw::c_uint,
    pub arr: *mut *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d__ccArray() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccArray>(),
        12usize,
        concat!("Size of: ", stringify!(cocos2d__ccArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccArray>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccArray),
            "::",
            stringify!(arr)
        )
    );
}
pub type cocos2d_ccArray = cocos2d__ccArray;
extern "C" {
    #[doc = " Allocates and initializes a new array with specified capacity"]
    #[link_name = "\u{1}?ccArrayNew@cocos2d@@YAPAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayNew(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_ccArray;
}
extern "C" {
    #[doc = " Frees array after removing all remaining objects. Silently ignores nil arr."]
    #[link_name = "\u{1}?ccArrayFree@cocos2d@@YAXAAPAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayFree(arr: *mut *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Doubles array capacity"]
    #[link_name = "\u{1}?ccArrayDoubleCapacity@cocos2d@@YAXPAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayDoubleCapacity(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Increases array capacity such that max >= num + extra."]
    #[link_name = "\u{1}?ccArrayEnsureExtraCapacity@cocos2d@@YAXPAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayEnsureExtraCapacity(
        arr: *mut cocos2d_ccArray,
        extra: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " shrinks the array so the memory footprint corresponds with the number of items"]
    #[link_name = "\u{1}?ccArrayShrink@cocos2d@@YAXPAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayShrink(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Returns index of first occurrence of object, NSNotFound if object not found."]
    #[link_name = "\u{1}?ccArrayGetIndexOfObject@cocos2d@@YAIPAU_ccArray@1@PAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayGetIndexOfObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a Boolean value that indicates whether object is present in array."]
    #[link_name = "\u{1}?ccArrayContainsObject@cocos2d@@YA_NPAU_ccArray@1@PAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayContainsObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " Appends an object. Behavior undefined if array doesn't have enough capacity."]
    #[link_name = "\u{1}?ccArrayAppendObject@cocos2d@@YAXPAU_ccArray@1@PAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayAppendObject(arr: *mut cocos2d_ccArray, object: *mut cocos2d_CCObject);
}
extern "C" {
    #[doc = " Appends an object. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccArrayAppendObjectWithResize@cocos2d@@YAXPAU_ccArray@1@PAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayAppendObjectWithResize(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Appends objects from plusArr to arr.\nBehavior undefined if arr doesn't have enough capacity."]
    #[link_name = "\u{1}?ccArrayAppendArray@cocos2d@@YAXPAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayAppendArray(arr: *mut cocos2d_ccArray, plusArr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Appends objects from plusArr to arr. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccArrayAppendArrayWithResize@cocos2d@@YAXPAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayAppendArrayWithResize(
        arr: *mut cocos2d_ccArray,
        plusArr: *mut cocos2d_ccArray,
    );
}
extern "C" {
    #[doc = " Inserts an object at index"]
    #[link_name = "\u{1}?ccArrayInsertObjectAtIndex@cocos2d@@YAXPAU_ccArray@1@PAVCCObject@1@I@Z"]
    pub fn cocos2d_ccArrayInsertObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Swaps two objects"]
    #[link_name = "\u{1}?ccArraySwapObjectsAtIndexes@cocos2d@@YAXPAU_ccArray@1@II@Z"]
    pub fn cocos2d_ccArraySwapObjectsAtIndexes(
        arr: *mut cocos2d_ccArray,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Removes all objects from arr"]
    #[link_name = "\u{1}?ccArrayRemoveAllObjects@cocos2d@@YAXPAU_ccArray@1@@Z"]
    pub fn cocos2d_ccArrayRemoveAllObjects(arr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Removes object at specified index and pushes back all subsequent objects.\nBehavior undefined if index outside [0, num-1]."]
    #[link_name = "\u{1}?ccArrayRemoveObjectAtIndex@cocos2d@@YAXPAU_ccArray@1@I_N@Z"]
    pub fn cocos2d_ccArrayRemoveObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        index: ::std::os::raw::c_uint,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Removes object at specified index and fills the gap with the last object,\nthereby avoiding the need to push back subsequent objects.\nBehavior undefined if index outside [0, num-1]."]
    #[link_name = "\u{1}?ccArrayFastRemoveObjectAtIndex@cocos2d@@YAXPAU_ccArray@1@I@Z"]
    pub fn cocos2d_ccArrayFastRemoveObjectAtIndex(
        arr: *mut cocos2d_ccArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccArrayFastRemoveObject@cocos2d@@YAXPAU_ccArray@1@PAVCCObject@1@@Z"]
    pub fn cocos2d_ccArrayFastRemoveObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[doc = " Searches for the first occurrence of object and removes it. If object is not\nfound the function has no effect."]
    #[link_name = "\u{1}?ccArrayRemoveObject@cocos2d@@YAXPAU_ccArray@1@PAVCCObject@1@_N@Z"]
    pub fn cocos2d_ccArrayRemoveObject(
        arr: *mut cocos2d_ccArray,
        object: *mut cocos2d_CCObject,
        bReleaseObj: bool,
    );
}
extern "C" {
    #[doc = " Removes from arr all objects in minusArr. For each object in minusArr, the\nfirst matching instance in arr will be removed."]
    #[link_name = "\u{1}?ccArrayRemoveArray@cocos2d@@YAXPAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayRemoveArray(arr: *mut cocos2d_ccArray, minusArr: *mut cocos2d_ccArray);
}
extern "C" {
    #[doc = " Removes from arr all objects in minusArr. For each object in minusArr, all\nmatching instances in arr will be removed."]
    #[link_name = "\u{1}?ccArrayFullRemoveArray@cocos2d@@YAXPAU_ccArray@1@0@Z"]
    pub fn cocos2d_ccArrayFullRemoveArray(
        arr: *mut cocos2d_ccArray,
        minusArr: *mut cocos2d_ccArray,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccCArray {
    pub num: ::std::os::raw::c_uint,
    pub max: ::std::os::raw::c_uint,
    pub arr: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d__ccCArray() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccCArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccCArray>(),
        12usize,
        concat!("Size of: ", stringify!(cocos2d__ccCArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccCArray>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccCArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccCArray),
            "::",
            stringify!(arr)
        )
    );
}
pub type cocos2d_ccCArray = cocos2d__ccCArray;
extern "C" {
    #[doc = " Allocates and initializes a new C array with specified capacity"]
    #[link_name = "\u{1}?ccCArrayNew@cocos2d@@YAPAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayNew(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_ccCArray;
}
extern "C" {
    #[doc = " Frees C array after removing all remaining values. Silently ignores nil arr."]
    #[link_name = "\u{1}?ccCArrayFree@cocos2d@@YAXPAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayFree(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Doubles C array capacity"]
    #[link_name = "\u{1}?ccCArrayDoubleCapacity@cocos2d@@YAXPAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayDoubleCapacity(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Increases array capacity such that max >= num + extra."]
    #[link_name = "\u{1}?ccCArrayEnsureExtraCapacity@cocos2d@@YAXPAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayEnsureExtraCapacity(
        arr: *mut cocos2d_ccCArray,
        extra: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Returns index of first occurrence of value, NSNotFound if value not found."]
    #[link_name = "\u{1}?ccCArrayGetIndexOfValue@cocos2d@@YAIPAU_ccCArray@1@PAX@Z"]
    pub fn cocos2d_ccCArrayGetIndexOfValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns a Boolean value that indicates whether value is present in the C array."]
    #[link_name = "\u{1}?ccCArrayContainsValue@cocos2d@@YA_NPAU_ccCArray@1@PAX@Z"]
    pub fn cocos2d_ccCArrayContainsValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Inserts a value at a certain position. Behavior undefined if array doesn't have enough capacity"]
    #[link_name = "\u{1}?ccCArrayInsertValueAtIndex@cocos2d@@YAXPAU_ccCArray@1@PAXI@Z"]
    pub fn cocos2d_ccCArrayInsertValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Appends an value. Behavior undefined if array doesn't have enough capacity."]
    #[link_name = "\u{1}?ccCArrayAppendValue@cocos2d@@YAXPAU_ccCArray@1@PAX@Z"]
    pub fn cocos2d_ccCArrayAppendValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Appends an value. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccCArrayAppendValueWithResize@cocos2d@@YAXPAU_ccCArray@1@PAX@Z"]
    pub fn cocos2d_ccCArrayAppendValueWithResize(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Appends values from plusArr to arr. Behavior undefined if arr doesn't have\nenough capacity."]
    #[link_name = "\u{1}?ccCArrayAppendArray@cocos2d@@YAXPAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayAppendArray(arr: *mut cocos2d_ccCArray, plusArr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Appends values from plusArr to arr. Capacity of arr is increased if needed."]
    #[link_name = "\u{1}?ccCArrayAppendArrayWithResize@cocos2d@@YAXPAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayAppendArrayWithResize(
        arr: *mut cocos2d_ccCArray,
        plusArr: *mut cocos2d_ccCArray,
    );
}
extern "C" {
    #[doc = " Removes all values from arr"]
    #[link_name = "\u{1}?ccCArrayRemoveAllValues@cocos2d@@YAXPAU_ccCArray@1@@Z"]
    pub fn cocos2d_ccCArrayRemoveAllValues(arr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Removes value at specified index and pushes back all subsequent values.\nBehavior undefined if index outside [0, num-1].\n@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveValueAtIndex@cocos2d@@YAXPAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayRemoveValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Removes value at specified index and fills the gap with the last value,\nthereby avoiding the need to push back subsequent values.\nBehavior undefined if index outside [0, num-1].\n@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayFastRemoveValueAtIndex@cocos2d@@YAXPAU_ccCArray@1@I@Z"]
    pub fn cocos2d_ccCArrayFastRemoveValueAtIndex(
        arr: *mut cocos2d_ccCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Searches for the first occurrence of value and removes it. If value is not found the function has no effect.\n@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveValue@cocos2d@@YAXPAU_ccCArray@1@PAX@Z"]
    pub fn cocos2d_ccCArrayRemoveValue(
        arr: *mut cocos2d_ccCArray,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Removes from arr all values in minusArr. For each Value in minusArr, the first matching instance in arr will be removed.\n@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayRemoveArray@cocos2d@@YAXPAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayRemoveArray(arr: *mut cocos2d_ccCArray, minusArr: *mut cocos2d_ccCArray);
}
extern "C" {
    #[doc = " Removes from arr all values in minusArr. For each value in minusArr, all matching instances in arr will be removed.\n@since v0.99.4"]
    #[link_name = "\u{1}?ccCArrayFullRemoveArray@cocos2d@@YAXPAU_ccCArray@1@0@Z"]
    pub fn cocos2d_ccCArrayFullRemoveArray(
        arr: *mut cocos2d_ccCArray,
        minusArr: *mut cocos2d_ccCArray,
    );
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCArray {
    pub _base: cocos2d_CCObject,
    pub data: *mut cocos2d_ccArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCArray() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCArray>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCArray>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Create an array"]
    #[link_name = "\u{1}?create@CCArray@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCArray_create() -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with some objects\n  @lua NA"]
    #[link_name = "\u{1}?create@CCArray@cocos2d@@SAPAV12@PAVCCObject@2@ZZ"]
    pub fn cocos2d_CCArray_create1(pObject: *mut cocos2d_CCObject, ...) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with one object"]
    #[link_name = "\u{1}?createWithObject@CCArray@cocos2d@@SAPAV12@PAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_createWithObject(pObject: *mut cocos2d_CCObject)
        -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with capacity"]
    #[link_name = "\u{1}?createWithCapacity@CCArray@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCArray_createWithCapacity(
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = " Create an array with an existing array"]
    #[link_name = "\u{1}?createWithArray@CCArray@cocos2d@@SAPAV12@PAV12@@Z"]
    pub fn cocos2d_CCArray_createWithArray(
        otherArray: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[doc = "@brief   Generate a CCArray pointer by file\n@param   pFileName  The file name of *.plist file\n@return  The CCArray pointer generated from the file"]
    #[link_name = "\u{1}?createWithContentsOfFile@CCArray@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCArray_createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray;
}
extern "C" {
    #[link_name = "\u{1}?createWithContentsOfFileThreadSafe@CCArray@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCArray_createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " Initializes an array\n  @lua NA"]
    #[link_name = "\u{1}?init@CCArray@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCArray_init(this: *mut cocos2d_CCArray) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes an array with one object\n  @lua NA"]
    #[link_name = "\u{1}?initWithObject@CCArray@cocos2d@@QAE_NPAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_initWithObject(
        this: *mut cocos2d_CCArray,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "C" {
    #[doc = " Initializes an array with some objects\n  @lua NA"]
    #[link_name = "\u{1}?initWithObjects@CCArray@cocos2d@@QAA_NPAVCCObject@2@ZZ"]
    pub fn cocos2d_CCArray_initWithObjects(
        this: *mut cocos2d_CCArray,
        pObject: *mut cocos2d_CCObject,
        ...
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes an array with capacity\n  @lua NA"]
    #[link_name = "\u{1}?initWithCapacity@CCArray@cocos2d@@QAE_NI@Z"]
    pub fn cocos2d_CCArray_initWithCapacity(
        this: *mut cocos2d_CCArray,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes an array with an existing array\n  @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCArray@cocos2d@@QAE_NPAV12@@Z"]
    pub fn cocos2d_CCArray_initWithArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Returns element count of the array"]
    #[link_name = "\u{1}?count@CCArray@cocos2d@@QBEIXZ"]
    pub fn cocos2d_CCArray_count(this: *const cocos2d_CCArray) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Returns capacity of the array"]
    #[link_name = "\u{1}?capacity@CCArray@cocos2d@@QBEIXZ"]
    pub fn cocos2d_CCArray_capacity(this: *const cocos2d_CCArray) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Returns index of a certain object, return UINT_MAX if doesn't contain the object"]
    #[link_name = "\u{1}?indexOfObject@CCArray@cocos2d@@QBEIPAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_indexOfObject(
        this: *const cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Returns an element with a certain index"]
    #[link_name = "\u{1}?objectAtIndex@CCArray@cocos2d@@QAEPAVCCObject@2@I@Z"]
    pub fn cocos2d_CCArray_objectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " Returns last element"]
    #[link_name = "\u{1}?lastObject@CCArray@cocos2d@@QAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCArray_lastObject(this: *mut cocos2d_CCArray) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " Returns a random element"]
    #[link_name = "\u{1}?randomObject@CCArray@cocos2d@@QAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCArray_randomObject(this: *mut cocos2d_CCArray) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " Returns a Boolean value that indicates whether object is present in array."]
    #[link_name = "\u{1}?containsObject@CCArray@cocos2d@@QBE_NPAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_containsObject(
        this: *const cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @since 1.1"]
    #[link_name = "\u{1}?isEqualToArray@CCArray@cocos2d@@QAE_NPAV12@@Z"]
    pub fn cocos2d_CCArray_isEqualToArray(
        this: *mut cocos2d_CCArray,
        pOtherArray: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Add a certain object"]
    #[link_name = "\u{1}?addObject@CCArray@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_addObject(this: *mut cocos2d_CCArray, object: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[doc = " Add all elements of an existing array"]
    #[link_name = "\u{1}?addObjectsFromArray@CCArray@cocos2d@@QAEXPAV12@@Z"]
    pub fn cocos2d_CCArray_addObjectsFromArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " Insert a certain object at a certain index"]
    #[link_name = "\u{1}?insertObject@CCArray@cocos2d@@QAEXPAVCCObject@2@I@Z"]
    pub fn cocos2d_CCArray_insertObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Remove last object"]
    #[link_name = "\u{1}?removeLastObject@CCArray@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCArray_removeLastObject(this: *mut cocos2d_CCArray, bReleaseObj: bool);
}
extern "thiscall" {
    #[doc = " Remove a certain object"]
    #[link_name = "\u{1}?removeObject@CCArray@cocos2d@@QAEXPAVCCObject@2@_N@Z"]
    pub fn cocos2d_CCArray_removeObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
        bReleaseObj: bool,
    );
}
extern "thiscall" {
    #[doc = " Remove an element with a certain index"]
    #[link_name = "\u{1}?removeObjectAtIndex@CCArray@cocos2d@@QAEXI_N@Z"]
    pub fn cocos2d_CCArray_removeObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
        bReleaseObj: bool,
    );
}
extern "thiscall" {
    #[doc = " Remove all elements"]
    #[link_name = "\u{1}?removeObjectsInArray@CCArray@cocos2d@@QAEXPAV12@@Z"]
    pub fn cocos2d_CCArray_removeObjectsInArray(
        this: *mut cocos2d_CCArray,
        otherArray: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " Remove all objects"]
    #[link_name = "\u{1}?removeAllObjects@CCArray@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCArray_removeAllObjects(this: *mut cocos2d_CCArray);
}
extern "thiscall" {
    #[doc = " Fast way to remove a certain object"]
    #[link_name = "\u{1}?fastRemoveObject@CCArray@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCArray_fastRemoveObject(
        this: *mut cocos2d_CCArray,
        object: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Fast way to remove an element with a certain index"]
    #[link_name = "\u{1}?fastRemoveObjectAtIndex@CCArray@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCArray_fastRemoveObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Swap two elements"]
    #[link_name = "\u{1}?exchangeObject@CCArray@cocos2d@@QAEXPAVCCObject@2@0@Z"]
    pub fn cocos2d_CCArray_exchangeObject(
        this: *mut cocos2d_CCArray,
        object1: *mut cocos2d_CCObject,
        object2: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Swap two elements with certain indexes"]
    #[link_name = "\u{1}?exchangeObjectAtIndex@CCArray@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCArray_exchangeObjectAtIndex(
        this: *mut cocos2d_CCArray,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Replace object at index with another object."]
    #[link_name = "\u{1}?replaceObjectAtIndex@CCArray@cocos2d@@QAEXIPAVCCObject@2@_N@Z"]
    pub fn cocos2d_CCArray_replaceObjectAtIndex(
        this: *mut cocos2d_CCArray,
        uIndex: ::std::os::raw::c_uint,
        pObject: *mut cocos2d_CCObject,
        bReleaseObject: bool,
    );
}
extern "thiscall" {
    #[doc = " Revers the array"]
    #[link_name = "\u{1}?reverseObjects@CCArray@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCArray_reverseObjects(this: *mut cocos2d_CCArray);
}
extern "thiscall" {
    #[link_name = "\u{1}?reduceMemoryFootprint@CCArray@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCArray_reduceMemoryFootprint(this: *mut cocos2d_CCArray);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCArray@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCArray_CCArray(this: *mut cocos2d_CCArray);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCArray@cocos2d@@QAE@I@Z"]
    pub fn cocos2d_CCArray_CCArray1(this: *mut cocos2d_CCArray, capacity: ::std::os::raw::c_uint);
}
impl cocos2d_CCArray {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCArray {
        cocos2d_CCArray_create()
    }
    #[inline]
    pub unsafe fn createWithObject(pObject: *mut cocos2d_CCObject) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithObject(pObject)
    }
    #[inline]
    pub unsafe fn createWithCapacity(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithCapacity(capacity)
    }
    #[inline]
    pub unsafe fn createWithArray(otherArray: *mut cocos2d_CCArray) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithArray(otherArray)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithContentsOfFile(pFileName)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCArray_createWithContentsOfFileThreadSafe(pFileName)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCArray_init(self)
    }
    #[inline]
    pub unsafe fn initWithObject(&mut self, pObject: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCArray_initWithObject(self, pObject)
    }
    #[inline]
    pub unsafe fn initWithCapacity(&mut self, capacity: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCArray_initWithCapacity(self, capacity)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, otherArray: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCArray_initWithArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_count(self)
    }
    #[inline]
    pub unsafe fn capacity(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_capacity(self)
    }
    #[inline]
    pub unsafe fn indexOfObject(&self, object: *mut cocos2d_CCObject) -> ::std::os::raw::c_uint {
        cocos2d_CCArray_indexOfObject(self, object)
    }
    #[inline]
    pub unsafe fn objectAtIndex(&mut self, index: ::std::os::raw::c_uint) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_objectAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn lastObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_lastObject(self)
    }
    #[inline]
    pub unsafe fn randomObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCArray_randomObject(self)
    }
    #[inline]
    pub unsafe fn containsObject(&self, object: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCArray_containsObject(self, object)
    }
    #[inline]
    pub unsafe fn isEqualToArray(&mut self, pOtherArray: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCArray_isEqualToArray(self, pOtherArray)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, object: *mut cocos2d_CCObject) {
        cocos2d_CCArray_addObject(self, object)
    }
    #[inline]
    pub unsafe fn addObjectsFromArray(&mut self, otherArray: *mut cocos2d_CCArray) {
        cocos2d_CCArray_addObjectsFromArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn insertObject(
        &mut self,
        object: *mut cocos2d_CCObject,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCArray_insertObject(self, object, index)
    }
    #[inline]
    pub unsafe fn removeLastObject(&mut self, bReleaseObj: bool) {
        cocos2d_CCArray_removeLastObject(self, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, object: *mut cocos2d_CCObject, bReleaseObj: bool) {
        cocos2d_CCArray_removeObject(self, object, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObjectAtIndex(&mut self, index: ::std::os::raw::c_uint, bReleaseObj: bool) {
        cocos2d_CCArray_removeObjectAtIndex(self, index, bReleaseObj)
    }
    #[inline]
    pub unsafe fn removeObjectsInArray(&mut self, otherArray: *mut cocos2d_CCArray) {
        cocos2d_CCArray_removeObjectsInArray(self, otherArray)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCArray_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn fastRemoveObject(&mut self, object: *mut cocos2d_CCObject) {
        cocos2d_CCArray_fastRemoveObject(self, object)
    }
    #[inline]
    pub unsafe fn fastRemoveObjectAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCArray_fastRemoveObjectAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn exchangeObject(
        &mut self,
        object1: *mut cocos2d_CCObject,
        object2: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCArray_exchangeObject(self, object1, object2)
    }
    #[inline]
    pub unsafe fn exchangeObjectAtIndex(
        &mut self,
        index1: ::std::os::raw::c_uint,
        index2: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCArray_exchangeObjectAtIndex(self, index1, index2)
    }
    #[inline]
    pub unsafe fn replaceObjectAtIndex(
        &mut self,
        uIndex: ::std::os::raw::c_uint,
        pObject: *mut cocos2d_CCObject,
        bReleaseObject: bool,
    ) {
        cocos2d_CCArray_replaceObjectAtIndex(self, uIndex, pObject, bReleaseObject)
    }
    #[inline]
    pub unsafe fn reverseObjects(&mut self) {
        cocos2d_CCArray_reverseObjects(self)
    }
    #[inline]
    pub unsafe fn reduceMemoryFootprint(&mut self) {
        cocos2d_CCArray_reduceMemoryFootprint(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCArray_CCArray(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(capacity: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCArray_CCArray1(__bindgen_tmp.as_mut_ptr(), capacity);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??1CCArray@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCArray_CCArray_destructor(this: *mut cocos2d_CCArray);
}
extern "thiscall" {
    #[doc = " override functions\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCArray@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCArray_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?acceptVisitor@CCArray@cocos2d@@UAEXAAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCArray_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
pub const kCCVertexAttribFlag_None: cocos2d__bindgen_ty_2 = 0;
pub const kCCVertexAttribFlag_Position: cocos2d__bindgen_ty_2 = 1;
pub const kCCVertexAttribFlag_Color: cocos2d__bindgen_ty_2 = 2;
pub const kCCVertexAttribFlag_TexCoords: cocos2d__bindgen_ty_2 = 4;
pub const kCCVertexAttribFlag_PosColorTex: cocos2d__bindgen_ty_2 = 7;
#[doc = " vertex attrib flags"]
pub type cocos2d__bindgen_ty_2 = ::std::os::raw::c_int;
pub const cocos2d_ccGLServerState_CC_GL_ALL: cocos2d_ccGLServerState = 0;
#[doc = " GL server side states"]
pub type cocos2d_ccGLServerState = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Invalidates the GL state cache.\nIf CC_ENABLE_GL_STATE_CACHE it will reset the GL state cache.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLInvalidateStateCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccGLInvalidateStateCache();
}
extern "C" {
    #[doc = " Uses the GL program in case program is different than the current one.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will the glUseProgram() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLUseProgram@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLUseProgram(program: GLuint);
}
extern "C" {
    #[doc = " Deletes the GL program. If it is the one that is being used, it invalidates it.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will the glDeleteProgram() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLDeleteProgram@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLDeleteProgram(program: GLuint);
}
extern "C" {
    #[doc = " Uses a blending function in case it not already used.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will the glBlendFunc() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBlendFunc@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLBlendFunc(sfactor: GLenum, dfactor: GLenum);
}
extern "C" {
    #[doc = " Resets the blending mode back to the cached state in case you used glBlendFuncSeparate() or glBlendEquation().\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will just set the default blending mode using GL_FUNC_ADD.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBlendResetToCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccGLBlendResetToCache();
}
extern "C" {
    #[doc = " sets the projection matrix as dirty\n@since v2.0.0"]
    #[link_name = "\u{1}?ccSetProjectionMatrixDirty@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccSetProjectionMatrixDirty();
}
extern "C" {
    #[doc = " Will enable the vertex attribs that are passed as flags.\nPossible flags:\n\n kCCVertexAttribFlag_Position\n kCCVertexAttribFlag_Color\n kCCVertexAttribFlag_TexCoords\n\nThese flags can be ORed. The flags that are not present, will be disabled.\n\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLEnableVertexAttribs@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLEnableVertexAttribs(flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " If the texture is not already bound to texture unit 0, it binds it.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindTexture() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBindTexture2D@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLBindTexture2D(textureId: GLuint);
}
extern "C" {
    #[doc = " If the texture is not already bound to a given unit, it binds it.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindTexture() directly.\n@since v2.1.0"]
    #[link_name = "\u{1}?ccGLBindTexture2DN@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLBindTexture2DN(textureUnit: GLuint, textureId: GLuint);
}
extern "C" {
    #[doc = " It will delete a given texture. If the texture was bound, it will invalidate the cached.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glDeleteTextures() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLDeleteTexture@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLDeleteTexture(textureId: GLuint);
}
extern "C" {
    #[doc = " It will delete a given texture. If the texture was bound, it will invalidate the cached for the given texture unit.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glDeleteTextures() directly.\n@since v2.1.0"]
    #[link_name = "\u{1}?ccGLDeleteTextureN@cocos2d@@YAXII@Z"]
    pub fn cocos2d_ccGLDeleteTextureN(textureUnit: GLuint, textureId: GLuint);
}
extern "C" {
    #[doc = " If the vertex array is not already bound, it binds it.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glBindVertexArray() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLBindVAO@cocos2d@@YAXI@Z"]
    pub fn cocos2d_ccGLBindVAO(vaoId: GLuint);
}
extern "C" {
    #[doc = " It will enable / disable the server side GL states.\nIf CC_ENABLE_GL_STATE_CACHE is disabled, it will call glEnable() directly.\n@since v2.0.0"]
    #[link_name = "\u{1}?ccGLEnable@cocos2d@@YAXW4ccGLServerState@1@@Z"]
    pub fn cocos2d_ccGLEnable(flags: cocos2d_ccGLServerState);
}
pub const kCCVertexAttrib_Position: cocos2d__bindgen_ty_3 = 0;
pub const kCCVertexAttrib_Color: cocos2d__bindgen_ty_3 = 1;
pub const kCCVertexAttrib_TexCoords: cocos2d__bindgen_ty_3 = 2;
pub const kCCVertexAttrib_MAX: cocos2d__bindgen_ty_3 = 3;
#[doc = " @addtogroup shaders\n @{"]
pub type cocos2d__bindgen_ty_3 = ::std::os::raw::c_int;
pub const kCCUniformPMatrix: cocos2d__bindgen_ty_4 = 0;
pub const kCCUniformMVMatrix: cocos2d__bindgen_ty_4 = 1;
pub const kCCUniformMVPMatrix: cocos2d__bindgen_ty_4 = 2;
pub const kCCUniformTime: cocos2d__bindgen_ty_4 = 3;
pub const kCCUniformSinTime: cocos2d__bindgen_ty_4 = 4;
pub const kCCUniformCosTime: cocos2d__bindgen_ty_4 = 5;
pub const kCCUniformRandom01: cocos2d__bindgen_ty_4 = 6;
pub const kCCUniformSampler: cocos2d__bindgen_ty_4 = 7;
pub const kCCUniform_MAX: cocos2d__bindgen_ty_4 = 8;
pub type cocos2d__bindgen_ty_4 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashUniformEntry {
    _unused: [u8; 0],
}
pub type cocos2d_GLInfoFunction =
    ::std::option::Option<unsafe extern "C" fn(program: GLuint, pname: GLenum, params: *mut GLint)>;
pub type cocos2d_GLLogFunction = ::std::option::Option<
    unsafe extern "C" fn(
        program: GLuint,
        bufsize: GLsizei,
        length: *mut GLsizei,
        infolog: *mut GLchar,
    ),
>;
#[doc = " @addtogroup shaders\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGLProgram {
    pub _base: cocos2d_CCObject,
    pub m_uProgram: GLuint,
    pub m_uVertShader: GLuint,
    pub m_uFragShader: GLuint,
    pub m_uUniforms: [GLint; 8usize],
    pub m_pHashForUniforms: *mut cocos2d__hashUniformEntry,
    pub m_bUsesTime: bool,
    pub m_hasShaderCompiler: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGLProgram() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCGLProgram> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGLProgram>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCGLProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGLProgram>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGLProgram))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uProgram) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uProgram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uVertShader) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uVertShader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uFragShader) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uFragShader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uUniforms) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_uUniforms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHashForUniforms) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_pHashForUniforms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUsesTime) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_bUsesTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hasShaderCompiler) as usize - ptr as usize },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGLProgram),
            "::",
            stringify!(m_hasShaderCompiler)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes the CCGLProgram with a vertex and fragment with bytes array\n @js  initWithString\n @lua NA"]
    #[link_name = "\u{1}?initWithVertexShaderByteArray@CCGLProgram@cocos2d@@QAE_NPBD0@Z"]
    pub fn cocos2d_CCGLProgram_initWithVertexShaderByteArray(
        this: *mut cocos2d_CCGLProgram,
        vShaderByteArray: *const GLchar,
        fShaderByteArray: *const GLchar,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes the CCGLProgram with a vertex and fragment with contents of filenames\n @js  init\n @lua NA"]
    #[link_name = "\u{1}?initWithVertexShaderFilename@CCGLProgram@cocos2d@@QAE_NPBD0@Z"]
    pub fn cocos2d_CCGLProgram_initWithVertexShaderFilename(
        this: *mut cocos2d_CCGLProgram,
        vShaderFilename: *const ::std::os::raw::c_char,
        fShaderFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  It will add a new attribute to the shader\n @lua NA"]
    #[link_name = "\u{1}?addAttribute@CCGLProgram@cocos2d@@QAEXPBDI@Z"]
    pub fn cocos2d_CCGLProgram_addAttribute(
        this: *mut cocos2d_CCGLProgram,
        attributeName: *const ::std::os::raw::c_char,
        index: GLuint,
    );
}
extern "thiscall" {
    #[doc = " links the glProgram\n @lua NA"]
    #[link_name = "\u{1}?link@CCGLProgram@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCGLProgram_link(this: *mut cocos2d_CCGLProgram) -> bool;
}
extern "thiscall" {
    #[doc = " it will call glUseProgram()\n @lua NA"]
    #[link_name = "\u{1}?use@CCGLProgram@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGLProgram_use(this: *mut cocos2d_CCGLProgram);
}
extern "thiscall" {
    #[doc = " It will create 4 uniforms:\n- kCCUniformPMatrix\n- kCCUniformMVMatrix\n- kCCUniformMVPMatrix\n- kCCUniformSampler\n\nAnd it will bind \"kCCUniformSampler\" to 0\n @lua NA"]
    #[link_name = "\u{1}?updateUniforms@CCGLProgram@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGLProgram_updateUniforms(this: *mut cocos2d_CCGLProgram);
}
extern "thiscall" {
    #[doc = " calls retrieves the named uniform location for this shader program.\n @lua NA"]
    #[link_name = "\u{1}?getUniformLocationForName@CCGLProgram@cocos2d@@QAEHPBD@Z"]
    pub fn cocos2d_CCGLProgram_getUniformLocationForName(
        this: *mut cocos2d_CCGLProgram,
        name: *const ::std::os::raw::c_char,
    ) -> GLint;
}
extern "thiscall" {
    #[doc = " calls glUniform1i only if the values are different than the previous call for this same shader program.\n  @js  setUniformLocationI32\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith1i@CCGLProgram@cocos2d@@QAEXHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith1i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform2i only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2i@CCGLProgram@cocos2d@@QAEXHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform3i only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3i@CCGLProgram@cocos2d@@QAEXHHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform4i only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4i@CCGLProgram@cocos2d@@QAEXHHHHH@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4i(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
        i4: GLint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform2iv only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2iv@CCGLProgram@cocos2d@@QAEXHPAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform3iv only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3iv@CCGLProgram@cocos2d@@QAEXHPAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform4iv only if the values are different than the previous call for this same shader program.\n @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4iv@CCGLProgram@cocos2d@@QAEXHPAHI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4iv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform1f only if the values are different than the previous call for this same shader program.\n  @js  setUniformLocationF32\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith1f@CCGLProgram@cocos2d@@QAEXHM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith1f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform2f only if the values are different than the previous call for this same shader program.\n  @js  setUniformLocationF32\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2f@CCGLProgram@cocos2d@@QAEXHMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform3f only if the values are different than the previous call for this same shader program.\n  @js  setUniformLocationF32\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3f@CCGLProgram@cocos2d@@QAEXHMMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform4f only if the values are different than the previous call for this same shader program.\n  @js  setUniformLocationF32\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4f@CCGLProgram@cocos2d@@QAEXHMMMM@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4f(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
        f4: GLfloat,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform2fv only if the values are different than the previous call for this same shader program.\n  @js  NA\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith2fv@CCGLProgram@cocos2d@@QAEXHPAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith2fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform3fv only if the values are different than the previous call for this same shader program.\n  @js  NA\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith3fv@CCGLProgram@cocos2d@@QAEXHPAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith3fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniform4fv only if the values are different than the previous call for this same shader program.\n  @js  NA\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWith4fv@CCGLProgram@cocos2d@@QAEXHPAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWith4fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calls glUniformMatrix4fv only if the values are different than the previous call for this same shader program.\n  @js  NA\n  @lua NA"]
    #[link_name = "\u{1}?setUniformLocationWithMatrix4fv@CCGLProgram@cocos2d@@QAEXHPAMI@Z"]
    pub fn cocos2d_CCGLProgram_setUniformLocationWithMatrix4fv(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        matrixArray: *mut GLfloat,
        numberOfMatrices: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " will update the builtin uniforms if they are different than the previous call for this same shader program.\n  @lua NA"]
    #[link_name = "\u{1}?setUniformsForBuiltins@CCGLProgram@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGLProgram_setUniformsForBuiltins(this: *mut cocos2d_CCGLProgram);
}
extern "thiscall" {
    #[doc = " returns the vertexShader error log\n  @js  getVertexShaderLog\n  @lua NA"]
    #[link_name = "\u{1}?vertexShaderLog@CCGLProgram@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCGLProgram_vertexShaderLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " returns the fragmentShader error log\n  @js  getFragmentShaderLog\n  @lua NA"]
    #[link_name = "\u{1}?fragmentShaderLog@CCGLProgram@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCGLProgram_fragmentShaderLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " returns the program error log\n  @js  getProgramLog\n  @lua NA"]
    #[link_name = "\u{1}?programLog@CCGLProgram@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCGLProgram_programLog(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " reload all shaders, this function is designed for android\n  when opengl context lost, so don't call it.\n  @lua NA"]
    #[link_name = "\u{1}?reset@CCGLProgram@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGLProgram_reset(this: *mut cocos2d_CCGLProgram);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateUniformLocation@CCGLProgram@cocos2d@@IAE_NHPAXI@Z"]
    pub fn cocos2d_CCGLProgram_updateUniformLocation(
        this: *mut cocos2d_CCGLProgram,
        location: GLint,
        data: *mut GLvoid,
        bytes: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?description@CCGLProgram@cocos2d@@IAEPBDXZ"]
    pub fn cocos2d_CCGLProgram_description(
        this: *mut cocos2d_CCGLProgram,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?compileShader@CCGLProgram@cocos2d@@IAE_NPAIIPBD@Z"]
    pub fn cocos2d_CCGLProgram_compileShader(
        this: *mut cocos2d_CCGLProgram,
        shader: *mut GLuint,
        type_: GLenum,
        source: *const GLchar,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?logForOpenGLObject@CCGLProgram@cocos2d@@IAEPBDIP6AXIIPAH@ZP6AXIH0PAD@Z@Z"]
    pub fn cocos2d_CCGLProgram_logForOpenGLObject(
        this: *mut cocos2d_CCGLProgram,
        object: GLuint,
        infoFunc: cocos2d_GLInfoFunction,
        logFunc: cocos2d_GLLogFunction,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " @js  ctor\n @lua NA"]
    #[link_name = "\u{1}??0CCGLProgram@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCGLProgram_CCGLProgram(this: *mut cocos2d_CCGLProgram);
}
impl cocos2d_CCGLProgram {
    #[inline]
    pub unsafe fn initWithVertexShaderByteArray(
        &mut self,
        vShaderByteArray: *const GLchar,
        fShaderByteArray: *const GLchar,
    ) -> bool {
        cocos2d_CCGLProgram_initWithVertexShaderByteArray(self, vShaderByteArray, fShaderByteArray)
    }
    #[inline]
    pub unsafe fn initWithVertexShaderFilename(
        &mut self,
        vShaderFilename: *const ::std::os::raw::c_char,
        fShaderFilename: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCGLProgram_initWithVertexShaderFilename(self, vShaderFilename, fShaderFilename)
    }
    #[inline]
    pub unsafe fn addAttribute(
        &mut self,
        attributeName: *const ::std::os::raw::c_char,
        index: GLuint,
    ) {
        cocos2d_CCGLProgram_addAttribute(self, attributeName, index)
    }
    #[inline]
    pub unsafe fn link(&mut self) -> bool {
        cocos2d_CCGLProgram_link(self)
    }
    #[inline]
    pub unsafe fn use_(&mut self) {
        cocos2d_CCGLProgram_use(self)
    }
    #[inline]
    pub unsafe fn updateUniforms(&mut self) {
        cocos2d_CCGLProgram_updateUniforms(self)
    }
    #[inline]
    pub unsafe fn getUniformLocationForName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> GLint {
        cocos2d_CCGLProgram_getUniformLocationForName(self, name)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith1i(&mut self, location: GLint, i1: GLint) {
        cocos2d_CCGLProgram_setUniformLocationWith1i(self, location, i1)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2i(&mut self, location: GLint, i1: GLint, i2: GLint) {
        cocos2d_CCGLProgram_setUniformLocationWith2i(self, location, i1, i2)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3i(
        &mut self,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3i(self, location, i1, i2, i3)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4i(
        &mut self,
        location: GLint,
        i1: GLint,
        i2: GLint,
        i3: GLint,
        i4: GLint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4i(self, location, i1, i2, i3, i4)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith2iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4iv(
        &mut self,
        location: GLint,
        ints: *mut GLint,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4iv(self, location, ints, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith1f(&mut self, location: GLint, f1: GLfloat) {
        cocos2d_CCGLProgram_setUniformLocationWith1f(self, location, f1)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2f(&mut self, location: GLint, f1: GLfloat, f2: GLfloat) {
        cocos2d_CCGLProgram_setUniformLocationWith2f(self, location, f1, f2)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3f(
        &mut self,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3f(self, location, f1, f2, f3)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4f(
        &mut self,
        location: GLint,
        f1: GLfloat,
        f2: GLfloat,
        f3: GLfloat,
        f4: GLfloat,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4f(self, location, f1, f2, f3, f4)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith2fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith2fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith3fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith3fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWith4fv(
        &mut self,
        location: GLint,
        floats: *mut GLfloat,
        numberOfArrays: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWith4fv(self, location, floats, numberOfArrays)
    }
    #[inline]
    pub unsafe fn setUniformLocationWithMatrix4fv(
        &mut self,
        location: GLint,
        matrixArray: *mut GLfloat,
        numberOfMatrices: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCGLProgram_setUniformLocationWithMatrix4fv(
            self,
            location,
            matrixArray,
            numberOfMatrices,
        )
    }
    #[inline]
    pub unsafe fn setUniformsForBuiltins(&mut self) {
        cocos2d_CCGLProgram_setUniformsForBuiltins(self)
    }
    #[inline]
    pub unsafe fn vertexShaderLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_vertexShaderLog(self)
    }
    #[inline]
    pub unsafe fn fragmentShaderLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_fragmentShaderLog(self)
    }
    #[inline]
    pub unsafe fn programLog(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_programLog(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCGLProgram_reset(self)
    }
    #[inline]
    pub unsafe fn updateUniformLocation(
        &mut self,
        location: GLint,
        data: *mut GLvoid,
        bytes: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCGLProgram_updateUniformLocation(self, location, data, bytes)
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_description(self)
    }
    #[inline]
    pub unsafe fn compileShader(
        &mut self,
        shader: *mut GLuint,
        type_: GLenum,
        source: *const GLchar,
    ) -> bool {
        cocos2d_CCGLProgram_compileShader(self, shader, type_, source)
    }
    #[inline]
    pub unsafe fn logForOpenGLObject(
        &mut self,
        object: GLuint,
        infoFunc: cocos2d_GLInfoFunction,
        logFunc: cocos2d_GLLogFunction,
    ) -> *const ::std::os::raw::c_char {
        cocos2d_CCGLProgram_logForOpenGLObject(self, object, infoFunc, logFunc)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGLProgram_CCGLProgram(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCGLProgram@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCGLProgram_CCGLProgram_destructor(this: *mut cocos2d_CCGLProgram);
}
#[doc = "@brief The device accelerometer reports values for each axis in units of g-force"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAcceleration {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub timestamp: f64,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAcceleration() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAcceleration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAcceleration>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d_CCAcceleration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAcceleration>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAcceleration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAcceleration),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct cocos2d_CCAccelerometerDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = "@brief\nThe CCAccelerometerDelegate defines a single method for\nreceiving acceleration-related data from the system.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCAccelerometerDelegate {
    pub vtable_: *const cocos2d_CCAccelerometerDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelerometerDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelerometerDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelerometerDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelerometerDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelerometerDelegate))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelerometer {
    pub m_obAccelerationValue: cocos2d_CCAcceleration,
    pub m_pAccelDelegate: *mut cocos2d_CCAccelerometerDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelerometer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAccelerometer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelerometer>(),
        40usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelerometer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelerometer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelerometer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obAccelerationValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelerometer),
            "::",
            stringify!(m_obAccelerationValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAccelDelegate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelerometer),
            "::",
            stringify!(m_pAccelDelegate)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCAccelerometer@cocos2d@@QAEXPAVCCAccelerometerDelegate@2@@Z"]
    pub fn cocos2d_CCAccelerometer_setDelegate(
        this: *mut cocos2d_CCAccelerometer,
        pDelegate: *mut cocos2d_CCAccelerometerDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setAccelerometerInterval@CCAccelerometer@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCAccelerometer_setAccelerometerInterval(
        this: *mut cocos2d_CCAccelerometer,
        interval: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCAccelerometer@cocos2d@@QAEXNNNN@Z"]
    pub fn cocos2d_CCAccelerometer_update(
        this: *mut cocos2d_CCAccelerometer,
        x: f64,
        y: f64,
        z: f64,
        timestamp: f64,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCAccelerometer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAccelerometer_CCAccelerometer(this: *mut cocos2d_CCAccelerometer);
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCAccelerometer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAccelerometer_CCAccelerometer_destructor(this: *mut cocos2d_CCAccelerometer);
}
impl cocos2d_CCAccelerometer {
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCAccelerometerDelegate) {
        cocos2d_CCAccelerometer_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn setAccelerometerInterval(&mut self, interval: f32) {
        cocos2d_CCAccelerometer_setAccelerometerInterval(self, interval)
    }
    #[inline]
    pub unsafe fn update(&mut self, x: f64, y: f64, z: f64, timestamp: f64) {
        cocos2d_CCAccelerometer_update(self, x, y, z, timestamp)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAccelerometer_CCAccelerometer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCAccelerometer_CCAccelerometer_destructor(self)
    }
}
#[doc = " @addtogroup input\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouch {
    pub _base: cocos2d_CCObject,
    pub m_nId: ::std::os::raw::c_int,
    pub m_startPointCaptured: bool,
    pub m_startPoint: cocos2d_CCPoint,
    pub m_point: cocos2d_CCPoint,
    pub m_prevPoint: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouch() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTouch> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouch>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouch))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouch>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nId) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_nId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPointCaptured) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_startPointCaptured)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPoint) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_startPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_point) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_prevPoint) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouch),
            "::",
            stringify!(m_prevPoint)
        )
    );
}
extern "thiscall" {
    #[doc = " returns the current touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getLocation@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the previous touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getPreviousLocation@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getPreviousLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the start touch location in OpenGL coordinates"]
    #[link_name = "\u{1}?getStartLocation@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getStartLocation(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the delta of 2 current touches locations in screen coordinates"]
    #[link_name = "\u{1}?getDelta@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getDelta(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the current touch location in screen coordinates"]
    #[link_name = "\u{1}?getLocationInView@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getLocationInView(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the previous touch location in screen coordinates"]
    #[link_name = "\u{1}?getPreviousLocationInView@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getPreviousLocationInView(
        this: *const cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " returns the start touch location in screen coordinates"]
    #[link_name = "\u{1}?getStartLocationInView@CCTouch@cocos2d@@QBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCTouch_getStartLocationInView(this: *const cocos2d_CCTouch) -> cocos2d_CCPoint;
}
impl cocos2d_CCTouch {
    #[inline]
    pub unsafe fn getLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getLocation(self)
    }
    #[inline]
    pub unsafe fn getPreviousLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getPreviousLocation(self)
    }
    #[inline]
    pub unsafe fn getStartLocation(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getStartLocation(self)
    }
    #[inline]
    pub unsafe fn getDelta(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getDelta(self)
    }
    #[inline]
    pub unsafe fn getLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getLocationInView(self)
    }
    #[inline]
    pub unsafe fn getPreviousLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getPreviousLocationInView(self)
    }
    #[inline]
    pub unsafe fn getStartLocationInView(&self) -> cocos2d_CCPoint {
        cocos2d_CCTouch_getStartLocationInView(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEvent {
    pub _base: cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEvent() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEvent>(),
        52usize,
        concat!("Size of: ", stringify!(cocos2d_CCEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEvent))
    );
}
#[doc = " @addtogroup data_structures\n @{"]
pub type cocos2d_CCSetIterator = u8;
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSet {
    pub _base: cocos2d_CCObject,
    pub m_pSet: *mut [u32; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCSet() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSet>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCSet))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSet>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSet) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSet),
            "::",
            stringify!(m_pSet)
        )
    );
}
extern "C" {
    #[doc = " @brief Create and return a new empty set.\n @lua NA"]
    #[link_name = "\u{1}?create@CCSet@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCSet_create() -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = "@brief Return a copy of the CCSet, it will copy all the elements."]
    #[link_name = "\u{1}?copy@CCSet@cocos2d@@QAEPAV12@XZ"]
    pub fn cocos2d_CCSet_copy(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = "@brief It is the same as copy().\n@lua NA"]
    #[link_name = "\u{1}?mutableCopy@CCSet@cocos2d@@QAEPAV12@XZ"]
    pub fn cocos2d_CCSet_mutableCopy(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = "@brief Return the number of elements the CCSet contains."]
    #[link_name = "\u{1}?count@CCSet@cocos2d@@QAEHXZ"]
    pub fn cocos2d_CCSet_count(this: *mut cocos2d_CCSet) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = "@brief Add a element into CCSet, it will retain the element."]
    #[link_name = "\u{1}?addObject@CCSet@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_addObject(this: *mut cocos2d_CCSet, pObject: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[doc = "@brief Remove the given element, nothing todo if no element equals pObject."]
    #[link_name = "\u{1}?removeObject@CCSet@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_removeObject(this: *mut cocos2d_CCSet, pObject: *mut cocos2d_CCObject);
}
extern "thiscall" {
    #[doc = "@brief Remove all elements of the set"]
    #[link_name = "\u{1}?removeAllObjects@CCSet@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCSet_removeAllObjects(this: *mut cocos2d_CCSet);
}
extern "thiscall" {
    #[doc = "@brief Check if CCSet contains a element equals pObject."]
    #[link_name = "\u{1}?containsObject@CCSet@cocos2d@@QAE_NPAVCCObject@2@@Z"]
    pub fn cocos2d_CCSet_containsObject(
        this: *mut cocos2d_CCSet,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief Return the iterator that points to the first element.\n@js NA\n@lua NA"]
    #[link_name = "\u{1}?begin@CCSet@cocos2d@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVCCObject@cocos2d@@@std@@@std@@@std@@XZ"]
    pub fn cocos2d_CCSet_begin(this: *mut cocos2d_CCSet) -> cocos2d_CCSetIterator;
}
extern "thiscall" {
    #[doc = "@brief Return the iterator that points to the position after the last element.\n@js NA\n@lua NA"]
    #[link_name = "\u{1}?end@CCSet@cocos2d@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVCCObject@cocos2d@@@std@@@std@@@std@@XZ"]
    pub fn cocos2d_CCSet_end(this: *mut cocos2d_CCSet) -> cocos2d_CCSetIterator;
}
extern "thiscall" {
    #[doc = "@brief Return the first element if it contains elements, or null if it doesn't contain any element."]
    #[link_name = "\u{1}?anyObject@CCSet@cocos2d@@QAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCSet_anyObject(this: *mut cocos2d_CCSet) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " @js  ctor\n @lua NA"]
    #[link_name = "\u{1}??0CCSet@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSet_CCSet(this: *mut cocos2d_CCSet);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCSet@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCSet_CCSet1(this: *mut cocos2d_CCSet, rSetObject: *const cocos2d_CCSet);
}
impl cocos2d_CCSet {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCSet {
        cocos2d_CCSet_create()
    }
    #[inline]
    pub unsafe fn copy(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCSet_copy(self)
    }
    #[inline]
    pub unsafe fn mutableCopy(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCSet_mutableCopy(self)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCSet_count(self)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCSet_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCSet_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCSet_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn containsObject(&mut self, pObject: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCSet_containsObject(self, pObject)
    }
    #[inline]
    pub unsafe fn begin(&mut self) -> cocos2d_CCSetIterator {
        cocos2d_CCSet_begin(self)
    }
    #[inline]
    pub unsafe fn end(&mut self) -> cocos2d_CCSetIterator {
        cocos2d_CCSet_end(self)
    }
    #[inline]
    pub unsafe fn anyObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCSet_anyObject(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSet_CCSet(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rSetObject: *const cocos2d_CCSet) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSet_CCSet1(__bindgen_tmp.as_mut_ptr(), rSetObject);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSet@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSet_CCSet_destructor(this: *mut cocos2d_CCSet);
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?acceptVisitor@CCSet@cocos2d@@UAEXAAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCSet_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
pub const cocos2d_ccScriptType_kScriptTypeNone: cocos2d_ccScriptType = 0;
pub const cocos2d_ccScriptType_kScriptTypeLua: cocos2d_ccScriptType = 1;
pub const cocos2d_ccScriptType_kScriptTypeJavascript: cocos2d_ccScriptType = 2;
pub type cocos2d_ccScriptType = ::std::os::raw::c_int;
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptHandlerEntry {
    pub _base: cocos2d_CCObject,
    pub m_nHandler: ::std::os::raw::c_int,
    pub m_nEntryId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScriptHandlerEntry() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCScriptHandlerEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptHandlerEntry>(),
        60usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptHandlerEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptHandlerEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptHandlerEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nHandler) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptHandlerEntry),
            "::",
            stringify!(m_nHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nEntryId) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptHandlerEntry),
            "::",
            stringify!(m_nEntryId)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCScriptHandlerEntry@cocos2d@@SAPAV12@H@Z"]
    pub fn cocos2d_CCScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCScriptHandlerEntry;
}
impl cocos2d_CCScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCScriptHandlerEntry {
        cocos2d_CCScriptHandlerEntry_create(nHandler)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCScriptHandlerEntry@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCScriptHandlerEntry_CCScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCScriptHandlerEntry,
    );
}
#[doc = " @addtogroup script_support\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSchedulerScriptHandlerEntry {
    pub _base: cocos2d_CCScriptHandlerEntry,
    pub m_pTimer: *mut cocos2d_CCTimer,
    pub m_bPaused: bool,
    pub m_bMarkedForDeletion: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSchedulerScriptHandlerEntry() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSchedulerScriptHandlerEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSchedulerScriptHandlerEntry>(),
        68usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSchedulerScriptHandlerEntry>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTimer) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_pTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPaused) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_bPaused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bMarkedForDeletion) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSchedulerScriptHandlerEntry),
            "::",
            stringify!(m_bMarkedForDeletion)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCSchedulerScriptHandlerEntry@cocos2d@@SAPAV12@HM_N@Z"]
    pub fn cocos2d_CCSchedulerScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
        fInterval: f32,
        bPaused: bool,
    ) -> *mut cocos2d_CCSchedulerScriptHandlerEntry;
}
impl cocos2d_CCSchedulerScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(
        nHandler: ::std::os::raw::c_int,
        fInterval: f32,
        bPaused: bool,
    ) -> *mut cocos2d_CCSchedulerScriptHandlerEntry {
        cocos2d_CCSchedulerScriptHandlerEntry_create(nHandler, fInterval, bPaused)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCSchedulerScriptHandlerEntry@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSchedulerScriptHandlerEntry_CCSchedulerScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCSchedulerScriptHandlerEntry,
    );
}
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchScriptHandlerEntry {
    pub _base: cocos2d_CCScriptHandlerEntry,
    pub m_bIsMultiTouches: bool,
    pub m_nPriority: ::std::os::raw::c_int,
    pub m_bSwallowsTouches: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchScriptHandlerEntry() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTouchScriptHandlerEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchScriptHandlerEntry>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchScriptHandlerEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchScriptHandlerEntry>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsMultiTouches) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_bIsMultiTouches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPriority) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_nPriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSwallowsTouches) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchScriptHandlerEntry),
            "::",
            stringify!(m_bSwallowsTouches)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTouchScriptHandlerEntry@cocos2d@@SAPAV12@H_NH0@Z"]
    pub fn cocos2d_CCTouchScriptHandlerEntry_create(
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) -> *mut cocos2d_CCTouchScriptHandlerEntry;
}
impl cocos2d_CCTouchScriptHandlerEntry {
    #[inline]
    pub unsafe fn create(
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) -> *mut cocos2d_CCTouchScriptHandlerEntry {
        cocos2d_CCTouchScriptHandlerEntry_create(
            nHandler,
            bIsMultiTouches,
            nPriority,
            bSwallowsTouches,
        )
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTouchScriptHandlerEntry@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTouchScriptHandlerEntry_CCTouchScriptHandlerEntry_destructor(
        this: *mut cocos2d_CCTouchScriptHandlerEntry,
    );
}
#[repr(C)]
pub struct cocos2d_CCScriptEngineProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptEngineProtocol {
    pub vtable_: *const cocos2d_CCScriptEngineProtocol__bindgen_vtable,
}
pub const cocos2d_CCScriptEngineProtocol_ConfigType_NONE:
    cocos2d_CCScriptEngineProtocol_ConfigType = 0;
pub const cocos2d_CCScriptEngineProtocol_ConfigType_COCOSTUDIO:
    cocos2d_CCScriptEngineProtocol_ConfigType = 1;
pub type cocos2d_CCScriptEngineProtocol_ConfigType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCScriptEngineProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptEngineProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptEngineProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptEngineProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptEngineProtocol))
    );
}
#[doc = "CCScriptEngineManager is a singleton which holds an object instance of CCScriptEngineProtocl\nIt helps cocos2d-x and the user code to find back LuaEngine object\n@since v0.99.5-x-0.8.5\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScriptEngineManager {
    pub m_pScriptEngine: *mut cocos2d_CCScriptEngineProtocol,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScriptEngineManager() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCScriptEngineManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScriptEngineManager>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCScriptEngineManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScriptEngineManager>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScriptEngineManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScriptEngine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScriptEngineManager),
            "::",
            stringify!(m_pScriptEngine)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setScriptEngine@CCScriptEngineManager@cocos2d@@QAEXPAVCCScriptEngineProtocol@2@@Z"]
    pub fn cocos2d_CCScriptEngineManager_setScriptEngine(
        this: *mut cocos2d_CCScriptEngineManager,
        pScriptEngine: *mut cocos2d_CCScriptEngineProtocol,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeScriptEngine@CCScriptEngineManager@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCScriptEngineManager_removeScriptEngine(
        this: *mut cocos2d_CCScriptEngineManager,
    );
}
extern "C" {
    #[link_name = "\u{1}?sharedManager@CCScriptEngineManager@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCScriptEngineManager_sharedManager() -> *mut cocos2d_CCScriptEngineManager;
}
extern "C" {
    #[link_name = "\u{1}?purgeSharedManager@CCScriptEngineManager@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCScriptEngineManager_purgeSharedManager();
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCScriptEngineManager@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCScriptEngineManager_CCScriptEngineManager_destructor(
        this: *mut cocos2d_CCScriptEngineManager,
    );
}
impl cocos2d_CCScriptEngineManager {
    #[inline]
    pub unsafe fn setScriptEngine(&mut self, pScriptEngine: *mut cocos2d_CCScriptEngineProtocol) {
        cocos2d_CCScriptEngineManager_setScriptEngine(self, pScriptEngine)
    }
    #[inline]
    pub unsafe fn removeScriptEngine(&mut self) {
        cocos2d_CCScriptEngineManager_removeScriptEngine(self)
    }
    #[inline]
    pub unsafe fn sharedManager() -> *mut cocos2d_CCScriptEngineManager {
        cocos2d_CCScriptEngineManager_sharedManager()
    }
    #[inline]
    pub unsafe fn purgeSharedManager() {
        cocos2d_CCScriptEngineManager_purgeSharedManager()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCScriptEngineManager_CCScriptEngineManager_destructor(self)
    }
}
#[doc = " RGB color composed of bytes 3 bytes\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor3B {
    pub r: GLubyte,
    pub g: GLubyte,
    pub b: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor3B() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccColor3B> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor3B>(),
        3usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor3B))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor3B>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor3B))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor3B),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " RGB color composed of bytes 3 bytes\n@since v0.8"]
pub type cocos2d_ccColor3B = cocos2d__ccColor3B;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccHSVValue {
    pub h: f32,
    pub s: f32,
    pub v: f32,
    pub absoluteSaturation: GLubyte,
    pub absoluteBrightness: GLubyte,
    pub __pad: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d__ccHSVValue() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccHSVValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccHSVValue>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccHSVValue))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccHSVValue>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccHSVValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).absoluteSaturation) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(absoluteSaturation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).absoluteBrightness) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(absoluteBrightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccHSVValue),
            "::",
            stringify!(__pad)
        )
    );
}
pub type cocos2d_ccHSVValue = cocos2d__ccHSVValue;
extern "C" {
    #[doc = "! White color (255,255,255)"]
    #[link_name = "\u{1}?ccWHITE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccWHITE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Yellow color (255,255,0)"]
    #[link_name = "\u{1}?ccYELLOW@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccYELLOW: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Blue color (0,0,255)"]
    #[link_name = "\u{1}?ccBLUE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccBLUE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Green Color (0,255,0)"]
    #[link_name = "\u{1}?ccGREEN@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccGREEN: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Red Color (255,0,0,)"]
    #[link_name = "\u{1}?ccRED@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccRED: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Magenta Color (255,0,255)"]
    #[link_name = "\u{1}?ccMAGENTA@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccMAGENTA: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Black Color (0,0,0)"]
    #[link_name = "\u{1}?ccBLACK@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccBLACK: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Orange Color (255,127,0)"]
    #[link_name = "\u{1}?ccORANGE@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccORANGE: cocos2d_ccColor3B;
}
extern "C" {
    #[doc = "! Gray Color (166,166,166)"]
    #[link_name = "\u{1}?ccGRAY@cocos2d@@3U_ccColor3B@1@B"]
    pub static cocos2d_ccGRAY: cocos2d_ccColor3B;
}
#[doc = " RGBA color composed of 4 bytes\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor4B {
    pub r: GLubyte,
    pub g: GLubyte,
    pub b: GLubyte,
    pub a: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor4B() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccColor4B> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor4B>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor4B))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor4B>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor4B))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4B),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " RGBA color composed of 4 bytes\n@since v0.8"]
pub type cocos2d_ccColor4B = cocos2d__ccColor4B;
#[doc = " RGBA color composed of 4 floats\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccColor4F {
    pub r: GLfloat,
    pub g: GLfloat,
    pub b: GLfloat,
    pub a: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccColor4F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccColor4F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccColor4F>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccColor4F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccColor4F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccColor4F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccColor4F),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " RGBA color composed of 4 floats\n@since v0.8"]
pub type cocos2d_ccColor4F = cocos2d__ccColor4F;
#[doc = " A vertex composed of 2 floats: x, y\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccVertex2F {
    pub x: GLfloat,
    pub y: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccVertex2F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccVertex2F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccVertex2F>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccVertex2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccVertex2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccVertex2F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex2F),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex2F),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A vertex composed of 2 floats: x, y\n@since v0.8"]
pub type cocos2d_ccVertex2F = cocos2d__ccVertex2F;
#[doc = " A vertex composed of 2 floats: x, y\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccVertex3F {
    pub x: GLfloat,
    pub y: GLfloat,
    pub z: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccVertex3F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccVertex3F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccVertex3F>(),
        12usize,
        concat!("Size of: ", stringify!(cocos2d__ccVertex3F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccVertex3F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccVertex3F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccVertex3F),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " A vertex composed of 2 floats: x, y\n@since v0.8"]
pub type cocos2d_ccVertex3F = cocos2d__ccVertex3F;
#[doc = " A texcoord composed of 2 floats: u, y\n@since v0.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccTex2F {
    pub u: GLfloat,
    pub v: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccTex2F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccTex2F> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccTex2F>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccTex2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccTex2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccTex2F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTex2F),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTex2F),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " A texcoord composed of 2 floats: u, y\n@since v0.8"]
pub type cocos2d_ccTex2F = cocos2d__ccTex2F;
#[doc = "! Point Sprite component"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccPointSprite {
    pub pos: cocos2d_ccVertex2F,
    pub color: cocos2d_ccColor4B,
    pub size: GLfloat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccPointSprite() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccPointSprite> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccPointSprite>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccPointSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccPointSprite>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccPointSprite))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPointSprite),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "! Point Sprite component"]
pub type cocos2d_ccPointSprite = cocos2d__ccPointSprite;
#[doc = "!    A 2D Quad. 4 * 2 floats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccQuad2 {
    pub tl: cocos2d_ccVertex2F,
    pub tr: cocos2d_ccVertex2F,
    pub bl: cocos2d_ccVertex2F,
    pub br: cocos2d_ccVertex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccQuad2() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccQuad2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccQuad2>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccQuad2))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccQuad2>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccQuad2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(tr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad2),
            "::",
            stringify!(br)
        )
    );
}
#[doc = "!    A 2D Quad. 4 * 2 floats"]
pub type cocos2d_ccQuad2 = cocos2d__ccQuad2;
#[doc = "!    A 3D Quad. 4 * 3 floats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccQuad3 {
    pub bl: cocos2d_ccVertex3F,
    pub br: cocos2d_ccVertex3F,
    pub tl: cocos2d_ccVertex3F,
    pub tr: cocos2d_ccVertex3F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccQuad3() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccQuad3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccQuad3>(),
        48usize,
        concat!("Size of: ", stringify!(cocos2d__ccQuad3))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccQuad3>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccQuad3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccQuad3),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "!    A 3D Quad. 4 * 3 floats"]
pub type cocos2d_ccQuad3 = cocos2d__ccQuad3;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F {
    #[doc = "! vertices (2F)"]
    pub vertices: cocos2d_ccVertex2F,
    #[doc = "! colors (4B)"]
    pub colors: cocos2d_ccColor4B,
    #[doc = "! tex coords (2F)"]
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV2F_C4B_T2F> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F>(),
        20usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texCoords) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
pub type cocos2d_ccV2F_C4B_T2F = cocos2d__ccV2F_C4B_T2F;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4F_T2F {
    #[doc = "! vertices (2F)"]
    pub vertices: cocos2d_ccVertex2F,
    #[doc = "! colors (4F)"]
    pub colors: cocos2d_ccColor4F,
    #[doc = "! tex coords (2F)"]
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4F_T2F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV2F_C4F_T2F> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4F_T2F>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4F_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4F_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4F_T2F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texCoords) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4F"]
pub type cocos2d_ccV2F_C4F_T2F = cocos2d__ccV2F_C4F_T2F;
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV3F_C4B_T2F {
    #[doc = "! vertices (3F)"]
    pub vertices: cocos2d_ccVertex3F,
    #[doc = "! colors (4B)"]
    pub colors: cocos2d_ccColor4B,
    pub texCoords: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV3F_C4B_T2F() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV3F_C4B_T2F> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV3F_C4B_T2F>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d__ccV3F_C4B_T2F))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV3F_C4B_T2F>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV3F_C4B_T2F))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texCoords) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F),
            "::",
            stringify!(texCoords)
        )
    );
}
#[doc = "! a Point with a vertex point, a tex coord point and a color 4B"]
pub type cocos2d_ccV3F_C4B_T2F = cocos2d__ccV3F_C4B_T2F;
#[doc = "! A Triangle of ccV2F_C4B_T2F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F_Triangle {
    #[doc = "! Point A"]
    pub a: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! Point B"]
    pub b: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! Point B"]
    pub c: cocos2d_ccV2F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F_Triangle() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV2F_C4B_T2F_Triangle> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F_Triangle>(),
        60usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F_Triangle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F_Triangle>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F_Triangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Triangle),
            "::",
            stringify!(c)
        )
    );
}
#[doc = "! A Triangle of ccV2F_C4B_T2F"]
pub type cocos2d_ccV2F_C4B_T2F_Triangle = cocos2d__ccV2F_C4B_T2F_Triangle;
#[doc = "! A Quad of ccV2F_C4B_T2F"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4B_T2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccV2F_C4B_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV2F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4B_T2F_Quad() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV2F_C4B_T2F_Quad> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4B_T2F_Quad>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4B_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4B_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4B_T2F_Quad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4B_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "! A Quad of ccV2F_C4B_T2F"]
pub type cocos2d_ccV2F_C4B_T2F_Quad = cocos2d__ccV2F_C4B_T2F_Quad;
#[doc = "! 4 ccVertex3FTex2FColor4B"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV3F_C4B_T2F_Quad {
    #[doc = "! top left"]
    pub tl: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV3F_C4B_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV3F_C4B_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV3F_C4B_T2F_Quad() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV3F_C4B_T2F_Quad> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV3F_C4B_T2F_Quad>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d__ccV3F_C4B_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV3F_C4B_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV3F_C4B_T2F_Quad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV3F_C4B_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
}
#[doc = "! 4 ccVertex3FTex2FColor4B"]
pub type cocos2d_ccV3F_C4B_T2F_Quad = cocos2d__ccV3F_C4B_T2F_Quad;
#[doc = "! 4 ccVertex2FTex2FColor4F Quad"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccV2F_C4F_T2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccV2F_C4F_T2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccV2F_C4F_T2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccV2F_C4F_T2F_Quad() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccV2F_C4F_T2F_Quad> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccV2F_C4F_T2F_Quad>(),
        128usize,
        concat!("Size of: ", stringify!(cocos2d__ccV2F_C4F_T2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccV2F_C4F_T2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccV2F_C4F_T2F_Quad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccV2F_C4F_T2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
#[doc = "! 4 ccVertex2FTex2FColor4F Quad"]
pub type cocos2d_ccV2F_C4F_T2F_Quad = cocos2d__ccV2F_C4F_T2F_Quad;
#[doc = "! Blend Function used for textures"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccBlendFunc {
    #[doc = "! source blend function"]
    pub src: GLenum,
    #[doc = "! destination blend function"]
    pub dst: GLenum,
}
#[test]
fn bindgen_test_layout_cocos2d__ccBlendFunc() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccBlendFunc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccBlendFunc>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccBlendFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccBlendFunc>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccBlendFunc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBlendFunc),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBlendFunc),
            "::",
            stringify!(dst)
        )
    );
}
#[doc = "! Blend Function used for textures"]
pub type cocos2d_ccBlendFunc = cocos2d__ccBlendFunc;
extern "C" {
    #[link_name = "\u{1}?kCCBlendFuncDisable@cocos2d@@3U_ccBlendFunc@1@B"]
    pub static cocos2d_kCCBlendFuncDisable: cocos2d_ccBlendFunc;
}
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentTop:
    cocos2d_CCVerticalTextAlignment = 0;
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentCenter:
    cocos2d_CCVerticalTextAlignment = 1;
pub const cocos2d_CCVerticalTextAlignment_kCCVerticalTextAlignmentBottom:
    cocos2d_CCVerticalTextAlignment = 2;
#[doc = "! Vertical text alignment type"]
pub type cocos2d_CCVerticalTextAlignment = ::std::os::raw::c_int;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentLeft: cocos2d_CCTextAlignment = 0;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentCenter: cocos2d_CCTextAlignment = 1;
pub const cocos2d_CCTextAlignment_kCCTextAlignmentRight: cocos2d_CCTextAlignment = 2;
#[doc = "! Horizontal text alignment type"]
pub type cocos2d_CCTextAlignment = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccT2F_Quad {
    #[doc = "! bottom left"]
    pub bl: cocos2d_ccTex2F,
    #[doc = "! bottom right"]
    pub br: cocos2d_ccTex2F,
    #[doc = "! top left"]
    pub tl: cocos2d_ccTex2F,
    #[doc = "! top right"]
    pub tr: cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d__ccT2F_Quad() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccT2F_Quad> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccT2F_Quad>(),
        32usize,
        concat!("Size of: ", stringify!(cocos2d__ccT2F_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccT2F_Quad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccT2F_Quad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(bl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).br) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(tl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccT2F_Quad),
            "::",
            stringify!(tr)
        )
    );
}
pub type cocos2d_ccT2F_Quad = cocos2d__ccT2F_Quad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_ccAnimationFrameData {
    pub texCoords: cocos2d_ccT2F_Quad,
    pub delay: f32,
    pub size: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_ccAnimationFrameData() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_ccAnimationFrameData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_ccAnimationFrameData>(),
        44usize,
        concat!("Size of: ", stringify!(cocos2d_ccAnimationFrameData))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_ccAnimationFrameData>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_ccAnimationFrameData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texCoords) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(texCoords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccAnimationFrameData),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "types used for defining fonts properties (i.e. font name, size, stroke or shadow)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontShadow {
    pub m_shadowEnabled: bool,
    pub m_shadowOffset: cocos2d_CCSize,
    pub m_shadowBlur: f32,
    pub m_shadowOpacity: f32,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontShadow() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccFontShadow> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontShadow>(),
        20usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontShadow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontShadow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontShadow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowEnabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowBlur) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowBlur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowOpacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontShadow),
            "::",
            stringify!(m_shadowOpacity)
        )
    );
}
#[doc = "types used for defining fonts properties (i.e. font name, size, stroke or shadow)"]
pub type cocos2d_ccFontShadow = cocos2d__ccFontShadow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontStroke {
    pub m_strokeEnabled: bool,
    pub m_strokeColor: cocos2d_ccColor3B,
    pub m_strokeSize: f32,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontStroke() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccFontStroke> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontStroke>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontStroke))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontStroke>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontStroke))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeEnabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeColor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontStroke),
            "::",
            stringify!(m_strokeSize)
        )
    );
}
pub type cocos2d_ccFontStroke = cocos2d__ccFontStroke;
#[doc = "  @js NA\n  @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccFontDefinition {
    pub m_fontName: std_string,
    pub m_fontSize: ::std::os::raw::c_int,
    pub m_alignment: cocos2d_CCTextAlignment,
    pub m_vertAlignment: cocos2d_CCVerticalTextAlignment,
    pub m_dimensions: cocos2d_CCSize,
    pub m_fontFillColor: cocos2d_ccColor3B,
    pub m_shadow: cocos2d_ccFontShadow,
    pub m_stroke: cocos2d_ccFontStroke,
}
#[test]
fn bindgen_test_layout_cocos2d__ccFontDefinition() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccFontDefinition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccFontDefinition>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d__ccFontDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccFontDefinition>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccFontDefinition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fontName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fontSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_alignment) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_vertAlignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_vertAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dimensions) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_dimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fontFillColor) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_fontFillColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadow) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_shadow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_stroke) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccFontDefinition),
            "::",
            stringify!(m_stroke)
        )
    );
}
#[doc = "  @js NA\n  @lua NA"]
pub type cocos2d_ccFontDefinition = cocos2d__ccFontDefinition;
#[doc = "! 32-bit texture: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGBA8888:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! 24-bit texture: RGBA888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB888:
    cocos2d_CCTexture2DPixelFormat = 1;
#[doc = "! 16-bit texture without Alpha channel"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB565:
    cocos2d_CCTexture2DPixelFormat = 2;
#[doc = "! 8-bit textures used as masks"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_A8:
    cocos2d_CCTexture2DPixelFormat = 3;
#[doc = "! 8-bit intensity texture"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_I8:
    cocos2d_CCTexture2DPixelFormat = 4;
#[doc = "! 16-bit textures used as masks"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_AI88:
    cocos2d_CCTexture2DPixelFormat = 5;
#[doc = "! 16-bit textures: RGBA4444"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGBA4444:
    cocos2d_CCTexture2DPixelFormat = 6;
#[doc = "! 16-bit textures: RGB5A1"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_RGB5A1:
    cocos2d_CCTexture2DPixelFormat = 7;
#[doc = "! 4-bit PVRTC-compressed texture: PVRTC4"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_PVRTC4:
    cocos2d_CCTexture2DPixelFormat = 8;
#[doc = "! 2-bit PVRTC-compressed texture: PVRTC2"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_PVRTC2:
    cocos2d_CCTexture2DPixelFormat = 9;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kCCTexture2DPixelFormat_Default:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGBA8888:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB888:
    cocos2d_CCTexture2DPixelFormat = 1;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB565:
    cocos2d_CCTexture2DPixelFormat = 2;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_A8: cocos2d_CCTexture2DPixelFormat =
    3;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGBA4444:
    cocos2d_CCTexture2DPixelFormat = 6;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_RGB5A1:
    cocos2d_CCTexture2DPixelFormat = 7;
#[doc = "! Default texture format: RGBA8888"]
pub const cocos2d_CCTexture2DPixelFormat_kTexture2DPixelFormat_Default:
    cocos2d_CCTexture2DPixelFormat = 0;
#[doc = " @typedef CCTexture2DPixelFormat\nPossible texture pixel formats"]
pub type cocos2d_CCTexture2DPixelFormat = ::std::os::raw::c_int;
#[doc = "Extension to set the Min / Mag filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccTexParams {
    pub minFilter: GLuint,
    pub magFilter: GLuint,
    pub wrapS: GLuint,
    pub wrapT: GLuint,
}
#[test]
fn bindgen_test_layout_cocos2d__ccTexParams() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccTexParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccTexParams>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__ccTexParams))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccTexParams>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccTexParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minFilter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(minFilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magFilter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(magFilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapS) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(wrapS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapT) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccTexParams),
            "::",
            stringify!(wrapT)
        )
    );
}
#[doc = "Extension to set the Min / Mag filter"]
pub type cocos2d_ccTexParams = cocos2d__ccTexParams;
#[doc = " @brief CCTexture2D class.\n This class allows to easily create OpenGL 2D textures from images, text or raw data.\n The created CCTexture2D object will always have power-of-two dimensions.\n Depending on how you create the CCTexture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. \"contentSize\" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).\n Be aware that the content of the generated textures will be upside-down!"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTexture2D {
    pub _base: cocos2d_CCObject,
    pub m_bPVRHaveAlphaPremultiplied: bool,
    #[doc = " pixel format of the texture"]
    pub m_ePixelFormat: cocos2d_CCTexture2DPixelFormat,
    #[doc = " width in pixels"]
    pub m_uPixelsWide: ::std::os::raw::c_uint,
    #[doc = " height in pixels"]
    pub m_uPixelsHigh: ::std::os::raw::c_uint,
    #[doc = " texture name"]
    pub m_uName: GLuint,
    #[doc = " texture max S"]
    pub m_fMaxS: GLfloat,
    #[doc = " texture max T"]
    pub m_fMaxT: GLfloat,
    #[doc = " content size"]
    pub m_tContentSize: cocos2d_CCSize,
    #[doc = " whether or not the texture has their Alpha premultiplied"]
    pub m_bHasPremultipliedAlpha: bool,
    pub m_bHasMipmaps: bool,
    #[doc = " shader program used by drawAtPoint and drawInRect"]
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTexture2D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTexture2D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTexture2D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCTexture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTexture2D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTexture2D))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bPVRHaveAlphaPremultiplied) as usize - ptr as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bPVRHaveAlphaPremultiplied)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ePixelFormat) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_ePixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uPixelsWide) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uPixelsWide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uPixelsHigh) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uPixelsHigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_uName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fMaxS) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_fMaxS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fMaxT) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_fMaxT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tContentSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_tContentSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasPremultipliedAlpha) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bHasPremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasMipmaps) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_bHasMipmaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pShaderProgram) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexture2D),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?description@CCTexture2D@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCTexture2D_description(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " These functions are needed to create mutable textures\n @js NA"]
    #[link_name = "\u{1}?releaseData@CCTexture2D@cocos2d@@QAEXPAX@Z"]
    pub fn cocos2d_CCTexture2D_releaseData(
        this: *mut cocos2d_CCTexture2D,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?keepData@CCTexture2D@cocos2d@@QAEPAXPAXI@Z"]
    pub fn cocos2d_CCTexture2D_keepData(
        this: *mut cocos2d_CCTexture2D,
        data: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "thiscall" {
    #[doc = " Initializes with a texture2d with data\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?initWithData@CCTexture2D@cocos2d@@QAE_NPBXW4CCTexture2DPixelFormat@2@IIABVCCSize@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithData(
        this: *mut cocos2d_CCTexture2D,
        data: *const ::std::os::raw::c_void,
        pixelFormat: cocos2d_CCTexture2DPixelFormat,
        pixelsWide: ::std::os::raw::c_uint,
        pixelsHigh: ::std::os::raw::c_uint,
        contentSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "Drawing extensions to make it easy to draw basic quads using a CCTexture2D object.\nThese functions require GL_TEXTURE_2D and both GL_VERTEX_ARRAY and GL_TEXTURE_COORD_ARRAY client states to be enabled.\n/\n/** draws a texture at a given point"]
    #[link_name = "\u{1}?drawAtPoint@CCTexture2D@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTexture2D_drawAtPoint(
        this: *mut cocos2d_CCTexture2D,
        point: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " draws a texture inside a rect"]
    #[link_name = "\u{1}?drawInRect@CCTexture2D@cocos2d@@QAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCTexture2D_drawInRect(
        this: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = "Extensions to make it easy to create a CCTexture2D object from an image file.\nNote that RGBA type textures will have their alpha premultiplied - use the blending mode (GL_ONE, GL_ONE_MINUS_SRC_ALPHA).\n/\n/** Initializes a texture from a UIImage object"]
    #[link_name = "\u{1}?initWithImage@CCTexture2D@cocos2d@@QAE_NPAVCCImage@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithImage(
        this: *mut cocos2d_CCTexture2D,
        uiImage: *mut cocos2d_CCImage,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a texture from a string with dimensions, alignment, font name and font size"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QAE_NPBD0MABVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithString(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a texture from a string with font name and font size"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QAE_NPBD0M@Z"]
    pub fn cocos2d_CCTexture2D_initWithString1(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a texture from a string using a text definition"]
    #[link_name = "\u{1}?initWithString@CCTexture2D@cocos2d@@QAE_NPBDPAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCTexture2D_initWithString2(
        this: *mut cocos2d_CCTexture2D,
        text: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a texture from a PVR file"]
    #[link_name = "\u{1}?initWithPVRFile@CCTexture2D@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTexture2D_initWithPVRFile(
        this: *mut cocos2d_CCTexture2D,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a texture from a ETC file"]
    #[link_name = "\u{1}?initWithETCFile@CCTexture2D@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTexture2D_initWithETCFile(
        this: *mut cocos2d_CCTexture2D,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " sets the min filter, mag filter, wrap s and wrap t texture parameters.\nIf the texture size is NPOT (non power of 2), then in can only use GL_CLAMP_TO_EDGE in GL_TEXTURE_WRAP_{S,T}.\n\n@warning Calling this method could allocate additional texture memory.\n\n@since v0.8\n@code\nwhen this functon bound to js,the input param are changed\njs: var setTexParameters(var minFilter, var magFilter, var wrapS, var wrapT)\n@endcode"]
    #[link_name = "\u{1}?setTexParameters@CCTexture2D@cocos2d@@QAEXPAU_ccTexParams@2@@Z"]
    pub fn cocos2d_CCTexture2D_setTexParameters(
        this: *mut cocos2d_CCTexture2D,
        texParams: *mut cocos2d_ccTexParams,
    );
}
extern "thiscall" {
    #[doc = " sets antialias texture parameters:\n- GL_TEXTURE_MIN_FILTER = GL_LINEAR\n- GL_TEXTURE_MAG_FILTER = GL_LINEAR\n\n@warning Calling this method could allocate additional texture memory.\n\n@since v0.8"]
    #[link_name = "\u{1}?setAntiAliasTexParameters@CCTexture2D@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTexture2D_setAntiAliasTexParameters(this: *mut cocos2d_CCTexture2D);
}
extern "thiscall" {
    #[doc = " sets alias texture parameters:\n- GL_TEXTURE_MIN_FILTER = GL_NEAREST\n- GL_TEXTURE_MAG_FILTER = GL_NEAREST\n\n@warning Calling this method could allocate additional texture memory.\n\n@since v0.8"]
    #[link_name = "\u{1}?setAliasTexParameters@CCTexture2D@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTexture2D_setAliasTexParameters(this: *mut cocos2d_CCTexture2D);
}
extern "thiscall" {
    #[doc = " Generates mipmap images for the texture.\nIt only works if the texture size is POT (power of 2).\n@since v0.99.0"]
    #[link_name = "\u{1}?generateMipmap@CCTexture2D@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTexture2D_generateMipmap(this: *mut cocos2d_CCTexture2D);
}
extern "thiscall" {
    #[doc = " returns the pixel format.\n@since v2.0"]
    #[link_name = "\u{1}?stringForFormat@CCTexture2D@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCTexture2D_stringForFormat(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " returns the bits-per-pixel of the in-memory OpenGL texture\n@since v1.0"]
    #[link_name = "\u{1}?bitsPerPixelForFormat@CCTexture2D@cocos2d@@QAEIXZ"]
    pub fn cocos2d_CCTexture2D_bitsPerPixelForFormat(
        this: *mut cocos2d_CCTexture2D,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Helper functions that returns bits per pixels for a given format.\n@since v2.0"]
    #[link_name = "\u{1}?bitsPerPixelForFormat@CCTexture2D@cocos2d@@QAEIW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCTexture2D_bitsPerPixelForFormat1(
        this: *mut cocos2d_CCTexture2D,
        format: cocos2d_CCTexture2DPixelFormat,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " sets the default pixel format for UIImagescontains alpha channel.\nIf the UIImage contains alpha channel, then the options are:\n- generate 32-bit textures: kCCTexture2DPixelFormat_RGBA8888 (default one)\n- generate 24-bit textures: kCCTexture2DPixelFormat_RGB888\n- generate 16-bit textures: kCCTexture2DPixelFormat_RGBA4444\n- generate 16-bit textures: kCCTexture2DPixelFormat_RGB5A1\n- generate 16-bit textures: kCCTexture2DPixelFormat_RGB565\n- generate 8-bit textures: kCCTexture2DPixelFormat_A8 (only use it if you use just 1 color)\n\nHow does it work ?\n- If the image is an RGBA (with Alpha) then the default pixel format will be used (it can be a 8-bit, 16-bit or 32-bit texture)\n- If the image is an RGB (without Alpha) then: If the default pixel format is RGBA8888 then a RGBA8888 (32-bit) will be used. Otherwise a RGB565 (16-bit texture) will be used.\n\nThis parameter is not valid for PVR / PVR.CCZ images.\n\n@since v0.8"]
    #[link_name = "\u{1}?setDefaultAlphaPixelFormat@CCTexture2D@cocos2d@@SAXW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCTexture2D_setDefaultAlphaPixelFormat(format: cocos2d_CCTexture2DPixelFormat);
}
extern "C" {
    #[doc = " returns the alpha pixel format\n@since v0.8\n@js getDefaultAlphaPixelFormat"]
    #[link_name = "\u{1}?defaultAlphaPixelFormat@CCTexture2D@cocos2d@@SA?AW4CCTexture2DPixelFormat@2@XZ"]
    pub fn cocos2d_CCTexture2D_defaultAlphaPixelFormat() -> cocos2d_CCTexture2DPixelFormat;
}
extern "C" {
    #[doc = " treats (or not) PVR files as if they have alpha premultiplied.\nSince it is impossible to know at runtime if the PVR images have the alpha channel premultiplied, it is\npossible load them as if they have (or not) the alpha channel premultiplied.\n\nBy default it is disabled.\n\n@since v0.99.5"]
    #[link_name = "\u{1}?PVRImagesHavePremultipliedAlpha@CCTexture2D@cocos2d@@SAX_N@Z"]
    pub fn cocos2d_CCTexture2D_PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied: bool);
}
extern "thiscall" {
    #[doc = " content size"]
    #[link_name = "\u{1}?getContentSizeInPixels@CCTexture2D@cocos2d@@QAEABVCCSize@2@XZ"]
    pub fn cocos2d_CCTexture2D_getContentSizeInPixels(
        this: *mut cocos2d_CCTexture2D,
    ) -> *const cocos2d_CCSize;
}
extern "thiscall" {
    #[link_name = "\u{1}?hasPremultipliedAlpha@CCTexture2D@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCTexture2D_hasPremultipliedAlpha(this: *mut cocos2d_CCTexture2D) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?hasMipmaps@CCTexture2D@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCTexture2D_hasMipmaps(this: *mut cocos2d_CCTexture2D) -> bool;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTexture2D@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTexture2D_CCTexture2D(this: *mut cocos2d_CCTexture2D);
}
impl cocos2d_CCTexture2D {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTexture2D_description(self)
    }
    #[inline]
    pub unsafe fn releaseData(&mut self, data: *mut ::std::os::raw::c_void) {
        cocos2d_CCTexture2D_releaseData(self, data)
    }
    #[inline]
    pub unsafe fn keepData(
        &mut self,
        data: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void {
        cocos2d_CCTexture2D_keepData(self, data, length)
    }
    #[inline]
    pub unsafe fn initWithData(
        &mut self,
        data: *const ::std::os::raw::c_void,
        pixelFormat: cocos2d_CCTexture2DPixelFormat,
        pixelsWide: ::std::os::raw::c_uint,
        pixelsHigh: ::std::os::raw::c_uint,
        contentSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCTexture2D_initWithData(
            self,
            data,
            pixelFormat,
            pixelsWide,
            pixelsHigh,
            contentSize,
        )
    }
    #[inline]
    pub unsafe fn drawAtPoint(&mut self, point: *const cocos2d_CCPoint) {
        cocos2d_CCTexture2D_drawAtPoint(self, point)
    }
    #[inline]
    pub unsafe fn drawInRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCTexture2D_drawInRect(self, rect)
    }
    #[inline]
    pub unsafe fn initWithImage(&mut self, uiImage: *mut cocos2d_CCImage) -> bool {
        cocos2d_CCTexture2D_initWithImage(self, uiImage)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString(
            self, text, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        text: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString1(self, text, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        text: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool {
        cocos2d_CCTexture2D_initWithString2(self, text, textDefinition)
    }
    #[inline]
    pub unsafe fn initWithPVRFile(&mut self, file: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexture2D_initWithPVRFile(self, file)
    }
    #[inline]
    pub unsafe fn initWithETCFile(&mut self, file: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexture2D_initWithETCFile(self, file)
    }
    #[inline]
    pub unsafe fn setTexParameters(&mut self, texParams: *mut cocos2d_ccTexParams) {
        cocos2d_CCTexture2D_setTexParameters(self, texParams)
    }
    #[inline]
    pub unsafe fn setAntiAliasTexParameters(&mut self) {
        cocos2d_CCTexture2D_setAntiAliasTexParameters(self)
    }
    #[inline]
    pub unsafe fn setAliasTexParameters(&mut self) {
        cocos2d_CCTexture2D_setAliasTexParameters(self)
    }
    #[inline]
    pub unsafe fn generateMipmap(&mut self) {
        cocos2d_CCTexture2D_generateMipmap(self)
    }
    #[inline]
    pub unsafe fn stringForFormat(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTexture2D_stringForFormat(self)
    }
    #[inline]
    pub unsafe fn bitsPerPixelForFormat(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCTexture2D_bitsPerPixelForFormat(self)
    }
    #[inline]
    pub unsafe fn bitsPerPixelForFormat1(
        &mut self,
        format: cocos2d_CCTexture2DPixelFormat,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTexture2D_bitsPerPixelForFormat1(self, format)
    }
    #[inline]
    pub unsafe fn setDefaultAlphaPixelFormat(format: cocos2d_CCTexture2DPixelFormat) {
        cocos2d_CCTexture2D_setDefaultAlphaPixelFormat(format)
    }
    #[inline]
    pub unsafe fn defaultAlphaPixelFormat() -> cocos2d_CCTexture2DPixelFormat {
        cocos2d_CCTexture2D_defaultAlphaPixelFormat()
    }
    #[inline]
    pub unsafe fn PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied: bool) {
        cocos2d_CCTexture2D_PVRImagesHavePremultipliedAlpha(haveAlphaPremultiplied)
    }
    #[inline]
    pub unsafe fn getContentSizeInPixels(&mut self) -> *const cocos2d_CCSize {
        cocos2d_CCTexture2D_getContentSizeInPixels(self)
    }
    #[inline]
    pub unsafe fn hasPremultipliedAlpha(&mut self) -> bool {
        cocos2d_CCTexture2D_hasPremultipliedAlpha(self)
    }
    #[inline]
    pub unsafe fn hasMipmaps(&mut self) -> bool {
        cocos2d_CCTexture2D_hasMipmaps(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTexture2D_CCTexture2D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTexture2D@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTexture2D_CCTexture2D_destructor(this: *mut cocos2d_CCTexture2D);
}
extern "thiscall" {
    #[doc = " pixel format of the texture"]
    #[link_name = "\u{1}?getPixelFormat@CCTexture2D@cocos2d@@UAE?AW4CCTexture2DPixelFormat@2@XZ"]
    pub fn cocos2d_CCTexture2D_getPixelFormat(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCTexture2DPixelFormat;
}
extern "thiscall" {
    #[doc = " width in pixels"]
    #[link_name = "\u{1}?getPixelsWide@CCTexture2D@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCTexture2D_getPixelsWide(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " height in pixels"]
    #[link_name = "\u{1}?getPixelsHigh@CCTexture2D@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCTexture2D_getPixelsHigh(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " texture name"]
    #[link_name = "\u{1}?getName@CCTexture2D@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCTexture2D_getName(this: *mut ::std::os::raw::c_void) -> GLuint;
}
extern "thiscall" {
    #[doc = " texture max S"]
    #[link_name = "\u{1}?getMaxS@CCTexture2D@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCTexture2D_getMaxS(this: *mut ::std::os::raw::c_void) -> GLfloat;
}
extern "thiscall" {
    #[doc = " texture max S"]
    #[link_name = "\u{1}?setMaxS@CCTexture2D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTexture2D_setMaxS(this: *mut ::std::os::raw::c_void, var: GLfloat);
}
extern "thiscall" {
    #[doc = " texture max T"]
    #[link_name = "\u{1}?getMaxT@CCTexture2D@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCTexture2D_getMaxT(this: *mut ::std::os::raw::c_void) -> GLfloat;
}
extern "thiscall" {
    #[doc = " texture max T"]
    #[link_name = "\u{1}?setMaxT@CCTexture2D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTexture2D_setMaxT(this: *mut ::std::os::raw::c_void, var: GLfloat);
}
extern "thiscall" {
    #[doc = " content size"]
    #[link_name = "\u{1}?getContentSize@CCTexture2D@cocos2d@@UAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCTexture2D_getContentSize(this: *mut ::std::os::raw::c_void) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " shader program used by drawAtPoint and drawInRect"]
    #[link_name = "\u{1}?getShaderProgram@CCTexture2D@cocos2d@@UAEPAVCCGLProgram@2@XZ"]
    pub fn cocos2d_CCTexture2D_getShaderProgram(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "thiscall" {
    #[doc = " shader program used by drawAtPoint and drawInRect"]
    #[link_name = "\u{1}?setShaderProgram@CCTexture2D@cocos2d@@UAEXPAVCCGLProgram@2@@Z"]
    pub fn cocos2d_CCTexture2D_setShaderProgram(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCGLProgram,
    );
}
#[repr(C)]
pub struct cocos2d_CCRGBAProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " RGBA protocol that affects CCNode's color and opacity\n @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCRGBAProtocol {
    pub vtable_: *const cocos2d_CCRGBAProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRGBAProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRGBAProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCRGBAProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRGBAProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRGBAProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCBlendProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Specify the blending function according glBlendFunc\n Please refer to glBlendFunc in OpenGL ES Manual\n http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml for more details.\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCBlendProtocol {
    pub vtable_: *const cocos2d_CCBlendProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBlendProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBlendProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCBlendProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBlendProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBlendProtocol))
    );
}
#[doc = " CCNode objects that uses a CCTexture2D to render the images.\n The texture can have a blending function.\n If the texture has alpha premultiplied the default blending function is:\n   src=GL_ONE dst= GL_ONE_MINUS_SRC_ALPHA\n else\n   src=GL_SRC_ALPHA dst= GL_ONE_MINUS_SRC_ALPHA\n But you can change the blending function at any time.\n @js NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextureProtocol {
    pub _base: cocos2d_CCBlendProtocol,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCLabelProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Common interface for Labels\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCLabelProtocol {
    pub vtable_: *const cocos2d_CCLabelProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelProtocol))
    );
}
#[repr(C)]
pub struct cocos2d_CCDirectorDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " OpenGL projection protocol\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCDirectorDelegate {
    pub vtable_: *const cocos2d_CCDirectorDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDirectorDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDirectorDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCDirectorDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDirectorDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDirectorDelegate))
    );
}
pub const kCCNodeTagInvalid: cocos2d__bindgen_ty_5 = -1;
#[doc = " @addtogroup base_nodes\n @{"]
pub type cocos2d__bindgen_ty_5 = ::std::os::raw::c_int;
pub const kCCNodeOnEnter: cocos2d__bindgen_ty_6 = 0;
pub const kCCNodeOnExit: cocos2d__bindgen_ty_6 = 1;
pub const kCCNodeOnEnterTransitionDidFinish: cocos2d__bindgen_ty_6 = 2;
pub const kCCNodeOnExitTransitionDidStart: cocos2d__bindgen_ty_6 = 3;
pub const kCCNodeOnCleanup: cocos2d__bindgen_ty_6 = 4;
pub type cocos2d__bindgen_ty_6 = ::std::os::raw::c_int;
#[doc = " @brief CCNode is the main element. Anything that gets drawn or contains things that get drawn is a CCNode.\nThe most popular CCNodes are: CCScene, CCLayer, CCSprite, CCMenu.\n\nThe main features of a CCNode are:\n- They can contain other CCNode nodes (addChild, getChildByTag, removeChild, etc)\n- They can schedule periodic callback (schedule, unschedule, etc)\n- They can execute actions (runAction, stopAction, etc)\n\nSome CCNode nodes provide extra functionality for them or their children.\n\nSubclassing a CCNode usually means (one/all) of:\n- overriding init to initialize resources and schedule callbacks\n- create callbacks to handle the advancement of time\n- overriding draw to render the node\n\nFeatures of CCNode:\n- position\n- scale (x, y)\n- rotation (in degrees, clockwise)\n- CCCamera (an interface to gluLookAt )\n- CCGridBase (to do mesh transformations)\n- anchor point\n- size\n- visible\n- z-order\n- openGL z position\n\nDefault values:\n- rotation: 0\n- position: (x=0,y=0)\n- scale: (x=1,y=1)\n- contentSize: (x=0,y=0)\n- anchorPoint: (x=0,y=0)\n\nLimitations:\n- A CCNode is a \"void\" object. It doesn't have a texture\n\nOrder in transformations with grid disabled\n-# The node will be translated (position)\n-# The node will be rotated (rotation)\n-# The node will be scaled (scale)\n-# The node will be moved according to the camera values (camera)\n\nOrder in transformations with grid enabled\n-# The node will be translated (position)\n-# The node will be rotated (rotation)\n-# The node will be scaled (scale)\n-# The grid will capture the screen\n-# The node will be moved according to the camera values (camera)\n-# The grid will render the captured screen\n\nCamera:\n- Each node has a camera. By default it points to the center of the CCNode."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNode {
    pub _base: cocos2d_CCObject,
    #[doc = "< rotation angle on x-axis"]
    pub m_fRotationX: f32,
    #[doc = "< rotation angle on y-axis"]
    pub m_fRotationY: f32,
    #[doc = "< scaling factor on x-axis"]
    pub m_fScaleX: f32,
    #[doc = "< scaling factor on y-axis"]
    pub m_fScaleY: f32,
    #[doc = "< OpenGL real Z vertex"]
    pub m_fVertexZ: f32,
    #[doc = "< position of the node"]
    pub m_obPosition: cocos2d_CCPoint,
    #[doc = "< skew angle on x-axis"]
    pub m_fSkewX: f32,
    #[doc = "< skew angle on y-axis"]
    pub m_fSkewY: f32,
    #[doc = "< anchor point in points"]
    pub m_obAnchorPointInPoints: cocos2d_CCPoint,
    #[doc = "< anchor point normalized (NOT in points)"]
    pub m_obAnchorPoint: cocos2d_CCPoint,
    #[doc = "< untransformed size of the node"]
    pub m_obContentSize: cocos2d_CCSize,
    #[doc = "< transform"]
    pub m_sAdditionalTransform: cocos2d_CCAffineTransform,
    #[doc = "< transform"]
    pub m_sTransform: cocos2d_CCAffineTransform,
    #[doc = "< transform"]
    pub m_sInverse: cocos2d_CCAffineTransform,
    #[doc = "< a camera"]
    pub m_pCamera: *mut cocos2d_CCCamera,
    #[doc = "< a grid"]
    pub m_pGrid: *mut cocos2d_CCGridBase,
    #[doc = "< array of children nodes"]
    pub m_pChildren: *mut cocos2d_CCArray,
    #[doc = "< weak reference to parent node"]
    pub m_pParent: *mut cocos2d_CCNode,
    #[doc = "< A user assingned void pointer, Can be point to any cpp object"]
    pub m_pUserData: *mut ::std::os::raw::c_void,
    #[doc = "< A user assigned CCObject"]
    pub m_pUserObject: *mut cocos2d_CCObject,
    #[doc = "< OpenGL shader"]
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
    #[doc = "< OpenGL servier side state"]
    pub m_eGLServerState: cocos2d_ccGLServerState,
    #[doc = "< scheduler used to schedule timers and updates"]
    pub m_pScheduler: *mut cocos2d_CCScheduler,
    #[doc = "< a pointer to ActionManager singleton, which is used to handle all the actions"]
    pub m_pActionManager: *mut cocos2d_CCActionManager,
    #[doc = "< is running"]
    pub m_bRunning: bool,
    #[doc = "< transform dirty flag"]
    pub m_bTransformDirty: bool,
    #[doc = "< transform dirty flag"]
    pub m_bInverseDirty: bool,
    #[doc = "< The flag to check whether the additional transform is dirty"]
    pub m_bAdditionalTransformDirty: bool,
    pub pad1474: [::std::os::raw::c_char; 10usize],
    #[doc = "< is this node visible"]
    pub m_bVisible: bool,
    #[doc = "< true if the Anchor Point will be (0,0) when you position the CCNode, false otherwise.\n< Used by CCLayer and CCScene."]
    pub m_bIgnoreAnchorPointForPosition: bool,
    #[doc = "< children order dirty flag"]
    pub m_bReorderChildDirty: bool,
    #[doc = "< script handler for onEnter() & onExit(), used in Javascript binding and Lua binding."]
    pub m_nScriptHandler: ::std::os::raw::c_int,
    #[doc = "< script handler for update() callback per frame, which is invoked from lua & javascript."]
    pub m_nUpdateScriptHandler: ::std::os::raw::c_int,
    #[doc = "< type of script binding, lua or javascript"]
    pub m_eScriptType: cocos2d_ccScriptType,
    #[doc = "< Dictionary of components"]
    pub m_pComponentContainer: *mut cocos2d_CCComponentContainer,
    pub m_unknown: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNode>(),
        264usize,
        concat!("Size of: ", stringify!(cocos2d_CCNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRotationX) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fRotationX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRotationY) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fRotationY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleX) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fVertexZ) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fVertexZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obPosition) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSkewX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fSkewX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSkewY) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_fSkewY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obAnchorPointInPoints) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obAnchorPointInPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obAnchorPoint) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obAnchorPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obContentSize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_obContentSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sAdditionalTransform) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sAdditionalTransform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sTransform) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sTransform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sInverse) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_sInverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCamera) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pCamera)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pGrid) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pGrid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pChildren) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pChildren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pParent) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pParent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUserData) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pUserData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUserObject) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pUserObject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pShaderProgram) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eGLServerState) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_eGLServerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScheduler) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pScheduler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pActionManager) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pActionManager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRunning) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bRunning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTransformDirty) as usize - ptr as usize },
        225usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bTransformDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bInverseDirty) as usize - ptr as usize },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bInverseDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAdditionalTransformDirty) as usize - ptr as usize },
        227usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bAdditionalTransformDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1474) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(pad1474)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVisible) as usize - ptr as usize },
        238usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bVisible)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bIgnoreAnchorPointForPosition) as usize - ptr as usize
        },
        239usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bIgnoreAnchorPointForPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bReorderChildDirty) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_bReorderChildDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScriptHandler) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUpdateScriptHandler) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_nUpdateScriptHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eScriptType) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_eScriptType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pComponentContainer) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_pComponentContainer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_unknown) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNode),
            "::",
            stringify!(m_unknown)
        )
    );
}
extern "C" {
    #[doc = " Allocates and initializes a node.\n @return A initialized node which is marked as \"autorelease\"."]
    #[link_name = "\u{1}?create@CCNode@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCNode_create() -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " Gets the description string. It makes debugging easier.\n @return A string terminated with '\\0'\n @js NA"]
    #[link_name = "\u{1}?description@CCNode@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCNode_description(this: *mut cocos2d_CCNode) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " Schedules for lua script.\n @js NA"]
    #[link_name = "\u{1}?scheduleUpdateWithPriorityLua@CCNode@cocos2d@@QAEXHH@Z"]
    pub fn cocos2d_CCNode_scheduleUpdateWithPriorityLua(
        this: *mut cocos2d_CCNode,
        nHandler: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Returns a \"local\" axis aligned bounding box of the node.\n The returned box is relative only to its parent.\n\n @note This method returns a temporaty variable, so it can't returns const CCRect&\n @todo Rename to getBoundingBox() in the future versions.\n\n @return A \"local\" axis aligned boudning box of the node.\n @js getBoundingBox"]
    #[link_name = "\u{1}?boundingBox@CCNode@cocos2d@@QAE?AVCCRect@2@XZ"]
    pub fn cocos2d_CCNode_boundingBox(this: *mut cocos2d_CCNode) -> cocos2d_CCRect;
}
extern "thiscall" {
    #[doc = " Executes an action, and returns the action that is executed.\n\n This node becomes the action's target. Refer to CCAction::getTarget()\n @warning Actions don't retain their target.\n\n @return An Action pointer"]
    #[link_name = "\u{1}?runAction@CCNode@cocos2d@@QAEPAVCCAction@2@PAV32@@Z"]
    pub fn cocos2d_CCNode_runAction(
        this: *mut cocos2d_CCNode,
        action: *mut cocos2d_CCAction,
    ) -> *mut cocos2d_CCAction;
}
extern "thiscall" {
    #[doc = " Stops and removes all actions from the running action list ."]
    #[link_name = "\u{1}?stopAllActions@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_stopAllActions(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Stops and removes an action from the running action list.\n\n @param An action object to be removed."]
    #[link_name = "\u{1}?stopAction@CCNode@cocos2d@@QAEXPAVCCAction@2@@Z"]
    pub fn cocos2d_CCNode_stopAction(this: *mut cocos2d_CCNode, action: *mut cocos2d_CCAction);
}
extern "thiscall" {
    #[doc = " Removes an action from the running action list by its tag.\n\n @param A tag that indicates the action to be removed."]
    #[link_name = "\u{1}?stopActionByTag@CCNode@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCNode_stopActionByTag(this: *mut cocos2d_CCNode, tag: ::std::os::raw::c_int);
}
extern "thiscall" {
    #[doc = " Gets an action from the running action list by its tag.\n\n @see setTag(int), getTag().\n\n @return The action object with the given tag."]
    #[link_name = "\u{1}?getActionByTag@CCNode@cocos2d@@QAEPAVCCAction@2@H@Z"]
    pub fn cocos2d_CCNode_getActionByTag(
        this: *mut cocos2d_CCNode,
        tag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCAction;
}
extern "thiscall" {
    #[doc = " Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).\n\n Composable actions are counted as 1 action. Example:\n    If you are running 1 Sequence of 7 actions, it will return 1.\n    If you are running 7 Sequences of 2 actions, it will return 7.\n @todo Rename to getNumberOfRunningActions()\n\n @return The number of actions that are running plus the ones that are schedule to run"]
    #[link_name = "\u{1}?numberOfRunningActions@CCNode@cocos2d@@QAEIXZ"]
    pub fn cocos2d_CCNode_numberOfRunningActions(
        this: *mut cocos2d_CCNode,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Checks whether a selector is scheduled.\n\n @param selector      A function selector\n @return Whether the funcion selector is scheduled.\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?isScheduled@CCNode@cocos2d@@QAE_NP8CCObject@2@AEXM@Z@Z"]
    pub fn cocos2d_CCNode_isScheduled(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Schedules the \"update\" method.\n\n It will use the order number 0. This method will be called every frame.\n Scheduled methods with a lower order value will be called before the ones that have a higher order value.\n Only one \"update\" method could be scheduled per node.\n @lua NA"]
    #[link_name = "\u{1}?scheduleUpdate@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_scheduleUpdate(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Schedules the \"update\" method with a custom priority.\n\n This selector will be called every frame.\n Scheduled methods with a lower priority will be called before the ones that have a higher value.\n Only one \"update\" selector could be scheduled per node (You can't have 2 'update' selectors).\n @lua NA"]
    #[link_name = "\u{1}?scheduleUpdateWithPriority@CCNode@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCNode_scheduleUpdateWithPriority(
        this: *mut cocos2d_CCNode,
        priority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?unscheduleUpdate@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_unscheduleUpdate(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Schedules a custom selector.\n\n If the selector is already scheduled, then the interval parameter will be updated without scheduling it again.\n @code\n // firstly, implement a schedule function\n void MyNode::TickMe(float dt);\n // wrap this function into a selector via schedule_selector marco.\n this->schedule(schedule_selector(MyNode::TickMe), 0, 0, 0);\n @endcode\n\n @param interval  Tick interval in seconds. 0 means tick every frame. If interval = 0, it's recommended to use scheduleUpdate() instead.\n @param repeat    The selector will be excuted (repeat + 1) times, you can use kCCRepeatForever for tick infinitely.\n @param delay     The amount of time that the first tick will wait before execution.\n @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QAEXP8CCObject@2@AEXM@ZMIM@Z"]
    pub fn cocos2d_CCNode_schedule(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
    );
}
extern "thiscall" {
    #[doc = " Schedules a custom selector with an interval time in seconds.\n @see schedule(SEL_SCHEDULE, float, unsigned int, float)\n\n @param selector      A function wrapped as a selector\n @param interval      Callback interval time in seconds. 0 means tick every frame,\n @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QAEXP8CCObject@2@AEXM@ZM@Z"]
    pub fn cocos2d_CCNode_schedule1(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
    );
}
extern "thiscall" {
    #[doc = " Schedules a selector that runs only once, with a delay of 0 or larger\n @see schedule(SEL_SCHEDULE, float, unsigned int, float)\n\n @param selector      A function wrapped as a selector\n @param delay         The amount of time that the first tick will wait before execution.\n @lua NA"]
    #[link_name = "\u{1}?scheduleOnce@CCNode@cocos2d@@QAEXP8CCObject@2@AEXM@ZM@Z"]
    pub fn cocos2d_CCNode_scheduleOnce(
        this: *mut cocos2d_CCNode,
        selector: cocos2d_SEL_SCHEDULE,
        delay: f32,
    );
}
extern "thiscall" {
    #[doc = " Schedules a custom selector, the scheduled selector will be ticked every frame\n @see schedule(SEL_SCHEDULE, float, unsigned int, float)\n\n @param selector      A function wrapped as a selector\n @lua NA"]
    #[link_name = "\u{1}?schedule@CCNode@cocos2d@@QAEXP8CCObject@2@AEXM@Z@Z"]
    pub fn cocos2d_CCNode_schedule2(this: *mut cocos2d_CCNode, selector: cocos2d_SEL_SCHEDULE);
}
extern "thiscall" {
    #[doc = " Unschedules a custom selector.\n @see schedule(SEL_SCHEDULE, float, unsigned int, float)\n\n @param selector      A function wrapped as a selector\n @lua NA"]
    #[link_name = "\u{1}?unschedule@CCNode@cocos2d@@QAEXP8CCObject@2@AEXM@Z@Z"]
    pub fn cocos2d_CCNode_unschedule(this: *mut cocos2d_CCNode, selector: cocos2d_SEL_SCHEDULE);
}
extern "thiscall" {
    #[doc = " Unschedule all scheduled selectors: custom selectors, and the 'update' selector.\n Actions are not affected by this method."]
    #[link_name = "\u{1}?unscheduleAllSelectors@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_unscheduleAllSelectors(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Resumes all scheduled selectors and actions.\n This method is called internally by onEnter\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?resumeSchedulerAndActions@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_resumeSchedulerAndActions(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Pauses all scheduled selectors and actions.\n This method is called internally by onExit\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?pauseSchedulerAndActions@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_pauseSchedulerAndActions(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Performs OpenGL view-matrix transformation based on position, scale, rotation and other attributes."]
    #[link_name = "\u{1}?transform@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_transform(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Performs OpenGL view-matrix transformation of it's ancestors.\n Generally the ancestors are already transformed, but in certain cases (eg: attaching a FBO)\n It's necessary to transform the ancestors again."]
    #[link_name = "\u{1}?transformAncestors@CCNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCNode_transformAncestors(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Converts a Point to node (local) space coordinates. The result is in Points."]
    #[link_name = "\u{1}?convertToNodeSpace@CCNode@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCNode_convertToNodeSpace(
        this: *mut cocos2d_CCNode,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Converts a Point to world space coordinates. The result is in Points."]
    #[link_name = "\u{1}?convertToWorldSpace@CCNode@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCNode_convertToWorldSpace(
        this: *mut cocos2d_CCNode,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Converts a Point to node (local) space coordinates. The result is in Points.\n treating the returned/received node point as anchor relative."]
    #[link_name = "\u{1}?convertToNodeSpaceAR@CCNode@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCNode_convertToNodeSpaceAR(
        this: *mut cocos2d_CCNode,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Converts a local Point to world space coordinates.The result is in Points.\n treating the returned/received node point as anchor relative."]
    #[link_name = "\u{1}?convertToWorldSpaceAR@CCNode@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCNode_convertToWorldSpaceAR(
        this: *mut cocos2d_CCNode,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " convenience methods which take a CCTouch instead of CCPoint"]
    #[link_name = "\u{1}?convertTouchToNodeSpace@CCNode@cocos2d@@QAE?AVCCPoint@2@PAVCCTouch@2@@Z"]
    pub fn cocos2d_CCNode_convertTouchToNodeSpace(
        this: *mut cocos2d_CCNode,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " converts a CCTouch (world coordinates) into a local coordinate. This method is AR (Anchor Relative)."]
    #[link_name = "\u{1}?convertTouchToNodeSpaceAR@CCNode@cocos2d@@QAE?AVCCPoint@2@PAVCCTouch@2@@Z"]
    pub fn cocos2d_CCNode_convertTouchToNodeSpaceAR(
        this: *mut cocos2d_CCNode,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = "  Sets the additional transform.\n\n  @note The additional transform will be concatenated at the end of nodeToParentTransform.\n        It could be used to simulate `parent-child` relationship between two nodes (e.g. one is in BatchNode, another isn't).\n  @code\n// create a batchNode\nCCSpriteBatchNode* batch= CCSpriteBatchNode::create(\"Icon-114.png\");\nthis->addChild(batch);\n\n// create two sprites, spriteA will be added to batchNode, they are using different textures.\nCCSprite* spriteA = CCSprite::createWithTexture(batch->getTexture());\nCCSprite* spriteB = CCSprite::create(\"Icon-72.png\");\n\nbatch->addChild(spriteA);\n\n// We can't make spriteB as spriteA's child since they use different textures. So just add it to layer.\n// But we want to simulate `parent-child` relationship for these two node.\nthis->addChild(spriteB);\n\n//position\nspriteA->setPosition(ccp(200, 200));\n\n// Gets the spriteA's transform.\nCCAffineTransform t = spriteA->nodeToParentTransform();\n\n// Sets the additional transform to spriteB, spriteB's postion will based on its pseudo parent i.e. spriteA.\nspriteB->setAdditionalTransform(t);\n\n//scale\nspriteA->setScale(2);\n\n// Gets the spriteA's transform.\nt = spriteA->nodeToParentTransform();\n\n// Sets the additional transform to spriteB, spriteB's scale will based on its pseudo parent i.e. spriteA.\nspriteB->setAdditionalTransform(t);\n\n//rotation\nspriteA->setRotation(20);\n\n// Gets the spriteA's transform.\nt = spriteA->nodeToParentTransform();\n\n// Sets the additional transform to spriteB, spriteB's rotation will based on its pseudo parent i.e. spriteA.\nspriteB->setAdditionalTransform(t);\n  @endcode"]
    #[link_name = "\u{1}?setAdditionalTransform@CCNode@cocos2d@@QAEXABUCCAffineTransform@2@@Z"]
    pub fn cocos2d_CCNode_setAdditionalTransform(
        this: *mut cocos2d_CCNode,
        additionalTransform: *const cocos2d_CCAffineTransform,
    );
}
extern "thiscall" {
    #[doc = " @{\n @name component functions\n**\n*   gets a component by its name\n*/"]
    #[link_name = "\u{1}?getComponent@CCNode@cocos2d@@QBEPAVCCComponent@2@PBD@Z"]
    pub fn cocos2d_CCNode_getComponent(
        this: *const cocos2d_CCNode,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent;
}
extern "thiscall" {
    #[doc = " Default constructor\n @js ctor"]
    #[link_name = "\u{1}??0CCNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCNode_CCNode(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCNode@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCNode_CCNode1(this: *mut cocos2d_CCNode, arg1: *const cocos2d_CCNode);
}
impl cocos2d_CCNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCNode {
        cocos2d_CCNode_create()
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCNode_description(self)
    }
    #[inline]
    pub unsafe fn scheduleUpdateWithPriorityLua(
        &mut self,
        nHandler: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    ) {
        cocos2d_CCNode_scheduleUpdateWithPriorityLua(self, nHandler, priority)
    }
    #[inline]
    pub unsafe fn boundingBox(&mut self) -> cocos2d_CCRect {
        cocos2d_CCNode_boundingBox(self)
    }
    #[inline]
    pub unsafe fn runAction(&mut self, action: *mut cocos2d_CCAction) -> *mut cocos2d_CCAction {
        cocos2d_CCNode_runAction(self, action)
    }
    #[inline]
    pub unsafe fn stopAllActions(&mut self) {
        cocos2d_CCNode_stopAllActions(self)
    }
    #[inline]
    pub unsafe fn stopAction(&mut self, action: *mut cocos2d_CCAction) {
        cocos2d_CCNode_stopAction(self, action)
    }
    #[inline]
    pub unsafe fn stopActionByTag(&mut self, tag: ::std::os::raw::c_int) {
        cocos2d_CCNode_stopActionByTag(self, tag)
    }
    #[inline]
    pub unsafe fn getActionByTag(&mut self, tag: ::std::os::raw::c_int) -> *mut cocos2d_CCAction {
        cocos2d_CCNode_getActionByTag(self, tag)
    }
    #[inline]
    pub unsafe fn numberOfRunningActions(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCNode_numberOfRunningActions(self)
    }
    #[inline]
    pub unsafe fn isScheduled(&mut self, selector: cocos2d_SEL_SCHEDULE) -> bool {
        cocos2d_CCNode_isScheduled(self, selector)
    }
    #[inline]
    pub unsafe fn scheduleUpdate(&mut self) {
        cocos2d_CCNode_scheduleUpdate(self)
    }
    #[inline]
    pub unsafe fn scheduleUpdateWithPriority(&mut self, priority: ::std::os::raw::c_int) {
        cocos2d_CCNode_scheduleUpdateWithPriority(self, priority)
    }
    #[inline]
    pub unsafe fn unscheduleUpdate(&mut self) {
        cocos2d_CCNode_unscheduleUpdate(self)
    }
    #[inline]
    pub unsafe fn schedule(
        &mut self,
        selector: cocos2d_SEL_SCHEDULE,
        interval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
    ) {
        cocos2d_CCNode_schedule(self, selector, interval, repeat, delay)
    }
    #[inline]
    pub unsafe fn schedule1(&mut self, selector: cocos2d_SEL_SCHEDULE, interval: f32) {
        cocos2d_CCNode_schedule1(self, selector, interval)
    }
    #[inline]
    pub unsafe fn scheduleOnce(&mut self, selector: cocos2d_SEL_SCHEDULE, delay: f32) {
        cocos2d_CCNode_scheduleOnce(self, selector, delay)
    }
    #[inline]
    pub unsafe fn schedule2(&mut self, selector: cocos2d_SEL_SCHEDULE) {
        cocos2d_CCNode_schedule2(self, selector)
    }
    #[inline]
    pub unsafe fn unschedule(&mut self, selector: cocos2d_SEL_SCHEDULE) {
        cocos2d_CCNode_unschedule(self, selector)
    }
    #[inline]
    pub unsafe fn unscheduleAllSelectors(&mut self) {
        cocos2d_CCNode_unscheduleAllSelectors(self)
    }
    #[inline]
    pub unsafe fn resumeSchedulerAndActions(&mut self) {
        cocos2d_CCNode_resumeSchedulerAndActions(self)
    }
    #[inline]
    pub unsafe fn pauseSchedulerAndActions(&mut self) {
        cocos2d_CCNode_pauseSchedulerAndActions(self)
    }
    #[inline]
    pub unsafe fn transform(&mut self) {
        cocos2d_CCNode_transform(self)
    }
    #[inline]
    pub unsafe fn transformAncestors(&mut self) {
        cocos2d_CCNode_transformAncestors(self)
    }
    #[inline]
    pub unsafe fn convertToNodeSpace(
        &mut self,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToNodeSpace(self, worldPoint)
    }
    #[inline]
    pub unsafe fn convertToWorldSpace(
        &mut self,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToWorldSpace(self, nodePoint)
    }
    #[inline]
    pub unsafe fn convertToNodeSpaceAR(
        &mut self,
        worldPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToNodeSpaceAR(self, worldPoint)
    }
    #[inline]
    pub unsafe fn convertToWorldSpaceAR(
        &mut self,
        nodePoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertToWorldSpaceAR(self, nodePoint)
    }
    #[inline]
    pub unsafe fn convertTouchToNodeSpace(
        &mut self,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertTouchToNodeSpace(self, touch)
    }
    #[inline]
    pub unsafe fn convertTouchToNodeSpaceAR(
        &mut self,
        touch: *mut cocos2d_CCTouch,
    ) -> cocos2d_CCPoint {
        cocos2d_CCNode_convertTouchToNodeSpaceAR(self, touch)
    }
    #[inline]
    pub unsafe fn setAdditionalTransform(
        &mut self,
        additionalTransform: *const cocos2d_CCAffineTransform,
    ) {
        cocos2d_CCNode_setAdditionalTransform(self, additionalTransform)
    }
    #[inline]
    pub unsafe fn getComponent(
        &self,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent {
        cocos2d_CCNode_getComponent(self, pName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNode_CCNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNode_CCNode1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " Default destructor\n @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCNode_CCNode_destructor(this: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = "  Initializes the instance of CCNode\n  @return Whether the initialization was successful."]
    #[link_name = "\u{1}?init@CCNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Sets the Z order which stands for the drawing order, and reorder this node in its parent's children array.\n\n The Z order of node is relative to its \"brothers\": children of the same parent.\n It's nothing to do with OpenGL's z vertex. This one only affects the draw order of nodes in cocos2d.\n The larger number it is, the later this node will be drawn in each message loop.\n Please refer to setVertexZ(float) for the difference.\n\n @param nZOrder   Z order of this node."]
    #[link_name = "\u{1}?setZOrder@CCNode@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCNode_setZOrder(
        this: *mut ::std::os::raw::c_void,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Sets the z order which stands for the drawing order\n\n This is an internal method. Don't call it outside the framework.\n The difference between setZOrder(int) and _setOrder(int) is:\n - _setZOrder(int) is a pure setter for m_nZOrder memeber variable\n - setZOrder(int) firstly changes m_nZOrder, then recorder this node in its parent's chilren array."]
    #[link_name = "\u{1}?_setZOrder@CCNode@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCNode__setZOrder(this: *mut ::std::os::raw::c_void, z: ::std::os::raw::c_int);
}
extern "thiscall" {
    #[doc = " Gets the Z order of this node.\n\n @see setZOrder(int)\n\n @return The Z order."]
    #[link_name = "\u{1}?getZOrder@CCNode@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCNode_getZOrder(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " Sets the real OpenGL Z vertex.\n\n Differences between openGL Z vertex and cocos2d Z order:\n - OpenGL Z modifies the Z vertex, and not the Z order in the relation between parent-children\n - OpenGL Z might require to set 2D projection\n - cocos2d Z order works OK if all the nodes uses the same openGL Z vertex. eg: vertexZ = 0\n\n @warning Use it at your own risk since it might break the cocos2d parent-children z order\n\n @param fVertexZ  OpenGL Z vertex of this node."]
    #[link_name = "\u{1}?setVertexZ@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setVertexZ(this: *mut ::std::os::raw::c_void, vertexZ: f32);
}
extern "thiscall" {
    #[doc = " Gets OpenGL Z vertex of this node.\n\n @see setVertexZ(float)\n\n @return OpenGL Z vertex of this node"]
    #[link_name = "\u{1}?getVertexZ@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getVertexZ(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes the scale factor on X axis of this node\n\n The deafult value is 1.0 if you haven't changed it before\n\n @param fScaleX   The scale factor on X axis."]
    #[link_name = "\u{1}?setScaleX@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setScaleX(this: *mut ::std::os::raw::c_void, fScaleX: f32);
}
extern "thiscall" {
    #[doc = " Returns the scale factor on X axis of this node\n\n @see setScaleX(float)\n\n @return The scale factor on X axis."]
    #[link_name = "\u{1}?getScaleX@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getScaleX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes the scale factor on Y axis of this node\n\n The Default value is 1.0 if you haven't changed it before.\n\n @param fScaleY   The scale factor on Y axis."]
    #[link_name = "\u{1}?setScaleY@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setScaleY(this: *mut ::std::os::raw::c_void, fScaleY: f32);
}
extern "thiscall" {
    #[doc = " Returns the scale factor on Y axis of this node\n\n @see setScaleY(float)\n\n @return The scale factor on Y axis."]
    #[link_name = "\u{1}?getScaleY@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getScaleY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes both X and Y scale factor of the node.\n\n 1.0 is the default scale factor. It modifies the X and Y scale at the same time.\n\n @param scale     The scale factor for both X and Y axis."]
    #[link_name = "\u{1}?setScale@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setScale(this: *mut ::std::os::raw::c_void, scale: f32);
}
extern "thiscall" {
    #[doc = " Gets the scale factor of the node,  when X and Y have the same scale factor.\n\n @warning Assert when m_fScaleX != m_fScaleY.\n @see setScale(float)\n\n @return The scale factor of the node."]
    #[link_name = "\u{1}?getScale@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getScale(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes both X and Y scale factor of the node.\n\n 1.0 is the default scale factor. It modifies the X and Y scale at the same time.\n\n @param fScaleX     The scale factor on X axis.\n @param fScaleY     The scale factor on Y axis."]
    #[link_name = "\u{1}?setScale@CCNode@cocos2d@@UAEXMM@Z"]
    pub fn cocos2d_CCNode_setScale1(this: *mut ::std::os::raw::c_void, fScaleX: f32, fScaleY: f32);
}
extern "thiscall" {
    #[doc = " Changes the position (x,y) of the node in OpenGL coordinates\n\n Usually we use ccp(x,y) to compose CCPoint object.\n The original point (0,0) is at the left-bottom corner of screen.\n For example, this codesnip sets the node in the center of screen.\n @code\n CCSize size = CCDirector::sharedDirector()->getWinSize();\n node->setPosition( ccp(size.width/2, size.height/2) )\n @endcode\n\n @param position  The position (x,y) of the node in OpenGL coordinates\n @js NA"]
    #[link_name = "\u{1}?setPosition@CCNode@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCNode_setPosition(
        this: *mut ::std::os::raw::c_void,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " Gets the position (x,y) of the node in OpenGL coordinates\n\n @see setPosition(const CCPoint&)\n\n @return The position (x,y) of the node in OpenGL coordinates"]
    #[link_name = "\u{1}?getPosition@CCNode@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getPosition(this: *mut ::std::os::raw::c_void) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Sets position in a more efficient way.\n\n Passing two numbers (x,y) is much efficient than passing CCPoint object.\n This method is binded to lua and javascript.\n Passing a number is 10 times faster than passing a object from lua to c++\n\n @code\n // sample code in lua\n local pos  = node::getPosition()  -- returns CCPoint object from C++\n node:setPosition(x, y)            -- pass x, y coordinate to C++\n @endcode\n\n @param x     X coordinate for position\n @param y     Y coordinate for position\n @js NA"]
    #[link_name = "\u{1}?setPosition@CCNode@cocos2d@@UAEXMM@Z"]
    pub fn cocos2d_CCNode_setPosition1(this: *mut ::std::os::raw::c_void, x: f32, y: f32);
}
extern "thiscall" {
    #[doc = " Gets position in a more efficient way, returns two number instead of a CCPoint object\n\n @see setPosition(float, float)"]
    #[link_name = "\u{1}?getPosition@CCNode@cocos2d@@UAEXPAM0@Z"]
    pub fn cocos2d_CCNode_getPosition1(this: *mut ::std::os::raw::c_void, x: *mut f32, y: *mut f32);
}
extern "thiscall" {
    #[doc = " Gets/Sets x or y coordinate individually for position.\n These methods are used in Lua and Javascript Bindings"]
    #[link_name = "\u{1}?setPositionX@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setPositionX(this: *mut ::std::os::raw::c_void, x: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getPositionX@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getPositionX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setPositionY@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setPositionY(this: *mut ::std::os::raw::c_void, y: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getPositionY@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getPositionY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes the X skew angle of the node in degrees.\n\n This angle describes the shear distortion in the X direction.\n Thus, it is the angle between the Y axis and the left edge of the shape\n The default skewX angle is 0. Positive values distort the node in a CW direction.\n\n @param fSkewX The X skew angle of the node in degrees."]
    #[link_name = "\u{1}?setSkewX@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setSkewX(this: *mut ::std::os::raw::c_void, fSkewX: f32);
}
extern "thiscall" {
    #[doc = " Returns the X skew angle of the node in degrees.\n\n @see setSkewX(float)\n\n @return The X skew angle of the node in degrees."]
    #[link_name = "\u{1}?getSkewX@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getSkewX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Changes the Y skew angle of the node in degrees.\n\n This angle describes the shear distortion in the Y direction.\n Thus, it is the angle between the X axis and the bottom edge of the shape\n The default skewY angle is 0. Positive values distort the node in a CCW direction.\n\n @param fSkewY    The Y skew angle of the node in degrees."]
    #[link_name = "\u{1}?setSkewY@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setSkewY(this: *mut ::std::os::raw::c_void, fSkewY: f32);
}
extern "thiscall" {
    #[doc = " Returns the Y skew angle of the node in degrees.\n\n @see setSkewY(float)\n\n @return The Y skew angle of the node in degrees."]
    #[link_name = "\u{1}?getSkewY@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getSkewY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Sets the anchor point in percent.\n\n anchorPoint is the point around which all transformations and positioning manipulations take place.\n It's like a pin in the node where it is \"attached\" to its parent.\n The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.\n But you can use values higher than (1,1) and lower than (0,0) too.\n The default anchorPoint is (0.5,0.5), so it starts in the center of the node.\n\n @param anchorPoint   The anchor point of node."]
    #[link_name = "\u{1}?setAnchorPoint@CCNode@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCNode_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        anchorPoint: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " Returns the anchor point in percent.\n\n @see setAnchorPoint(const CCPoint&)\n\n @return The anchor point of node."]
    #[link_name = "\u{1}?getAnchorPoint@CCNode@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getAnchorPoint(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Returns the anchorPoint in absolute pixels.\n\n @warning You can only read it. If you wish to modify it, use anchorPoint instead.\n @see getAnchorPoint()\n\n @return The anchor point in absolute pixels."]
    #[link_name = "\u{1}?getAnchorPointInPoints@CCNode@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCNode_getAnchorPointInPoints(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Sets the untransformed size of the node.\n\n The contentSize remains the same no matter the node is scaled or rotated.\n All nodes has a size. Layer and Scene has the same size of the screen.\n\n @param contentSize   The untransformed size of the node."]
    #[link_name = "\u{1}?setContentSize@CCNode@cocos2d@@UAEXABVCCSize@2@@Z"]
    pub fn cocos2d_CCNode_setContentSize(
        this: *mut ::std::os::raw::c_void,
        contentSize: *const cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[doc = " Returns the untransformed size of the node.\n\n @see setContentSize(const CCSize&)\n\n @return The untransformed size of the node."]
    #[link_name = "\u{1}?getContentSize@CCNode@cocos2d@@UBEABVCCSize@2@XZ"]
    pub fn cocos2d_CCNode_getContentSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "thiscall" {
    #[link_name = "\u{1}?getScaledContentSize@CCNode@cocos2d@@UAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCNode_getScaledContentSize(this: *mut ::std::os::raw::c_void)
        -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " Sets whether the node is visible\n\n The default value is true, a node is default to visible\n\n @param visible   true if the node is visible, false if the node is hidden."]
    #[link_name = "\u{1}?setVisible@CCNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNode_setVisible(this: *mut ::std::os::raw::c_void, visible: bool);
}
extern "thiscall" {
    #[doc = " Determines if the node is visible\n\n @see setVisible(bool)\n\n @return true if the node is visible, false if the node is hidden."]
    #[link_name = "\u{1}?isVisible@CCNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNode_isVisible(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Sets the rotation (angle) of the node in degrees.\n\n 0 is the default rotation angle.\n Positive values rotate node clockwise, and negative values for anti-clockwise.\n\n @param fRotation     The roration of the node in degrees."]
    #[link_name = "\u{1}?setRotation@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setRotation(this: *mut ::std::os::raw::c_void, fRotation: f32);
}
extern "thiscall" {
    #[doc = " Returns the rotation of the node in degrees.\n\n @see setRotation(float)\n\n @return The rotation of the node in degrees."]
    #[link_name = "\u{1}?getRotation@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getRotation(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.\n\n 0 is the default rotation angle.\n Positive values rotate node clockwise, and negative values for anti-clockwise.\n\n @param fRotationX    The X rotation in degrees which performs a horizontal rotational skew."]
    #[link_name = "\u{1}?setRotationX@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setRotationX(this: *mut ::std::os::raw::c_void, fRotaionX: f32);
}
extern "thiscall" {
    #[doc = " Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.\n\n @see setRotationX(float)\n\n @return The X rotation in degrees."]
    #[link_name = "\u{1}?getRotationX@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getRotationX(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.\n\n 0 is the default rotation angle.\n Positive values rotate node clockwise, and negative values for anti-clockwise.\n\n @param fRotationY    The Y rotation in degrees."]
    #[link_name = "\u{1}?setRotationY@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_setRotationY(this: *mut ::std::os::raw::c_void, fRotationY: f32);
}
extern "thiscall" {
    #[doc = " Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.\n\n @see setRotationY(float)\n\n @return The Y rotation in degrees."]
    #[link_name = "\u{1}?getRotationY@CCNode@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCNode_getRotationY(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " Sets the arrival order when this node has a same ZOrder with other children.\n\n A node which called addChild subsequently will take a larger arrival order,\n If two children have the same Z order, the child with larger arrival order will be drawn later.\n\n @warning This method is used internally for zOrder sorting, don't change this manually\n\n @param uOrderOfArrival   The arrival order."]
    #[link_name = "\u{1}?setOrderOfArrival@CCNode@cocos2d@@UAEXI@Z"]
    pub fn cocos2d_CCNode_setOrderOfArrival(
        this: *mut ::std::os::raw::c_void,
        uOrderOfArrival: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Returns the arrival order, indecates which children is added previously.\n\n @see setOrderOfArrival(unsigned int)\n\n @return The arrival order."]
    #[link_name = "\u{1}?getOrderOfArrival@CCNode@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCNode_getOrderOfArrival(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Sets the state of OpenGL server side.\n\n @param glServerState     The state of OpenGL server side.\n @js NA"]
    #[link_name = "\u{1}?setGLServerState@CCNode@cocos2d@@UAEXW4ccGLServerState@2@@Z"]
    pub fn cocos2d_CCNode_setGLServerState(
        this: *mut ::std::os::raw::c_void,
        glServerState: cocos2d_ccGLServerState,
    );
}
extern "thiscall" {
    #[doc = " Returns the state of OpenGL server side.\n\n @return The state of OpenGL server side.\n @js NA"]
    #[link_name = "\u{1}?getGLServerState@CCNode@cocos2d@@UAE?AW4ccGLServerState@2@XZ"]
    pub fn cocos2d_CCNode_getGLServerState(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccGLServerState;
}
extern "thiscall" {
    #[doc = " Sets whether the anchor point will be (0,0) when you position this node.\n\n This is an internal method, only used by CCLayer and CCScene. Don't call it outside framework.\n The default value is false, while in CCLayer and CCScene are true\n\n @param ignore    true if anchor point will be (0,0) when you position this node\n @todo This method shoud be renamed as setIgnoreAnchorPointForPosition(bool) or something with \"set\""]
    #[link_name = "\u{1}?ignoreAnchorPointForPosition@CCNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNode_ignoreAnchorPointForPosition(
        this: *mut ::std::os::raw::c_void,
        ignore: bool,
    );
}
extern "thiscall" {
    #[doc = " Gets whether the anchor point will be (0,0) when you position this node.\n\n @see ignoreAnchorPointForPosition(bool)\n\n @return true if the anchor point will be (0,0) when you position this node."]
    #[link_name = "\u{1}?isIgnoreAnchorPointForPosition@CCNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNode_isIgnoreAnchorPointForPosition(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "thiscall" {
    #[doc = " Adds a child to the container with z-order as 0.\n\n If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.\n\n @param child A child node"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UAEXPAV12@@Z"]
    pub fn cocos2d_CCNode_addChild(this: *mut ::std::os::raw::c_void, child: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Adds a child to the container with a z-order\n\n If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.\n\n @param child     A child node\n @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UAEXPAV12@H@Z"]
    pub fn cocos2d_CCNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Adds a child to the container with z order and tag\n\n If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.\n\n @param child     A child node\n @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)\n @param tag       A interger to identify the node easily. Please refer to setTag(int)"]
    #[link_name = "\u{1}?addChild@CCNode@cocos2d@@UAEXPAV12@HH@Z"]
    pub fn cocos2d_CCNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Gets a child from the container with its tag\n\n @param tag   An identifier to find the child node.\n\n @return a CCNode object whose tag equals to the input parameter"]
    #[link_name = "\u{1}?getChildByTag@CCNode@cocos2d@@UAEPAV12@H@Z"]
    pub fn cocos2d_CCNode_getChildByTag(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " Return an array of children\n\n Composing a \"tree\" structure is a very important feature of CCNode\n Here's a sample code of traversing children array:\n @code\n CCNode* node = NULL;\n CCARRAY_FOREACH(parent->getChildren(), node)\n {\n     node->setPosition(0,0);\n }\n @endcode\n This sample code traverses all children nodes, and set theie position to (0,0)\n\n @return An array of children"]
    #[link_name = "\u{1}?getChildren@CCNode@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCNode_getChildren(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " Get the amount of children.\n\n @return The amount of children."]
    #[link_name = "\u{1}?getChildrenCount@CCNode@cocos2d@@UBEIXZ"]
    pub fn cocos2d_CCNode_getChildrenCount(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Sets the parent node\n\n @param parent    A pointer to the parnet node"]
    #[link_name = "\u{1}?setParent@CCNode@cocos2d@@UAEXPAV12@@Z"]
    pub fn cocos2d_CCNode_setParent(this: *mut ::std::os::raw::c_void, parent: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[doc = " Returns a pointer to the parent node\n\n @see setParent(CCNode*)\n\n @returns A pointer to the parnet node"]
    #[link_name = "\u{1}?getParent@CCNode@cocos2d@@UAEPAV12@XZ"]
    pub fn cocos2d_CCNode_getParent(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " Removes this node itself from its parent node with a cleanup.\n If the node orphan, then nothing happens.\n @see removeFromParentAndCleanup(bool)"]
    #[link_name = "\u{1}?removeFromParent@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_removeFromParent(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Removes this node itself from its parent node.\n If the node orphan, then nothing happens.\n @param cleanup   true if all actions and callbacks on this node should be removed, false otherwise.\n @js removeFromParent"]
    #[link_name = "\u{1}?removeFromParentAndCleanup@CCNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNode_removeFromParentAndCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeMeAndCleanup@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_removeMeAndCleanup(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Removes a child from the container with a cleanup\n\n @see removeChild(CCNode, bool)\n\n @param child     The child node which will be removed."]
    #[link_name = "\u{1}?removeChild@CCNode@cocos2d@@UAEXPAV12@@Z"]
    pub fn cocos2d_CCNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.\n\n @param child     The child node which will be removed.\n @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise."]
    #[link_name = "\u{1}?removeChild@CCNode@cocos2d@@UAEXPAV12@_N@Z"]
    pub fn cocos2d_CCNode_removeChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[doc = " Removes a child from the container by tag value with a cleanup.\n\n @see removeChildByTag(int, bool)\n\n @param tag       An interger number that identifies a child node"]
    #[link_name = "\u{1}?removeChildByTag@CCNode@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCNode_removeChildByTag(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter\n\n @param tag       An interger number that identifies a child node\n @param cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise."]
    #[link_name = "\u{1}?removeChildByTag@CCNode@cocos2d@@UAEXH_N@Z"]
    pub fn cocos2d_CCNode_removeChildByTag1(
        this: *mut ::std::os::raw::c_void,
        tag: ::std::os::raw::c_int,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[doc = " Removes all children from the container with a cleanup.\n\n @see removeAllChildrenWithCleanup(bool)"]
    #[link_name = "\u{1}?removeAllChildren@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_removeAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.\n\n @param cleanup   true if all running actions on all children nodes should be cleanup, false oterwise.\n @js removeAllChildren"]
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[doc = " Reorders a child according to a new z value.\n\n @param child     An already added child node. It MUST be already added.\n @param zOrder    Z order for drawing priority. Please refer to setZOrder(int)"]
    #[link_name = "\u{1}?reorderChild@CCNode@cocos2d@@UAEXPAV12@H@Z"]
    pub fn cocos2d_CCNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Sorts the children array once before drawing, instead of every time when a child is added or reordered.\n This appraoch can improves the performance massively.\n @note Don't call this manually unless a child added needs to be removed in the same frame"]
    #[link_name = "\u{1}?sortAllChildren@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Returns a grid object that is used when applying effects\n\n @return A CCGrid object that is used when applying effects\n @js NA"]
    #[link_name = "\u{1}?getGrid@CCNode@cocos2d@@UAEPAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCNode_getGrid(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCGridBase;
}
extern "thiscall" {
    #[doc = " Changes a grid object that is used when applying effects\n\n @param A CCGrid object that is used when applying effects"]
    #[link_name = "\u{1}?setGrid@CCNode@cocos2d@@UAEXPAVCCGridBase@2@@Z"]
    pub fn cocos2d_CCNode_setGrid(
        this: *mut ::std::os::raw::c_void,
        pGrid: *mut cocos2d_CCGridBase,
    );
}
extern "thiscall" {
    #[doc = " Returns a custom user data pointer\n\n You can set everything in UserData pointer, a data block, a structure or an object.\n\n @return A custom user data pointer\n @js NA"]
    #[link_name = "\u{1}?getUserData@CCNode@cocos2d@@UAEPAXXZ"]
    pub fn cocos2d_CCNode_getUserData(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "thiscall" {
    #[doc = " Sets a custom user data pointer\n\n You can set everything in UserData pointer, a data block, a structure or an object, etc.\n @warning Don't forget to release the memroy manually,\n          especially before you change this data pointer, and before this node is autoreleased.\n\n @return A custom user data pointer\n @js NA"]
    #[link_name = "\u{1}?setUserData@CCNode@cocos2d@@UAEXPAX@Z"]
    pub fn cocos2d_CCNode_setUserData(
        this: *mut ::std::os::raw::c_void,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "thiscall" {
    #[doc = " Returns a user assigned CCObject\n\n Similar to userData, but instead of holding a void* it holds an object\n\n @return A user assigned CCObject\n @js NA"]
    #[link_name = "\u{1}?getUserObject@CCNode@cocos2d@@UAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCNode_getUserObject(this: *mut ::std::os::raw::c_void)
        -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " Returns a user assigned CCObject\n\n Similar to UserData, but instead of holding a void* it holds an object.\n The UserObject will be retained once in this method,\n and the previous UserObject (if existed) will be relese.\n The UserObject will be released in CCNode's destructure.\n\n @param A user assigned CCObject"]
    #[link_name = "\u{1}?setUserObject@CCNode@cocos2d@@UAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCNode_setUserObject(
        this: *mut ::std::os::raw::c_void,
        pUserObject: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " @{\n @name Shader Program\n**\n* Return the shader program currently used for this node\n*\n* @return The shader program currelty used for this node\n*/"]
    #[link_name = "\u{1}?getShaderProgram@CCNode@cocos2d@@UAEPAVCCGLProgram@2@XZ"]
    pub fn cocos2d_CCNode_getShaderProgram(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "thiscall" {
    #[doc = " Sets the shader program for this node\n\n Since v2.0, each rendering node must set its shader program.\n It should be set in initialize phase.\n @code\n node->setShaderProgram(CCShaderCache::sharedShaderCache()->programForKey(kCCShader_PositionTextureColor));\n @endcode\n\n @param The shader program which fetchs from CCShaderCache."]
    #[link_name = "\u{1}?setShaderProgram@CCNode@cocos2d@@UAEXPAVCCGLProgram@2@@Z"]
    pub fn cocos2d_CCNode_setShaderProgram(
        this: *mut ::std::os::raw::c_void,
        pShaderProgram: *mut cocos2d_CCGLProgram,
    );
}
extern "thiscall" {
    #[doc = " Returns a camera object that lets you move the node using a gluLookAt\n\n @code\n CCCamera* camera = node->getCamera();\n camera->setEyeXYZ(0, 0, 415/2);\n camera->setCenterXYZ(0, 0, 0);\n @endcode\n\n @return A CCCamera object that lets you move the node using a gluLookAt"]
    #[link_name = "\u{1}?getCamera@CCNode@cocos2d@@UAEPAVCCCamera@2@XZ"]
    pub fn cocos2d_CCNode_getCamera(this: *mut ::std::os::raw::c_void) -> *mut cocos2d_CCCamera;
}
extern "thiscall" {
    #[doc = " Returns whether or not the node accepts event callbacks.\n\n Running means the node accept event callbacks like onEnter(), onExit(), update()\n\n @return Whether or not the node is running."]
    #[link_name = "\u{1}?isRunning@CCNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNode_isRunning(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Registers a script function that will be called in onEnter() & onExit() seires functions.\n\n This handler will be removed automatically after onExit() called.\n @code\n -- lua sample\n local function sceneEventHandler(eventType)\n     if eventType == kCCNodeOnEnter then\n         -- do something\n     elseif evetType == kCCNodeOnExit then\n         -- do something\n     end\n end\n scene::registerScriptHandler(sceneEventHandler)\n @endcode\n\n @warning This method is for internal usage, don't call it manually.\n @todo Perhaps we should rename it to get/set/removeScriptHandler acoording to the function name style.\n\n @param handler   A number that indicates a lua function."]
    #[link_name = "\u{1}?registerScriptHandler@CCNode@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCNode_registerScriptHandler(
        this: *mut ::std::os::raw::c_void,
        handler: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Unregisters a script function that will be called in onEnter() & onExit() series functions.\n\n @see registerScriptHandler(int)"]
    #[link_name = "\u{1}?unregisterScriptHandler@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_unregisterScriptHandler(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Event callback that is invoked every time when CCNode enters the 'stage'.\n If the CCNode enters the 'stage' with a transition, this event is called when the transition starts.\n During onEnter you can't access a \"sister/brother\" node.\n If you override onEnter, you shall call its parent's one, e.g., CCNode::onEnter().\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?onEnter@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Event callback that is invoked when the CCNode enters in the 'stage'.\n If the CCNode enters the 'stage' with a transition, this event is called when the transition finishes.\n If you override onEnterTransitionDidFinish, you shall call its parent's one, e.g. CCNode::onEnterTransitionDidFinish()\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Event callback that is invoked every time the CCNode leaves the 'stage'.\n If the CCNode leaves the 'stage' with a transition, this event is called when the transition finishes.\n During onExit you can't access a sibling node.\n If you override onExit, you shall call its parent's one, e.g., CCNode::onExit().\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?onExit@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Event callback that is called every time the CCNode leaves the 'stage'.\n If the CCNode leaves the 'stage' with a transition, this callback is called when the transition starts.\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?onExitTransitionDidStart@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_onExitTransitionDidStart(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Stops all running actions and schedulers"]
    #[link_name = "\u{1}?cleanup@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_cleanup(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Override this method to draw your own node.\n The following GL states will be enabled by default:\n - glEnableClientState(GL_VERTEX_ARRAY);\n - glEnableClientState(GL_COLOR_ARRAY);\n - glEnableClientState(GL_TEXTURE_COORD_ARRAY);\n - glEnable(GL_TEXTURE_2D);\n AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE\n But if you enable any other GL state, you should disable it after drawing your node."]
    #[link_name = "\u{1}?draw@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Visits this node's children and draw them recursively."]
    #[link_name = "\u{1}?visit@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_visit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Sets the CCActionManager object that is used by all actions.\n\n @warning If you set a new CCActionManager, then previously created actions will be removed.\n\n @param actionManager     A CCActionManager object that is used by all actions."]
    #[link_name = "\u{1}?setActionManager@CCNode@cocos2d@@UAEXPAVCCActionManager@2@@Z"]
    pub fn cocos2d_CCNode_setActionManager(
        this: *mut ::std::os::raw::c_void,
        actionManager: *mut cocos2d_CCActionManager,
    );
}
extern "thiscall" {
    #[doc = " Gets the CCActionManager object that is used by all actions.\n @see setActionManager(CCActionManager*)\n @return A CCActionManager object."]
    #[link_name = "\u{1}?getActionManager@CCNode@cocos2d@@UAEPAVCCActionManager@2@XZ"]
    pub fn cocos2d_CCNode_getActionManager(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionManager;
}
extern "thiscall" {
    #[doc = " Sets a CCScheduler object that is used to schedule all \"updates\" and timers.\n\n @warning If you set a new CCScheduler, then previously created timers/update are going to be removed.\n @param scheduler     A CCShdeduler object that is used to schedule all \"update\" and timers.\n @js NA"]
    #[link_name = "\u{1}?setScheduler@CCNode@cocos2d@@UAEXPAVCCScheduler@2@@Z"]
    pub fn cocos2d_CCNode_setScheduler(
        this: *mut ::std::os::raw::c_void,
        scheduler: *mut cocos2d_CCScheduler,
    );
}
extern "thiscall" {
    #[doc = " Gets a CCSheduler object.\n\n @see setScheduler(CCScheduler*)\n @return A CCScheduler object.\n @js NA"]
    #[link_name = "\u{1}?getScheduler@CCNode@cocos2d@@UAEPAVCCScheduler@2@XZ"]
    pub fn cocos2d_CCNode_getScheduler(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCScheduler;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCNode@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCNode_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "thiscall" {
    #[doc = " Calls children's updateTransform() method recursively.\n\n This method is moved from CCSprite, so it's no longer specific to CCSprite.\n As the result, you apply CCSpriteBatchNode's optimization on your customed CCNode.\n e.g., batchNode->addChild(myCustomNode), while you can only addChild(sprite) before."]
    #[link_name = "\u{1}?updateTransform@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_updateTransform(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?nodeToParentTransform@CCNode@cocos2d@@UAE?BUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToParentTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[link_name = "\u{1}?nodeToParentTransformFast@CCNode@cocos2d@@UAE?BUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToParentTransformFast(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[link_name = "\u{1}?parentToNodeTransform@CCNode@cocos2d@@UAE?BUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_parentToNodeTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[doc = " Returns the world affine transform matrix. The matrix is in Pixels."]
    #[link_name = "\u{1}?nodeToWorldTransform@CCNode@cocos2d@@UAE?AUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToWorldTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[link_name = "\u{1}?nodeToWorldTransformFast@CCNode@cocos2d@@UAE?AUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_nodeToWorldTransformFast(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[doc = " Returns the inverse world affine transform matrix. The matrix is in Pixels."]
    #[link_name = "\u{1}?worldToNodeTransform@CCNode@cocos2d@@UAE?AUCCAffineTransform@2@XZ"]
    pub fn cocos2d_CCNode_worldToNodeTransform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCAffineTransform;
}
extern "thiscall" {
    #[doc = "   adds a component"]
    #[link_name = "\u{1}?addComponent@CCNode@cocos2d@@UAE_NPAVCCComponent@2@@Z"]
    pub fn cocos2d_CCNode_addComponent(
        this: *mut ::std::os::raw::c_void,
        pComponent: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "   removes a component by its name"]
    #[link_name = "\u{1}?removeComponent@CCNode@cocos2d@@UAE_NPBD@Z"]
    pub fn cocos2d_CCNode_removeComponent(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "   removes a component by its pointer"]
    #[link_name = "\u{1}?removeComponent@CCNode@cocos2d@@UAE_NPAVCCComponent@2@@Z"]
    pub fn cocos2d_CCNode_removeComponent1(
        this: *mut ::std::os::raw::c_void,
        pComponent: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "   removes all components"]
    #[link_name = "\u{1}?removeAllComponents@CCNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCNode_removeAllComponents(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @} end of component functions"]
    #[link_name = "\u{1}?updateTweenAction@CCNode@cocos2d@@UAEXMPBD@Z"]
    pub fn cocos2d_CCNode_updateTweenAction(
        this: *mut ::std::os::raw::c_void,
        arg1: f32,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @} end of component functions"]
    #[link_name = "\u{1}?updateTweenActionInt@CCNode@cocos2d@@UAEXMH@Z"]
    pub fn cocos2d_CCNode_updateTweenActionInt(
        this: *mut ::std::os::raw::c_void,
        arg1: f32,
        arg2: ::std::os::raw::c_int,
    );
}
#[doc = " CCNodeRGBA is a subclass of CCNode that implements the CCRGBAProtocol protocol.\n\nAll features from CCNode are valid, plus the following new features:\n- opacity\n- RGB colors\n\nOpacity/Color propagates into children that conform to the CCRGBAProtocol if cascadeOpacity/cascadeColor is enabled.\n@since v2.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNodeRGBA {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCRGBAProtocol,
    pub _displayedOpacity: GLubyte,
    pub _realOpacity: GLubyte,
    pub _displayedColor: cocos2d_ccColor3B,
    pub _realColor: cocos2d_ccColor3B,
    pub _cascadeColorEnabled: bool,
    pub _cascadeOpacityEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNodeRGBA() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCNodeRGBA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNodeRGBA>(),
        280usize,
        concat!("Size of: ", stringify!(cocos2d_CCNodeRGBA))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNodeRGBA>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNodeRGBA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._displayedOpacity) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_displayedOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._realOpacity) as usize - ptr as usize },
        269usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_realOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._displayedColor) as usize - ptr as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_displayedColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._realColor) as usize - ptr as usize },
        273usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_realColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cascadeColorEnabled) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_cascadeColorEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cascadeOpacityEnabled) as usize - ptr as usize },
        277usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNodeRGBA),
            "::",
            stringify!(_cascadeOpacityEnabled)
        )
    );
}
extern "C" {
    #[doc = " Allocates and initializes a nodergba.\n @return A initialized node which is marked as \"autorelease\"."]
    #[link_name = "\u{1}?create@CCNodeRGBA@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCNodeRGBA_create() -> *mut cocos2d_CCNodeRGBA;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCNodeRGBA@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCNodeRGBA_CCNodeRGBA(this: *mut cocos2d_CCNodeRGBA);
}
impl cocos2d_CCNodeRGBA {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCNodeRGBA {
        cocos2d_CCNodeRGBA_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNodeRGBA_CCNodeRGBA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCNodeRGBA@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCNodeRGBA_CCNodeRGBA_destructor(this: *mut cocos2d_CCNodeRGBA);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCNodeRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNodeRGBA_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getOpacity@CCNodeRGBA@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCNodeRGBA_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCNodeRGBA@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCNodeRGBA_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCNodeRGBA@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCNodeRGBA_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCNodeRGBA@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCNodeRGBA_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCNodeRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNodeRGBA_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCNodeRGBA@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNodeRGBA_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getColor@CCNodeRGBA@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCNodeRGBA_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedColor@CCNodeRGBA@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCNodeRGBA_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setColor@CCNodeRGBA@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCNodeRGBA_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedColor@CCNodeRGBA@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCNodeRGBA_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCNodeRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCNodeRGBA_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCNodeRGBA@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCNodeRGBA_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
#[doc = " @brief A CCSpriteFrame has:\n- texture: A CCTexture2D that will be used by the CCSprite\n- rectangle: A rectangle of the texture\n\n\nYou can modify the frame of a CCSprite by doing:\n\nCCSpriteFrame *frame = CCSpriteFrame::frameWithTexture(texture, rect, offset);\nsprite->setDisplayFrame(frame);"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteFrame {
    pub _base: cocos2d_CCObject,
    pub m_obOffset: cocos2d_CCPoint,
    pub m_obOriginalSize: cocos2d_CCSize,
    pub m_obRectInPixels: cocos2d_CCRect,
    pub m_bRotated: bool,
    pub m_obRect: cocos2d_CCRect,
    pub m_obOffsetInPixels: cocos2d_CCPoint,
    pub m_obOriginalSizeInPixels: cocos2d_CCSize,
    pub m_pobTexture: *mut cocos2d_CCTexture2D,
    pub m_strTextureFilename: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteFrame() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSpriteFrame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteFrame>(),
        148usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteFrame>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obOriginalSize) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOriginalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obRectInPixels) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obRectInPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRotated) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_bRotated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obRect) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obOffsetInPixels) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOffsetInPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obOriginalSizeInPixels) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_obOriginalSizeInPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobTexture) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_pobTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strTextureFilename) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrame),
            "::",
            stringify!(m_strTextureFilename)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRectInPixels@CCSpriteFrame@cocos2d@@QAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setRectInPixels(
        this: *mut cocos2d_CCSpriteFrame,
        rectInPixels: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " set rect of the frame"]
    #[link_name = "\u{1}?setRect@CCSpriteFrame@cocos2d@@QAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setRect(
        this: *mut cocos2d_CCSpriteFrame,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " get offset of the frame"]
    #[link_name = "\u{1}?getOffsetInPixels@CCSpriteFrame@cocos2d@@QAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getOffsetInPixels(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " set offset of the frame"]
    #[link_name = "\u{1}?setOffsetInPixels@CCSpriteFrame@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setOffsetInPixels(
        this: *mut cocos2d_CCSpriteFrame,
        offsetInPixels: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " get texture of the frame"]
    #[link_name = "\u{1}?getTexture@CCSpriteFrame@cocos2d@@QAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getTexture(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " set texture of the frame, the texture is retained"]
    #[link_name = "\u{1}?setTexture@CCSpriteFrame@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setTexture(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getOffset@CCSpriteFrame@cocos2d@@QAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCSpriteFrame_getOffset(
        this: *mut cocos2d_CCSpriteFrame,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOffset@CCSpriteFrame@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_setOffset(
        this: *mut cocos2d_CCSpriteFrame,
        offsets: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture filename, rect in points.\nIt is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?create@CCSpriteFrame@cocos2d@@SAPAV12@PBDABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_create(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels.\nThe originalSize is the size in pixels of the frame before being trimmed."]
    #[link_name = "\u{1}?create@CCSpriteFrame@cocos2d@@SAPAV12@PBDABVCCRect@2@_NABVCCPoint@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_create1(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture, rect in points.\nIt is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteFrame@cocos2d@@SAPAV12@PAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_createWithTexture(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Create a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.\nThe originalSize is the size in points of the frame before being trimmed."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteFrame@cocos2d@@SAPAV12@PAVCCTexture2D@2@ABVCCRect@2@_NABVCCPoint@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_createWithTexture1(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "thiscall" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect in points.\nIt is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteFrame@cocos2d@@QAE_NPAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTexture(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a CCSpriteFrame with a texture filename, rect in points;\nIt is assumed that the frame was not trimmed."]
    #[link_name = "\u{1}?initWithTextureFilename@CCSpriteFrame@cocos2d@@QAE_NPBDABVCCRect@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTextureFilename(
        this: *mut cocos2d_CCSpriteFrame,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.\nThe originalSize is the size in points of the frame before being trimmed."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteFrame@cocos2d@@QAE_NPAVCCTexture2D@2@ABVCCRect@2@_NABVCCPoint@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTexture1(
        this: *mut cocos2d_CCSpriteFrame,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a CCSpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.\nThe originalSize is the size in pixels of the frame before being trimmed.\n\n@since v1.1"]
    #[link_name = "\u{1}?initWithTextureFilename@CCSpriteFrame@cocos2d@@QAE_NPBDABVCCRect@2@_NABVCCPoint@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_initWithTextureFilename1(
        this: *mut cocos2d_CCSpriteFrame,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool;
}
impl cocos2d_CCSpriteFrame {
    #[inline]
    pub unsafe fn setRectInPixels(&mut self, rectInPixels: *const cocos2d_CCRect) {
        cocos2d_CCSpriteFrame_setRectInPixels(self, rectInPixels)
    }
    #[inline]
    pub unsafe fn setRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCSpriteFrame_setRect(self, rect)
    }
    #[inline]
    pub unsafe fn getOffsetInPixels(&mut self) -> *const cocos2d_CCPoint {
        cocos2d_CCSpriteFrame_getOffsetInPixels(self)
    }
    #[inline]
    pub unsafe fn setOffsetInPixels(&mut self, offsetInPixels: *const cocos2d_CCPoint) {
        cocos2d_CCSpriteFrame_setOffsetInPixels(self, offsetInPixels)
    }
    #[inline]
    pub unsafe fn getTexture(&mut self) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCSpriteFrame_getTexture(self)
    }
    #[inline]
    pub unsafe fn setTexture(&mut self, pobTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCSpriteFrame_setTexture(self, pobTexture)
    }
    #[inline]
    pub unsafe fn getOffset(&mut self) -> *const cocos2d_CCPoint {
        cocos2d_CCSpriteFrame_getOffset(self)
    }
    #[inline]
    pub unsafe fn setOffset(&mut self, offsets: *const cocos2d_CCPoint) {
        cocos2d_CCSpriteFrame_setOffset(self, offsets)
    }
    #[inline]
    pub unsafe fn create(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_create(filename, rect)
    }
    #[inline]
    pub unsafe fn create1(
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_create1(filename, rect, rotated, offset, originalSize)
    }
    #[inline]
    pub unsafe fn createWithTexture(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_createWithTexture(pobTexture, rect)
    }
    #[inline]
    pub unsafe fn createWithTexture1(
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrame_createWithTexture1(pobTexture, rect, rotated, offset, originalSize)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTexture(self, pobTexture, rect)
    }
    #[inline]
    pub unsafe fn initWithTextureFilename(
        &mut self,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTextureFilename(self, filename, rect)
    }
    #[inline]
    pub unsafe fn initWithTexture1(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTexture1(
            self,
            pobTexture,
            rect,
            rotated,
            offset,
            originalSize,
        )
    }
    #[inline]
    pub unsafe fn initWithTextureFilename1(
        &mut self,
        filename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        offset: *const cocos2d_CCPoint,
        originalSize: *const cocos2d_CCSize,
    ) -> bool {
        cocos2d_CCSpriteFrame_initWithTextureFilename1(
            self,
            filename,
            rect,
            rotated,
            offset,
            originalSize,
        )
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCSpriteFrame@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSpriteFrame_CCSpriteFrame_destructor(this: *mut cocos2d_CCSpriteFrame);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpriteFrame@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpriteFrame_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @addtogroup data_structures\n @{\n @ js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCString {
    pub _base: cocos2d_CCObject,
    pub m_sString: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCString() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCString>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCString))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCString>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sString) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCString),
            "::",
            stringify!(m_sString)
        )
    );
}
extern "C" {
    #[doc = " init a string with format, it's similar with the c function 'sprintf'\n @lua NA"]
    #[link_name = "\u{1}?initWithFormat@CCString@cocos2d@@QAA_NPBDZZ"]
    pub fn cocos2d_CCString_initWithFormat(
        this: *mut cocos2d_CCString,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "thiscall" {
    #[doc = " convert to int value"]
    #[link_name = "\u{1}?intValue@CCString@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCString_intValue(this: *const cocos2d_CCString) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " convert to unsigned int value"]
    #[link_name = "\u{1}?uintValue@CCString@cocos2d@@QBEIXZ"]
    pub fn cocos2d_CCString_uintValue(this: *const cocos2d_CCString) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " convert to float value"]
    #[link_name = "\u{1}?floatValue@CCString@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCString_floatValue(this: *const cocos2d_CCString) -> f32;
}
extern "thiscall" {
    #[doc = " convert to double value"]
    #[link_name = "\u{1}?doubleValue@CCString@cocos2d@@QBENXZ"]
    pub fn cocos2d_CCString_doubleValue(this: *const cocos2d_CCString) -> f64;
}
extern "thiscall" {
    #[doc = " convert to bool value"]
    #[link_name = "\u{1}?boolValue@CCString@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCString_boolValue(this: *const cocos2d_CCString) -> bool;
}
extern "thiscall" {
    #[doc = " get the C string"]
    #[link_name = "\u{1}?getCString@CCString@cocos2d@@QBEPBDXZ"]
    pub fn cocos2d_CCString_getCString(
        this: *const cocos2d_CCString,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " get the length of string"]
    #[link_name = "\u{1}?length@CCString@cocos2d@@QBEIXZ"]
    pub fn cocos2d_CCString_length(this: *const cocos2d_CCString) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " compare to a c string"]
    #[link_name = "\u{1}?compare@CCString@cocos2d@@QBEHPBD@Z"]
    pub fn cocos2d_CCString_compare(
        this: *const cocos2d_CCString,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " create a string with std string, you can also pass a c string pointer because the default constructor of std::string can access a c string pointer.\n  @return A CCString pointer which is an autorelease object pointer,\n          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?create@CCString@cocos2d@@SAPAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCString_create(str_: *const std_string) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with format, it's similar with the c function 'sprintf', the default buffer size is (1024*100) bytes,\n  if you want to change it, you should modify the kMaxStringLen macro in CCString.cpp file.\n  @return A CCString pointer which is an autorelease object pointer,\n          it means that you needn't do a release operation unless you retain it.\n  @lua NA"]
    #[link_name = "\u{1}?createWithFormat@CCString@cocos2d@@SAPAV12@PBDZZ"]
    pub fn cocos2d_CCString_createWithFormat(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with binary data\n  @return A CCString pointer which is an autorelease object pointer,\n          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?createWithData@CCString@cocos2d@@SAPAV12@PBEK@Z"]
    pub fn cocos2d_CCString_createWithData(
        pData: *const ::std::os::raw::c_uchar,
        nLen: ::std::os::raw::c_ulong,
    ) -> *mut cocos2d_CCString;
}
extern "C" {
    #[doc = " create a string with a file,\n  @return A CCString pointer which is an autorelease object pointer,\n          it means that you needn't do a release operation unless you retain it."]
    #[link_name = "\u{1}?createWithContentsOfFile@CCString@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCString_createWithContentsOfFile(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCString_CCString(this: *mut cocos2d_CCString);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QAE@PBD@Z"]
    pub fn cocos2d_CCString_CCString1(
        this: *mut cocos2d_CCString,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCString_CCString2(this: *mut cocos2d_CCString, str_: *const std_string);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCString@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCString_CCString3(this: *mut cocos2d_CCString, str_: *const cocos2d_CCString);
}
impl cocos2d_CCString {
    #[inline]
    pub unsafe fn intValue(&self) -> ::std::os::raw::c_int {
        cocos2d_CCString_intValue(self)
    }
    #[inline]
    pub unsafe fn uintValue(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCString_uintValue(self)
    }
    #[inline]
    pub unsafe fn floatValue(&self) -> f32 {
        cocos2d_CCString_floatValue(self)
    }
    #[inline]
    pub unsafe fn doubleValue(&self) -> f64 {
        cocos2d_CCString_doubleValue(self)
    }
    #[inline]
    pub unsafe fn boolValue(&self) -> bool {
        cocos2d_CCString_boolValue(self)
    }
    #[inline]
    pub unsafe fn getCString(&self) -> *const ::std::os::raw::c_char {
        cocos2d_CCString_getCString(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCString_length(self)
    }
    #[inline]
    pub unsafe fn compare(&self, arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
        cocos2d_CCString_compare(self, arg1)
    }
    #[inline]
    pub unsafe fn create(str_: *const std_string) -> *mut cocos2d_CCString {
        cocos2d_CCString_create(str_)
    }
    #[inline]
    pub unsafe fn createWithData(
        pData: *const ::std::os::raw::c_uchar,
        nLen: ::std::os::raw::c_ulong,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCString_createWithData(pData, nLen)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCString_createWithContentsOfFile(pszFileName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(str_: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString1(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(str_: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString2(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(str_: *const cocos2d_CCString) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCString_CCString3(__bindgen_tmp.as_mut_ptr(), str_);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??1CCString@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCString_CCString_destructor(this: *mut cocos2d_CCString);
}
extern "thiscall" {
    #[link_name = "\u{1}?copyWithZone@CCString@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCString_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?isEqual@CCString@cocos2d@@UAE_NPBVCCObject@2@@Z"]
    pub fn cocos2d_CCString_isEqual(
        this: *mut ::std::os::raw::c_void,
        pObject: *const cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?acceptVisitor@CCString@cocos2d@@UAEXAAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCString_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
#[doc = "  CCDictElement is used for traversing CCDictionary.\n\n  A CCDictElement is one element of CCDictionary, it contains two properties, key and object.\n  Its key has two different type (integer and string).\n\n  @note The key type is unique, all the elements in CCDictionary has the same key type(integer or string).\n  @code\n  CCDictElement* pElement;\n  CCDICT_FOREACH(dict, pElement)\n  {\n      const char*key = pElement->getStrKey();\n      // You certainly know the type of value, so we assume that it's a CCSprite.\n      CCSprite* pSprite = (CCSprite*)pElement->getObject();\n      // ......\n  }\n  @endcode\n  @js NA\n  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDictElement {
    pub m_szKey: [::std::os::raw::c_char; 256usize],
    pub m_iKey: isize,
    pub m_pObject: *mut cocos2d_CCObject,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDictElement() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDictElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDictElement>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCDictElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDictElement>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDictElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_szKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_iKey) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_iKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pObject) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(m_pObject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictElement),
            "::",
            stringify!(hh)
        )
    );
}
extern "thiscall" {
    #[doc = "  The destructor of CCDictElement."]
    #[link_name = "\u{1}??1CCDictElement@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCDictElement_CCDictElement_destructor(this: *mut cocos2d_CCDictElement);
}
impl cocos2d_CCDictElement {
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCDictElement_CCDictElement_destructor(self)
    }
}
#[doc = "  CCDictionary is a class like NSDictionary in Obj-C .\n\n  @note Only the pointer of CCObject or its subclass can be inserted to CCDictionary.\n  @code\n  // Create a dictionary, return an autorelease object.\n  CCDictionary* pDict = CCDictionary::create();\n\n  // Insert objects to dictionary\n  CCString* pValue1 = CCString::create(\"100\");\n  CCString* pValue2 = CCString::create(\"120\");\n  CCInteger* pValue3 = CCInteger::create(200);\n  pDict->setObject(pValue1, \"key1\");\n  pDict->setObject(pValue2, \"key2\");\n  pDict->setObject(pValue3, \"key3\");\n\n  // Get the object for key\n  CCString* pStr1 = (CCString*)pDict->objectForKey(\"key1\");\n  CCLog(\"{ key1: %s }\", pStr1->getCString());\n  CCInteger* pInteger = (CCInteger*)pDict->objectForKey(\"key3\");\n  CCLog(\"{ key3: %d }\", pInteger->getValue());\n  @endcode\n  @js NA\n"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDictionary {
    pub _base: cocos2d_CCObject,
    #[doc = "  All the elements in dictionary.\n\n  @note For internal usage, we need to declare this member variable as public since it's used in UT_HASH."]
    pub m_pElements: *mut cocos2d_CCDictElement,
    #[doc = "  The type of dictionary, it's assigned to kCCDictUnknown by default."]
    pub m_eDictType: cocos2d_CCDictionary_CCDictType,
}
pub const cocos2d_CCDictionary_CCDictType_kCCDictUnknown: cocos2d_CCDictionary_CCDictType = 0;
pub const cocos2d_CCDictionary_CCDictType_kCCDictStr: cocos2d_CCDictionary_CCDictType = 1;
pub const cocos2d_CCDictionary_CCDictType_kCCDictInt: cocos2d_CCDictionary_CCDictType = 2;
#[doc = " The support type of dictionary, it's confirmed when setObject is invoked."]
pub type cocos2d_CCDictionary_CCDictType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCDictionary() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDictionary> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDictionary>(),
        60usize,
        concat!("Size of: ", stringify!(cocos2d_CCDictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDictionary>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDictionary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pElements) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictionary),
            "::",
            stringify!(m_pElements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eDictType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDictionary),
            "::",
            stringify!(m_eDictType)
        )
    );
}
extern "thiscall" {
    #[doc = "  Get the count of elements in CCDictionary.\n\n  @return  The count of elements."]
    #[link_name = "\u{1}?count@CCDictionary@cocos2d@@QAEIXZ"]
    pub fn cocos2d_CCDictionary_count(this: *mut cocos2d_CCDictionary) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = "  Return all keys of elements.\n\n  @return  The array contains all keys of elements. It's an autorelease object yet."]
    #[link_name = "\u{1}?allKeys@CCDictionary@cocos2d@@QAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCDictionary_allKeys(this: *mut cocos2d_CCDictionary) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = "  Get all keys according to the specified object.\n  @warning  We use '==' to compare two objects\n  @return   The array contains all keys for the specified object. It's an autorelease object yet."]
    #[link_name = "\u{1}?allKeysForObject@CCDictionary@cocos2d@@QAEPAVCCArray@2@PAVCCObject@2@@Z"]
    pub fn cocos2d_CCDictionary_allKeysForObject(
        this: *mut cocos2d_CCDictionary,
        object: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = "  Get the object according to the specified string key.\n\n  @note The dictionary needs to use string as key. If integer is passed, an assert will appear.\n  @param key  The string key for searching.\n  @return The object matches the key. You need to force convert it to the type you know.\n  @code\n     // Assume that the elements are CCString* pointers. Convert it by following code.\n     CCString* pStr = (CCString*)pDict->objectForKey(\"key1\");\n     // Do something about pStr.\n     // If you don't know the object type, properly you need to use dynamic_cast<SomeType*> to check it.\n     CCString* pStr2 = dynamic_cast<CCString*>(pDict->objectForKey(\"key1\"));\n     if (pStr2 != NULL) {\n          // Do something about pStr2\n     }\n  @endcode\n  @see objectForKey(intptr_t)"]
    #[link_name = "\u{1}?objectForKey@CCDictionary@cocos2d@@QAEPAVCCObject@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_objectForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = "  Get the object according to the specified integer key.\n\n  @note The dictionary needs to use integer as key. If string is passed, an assert will appear.\n  @param key  The integer key for searching.\n  @return The object matches the key.\n  @see objectForKey(const std::string&)"]
    #[link_name = "\u{1}?objectForKey@CCDictionary@cocos2d@@QAEPAVCCObject@2@H@Z"]
    pub fn cocos2d_CCDictionary_objectForKey1(
        this: *mut cocos2d_CCDictionary,
        key: isize,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " Get the value according to the specified string key.\n\n  @note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer.\n  @param key  The string key for searching\n  @return An instance of CCString.\n          It will return an empty string if the objects aren't CCString pointer or the key wasn't found.\n  @see valueForKey(intptr_t)"]
    #[link_name = "\u{1}?valueForKey@CCDictionary@cocos2d@@QAEPBVCCString@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_valueForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    ) -> *const cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " Get the value according to the specified integer key.\n\n  @note Be careful to use this function since it assumes the objects in the dictionary are CCString pointer.\n  @param key  The string key for searching.\n  @return An instance of CCString.\n          It will return an empty string if the objects aren't CCString pointer or the key wasn't found.\n  @see valueForKey(intptr_t)"]
    #[link_name = "\u{1}?valueForKey@CCDictionary@cocos2d@@QAEPBVCCString@2@H@Z"]
    pub fn cocos2d_CCDictionary_valueForKey1(
        this: *mut cocos2d_CCDictionary,
        key: isize,
    ) -> *const cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " Insert an object to dictionary, and match it with the specified string key.\n\n  @note Whe the first time this method is invoked, the key type will be set to string.\n        After that you can't setObject with an integer key.\n        If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary.\n        Then the new object will be inserted after that.\n\n  @param pObject  The Object to be inserted.\n  @param key      The string key for searching.\n  @see setObject(CCObject*, intptr_t)"]
    #[link_name = "\u{1}?setObject@CCDictionary@cocos2d@@QAEXPAVCCObject@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_setObject(
        this: *mut cocos2d_CCDictionary,
        pObject: *mut cocos2d_CCObject,
        key: *const std_string,
    );
}
extern "thiscall" {
    #[doc = " Insert an object to dictionary, and match it with the specified string key.\n\n  @note Then the first time this method is invoked, the key type will be set to string.\n        After that you can't setObject with an integer key.\n        If the dictionary contains the key you passed, the object matching the key will be released and removed from dictionary.\n        Then the new object will be inserted after that.\n  @param pObject  The Object to be inserted.\n  @param key      The string key for searching.\n  @see setObject(CCObject*, const std::string&)"]
    #[link_name = "\u{1}?setObject@CCDictionary@cocos2d@@QAEXPAVCCObject@2@H@Z"]
    pub fn cocos2d_CCDictionary_setObject1(
        this: *mut cocos2d_CCDictionary,
        pObject: *mut cocos2d_CCObject,
        key: isize,
    );
}
extern "thiscall" {
    #[doc = "  Remove an object by the specified string key.\n\n  @param key  The string key for searching.\n  @see removeObjectForKey(intptr_t), removeObjectsForKeys(CCArray*),\n       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectForKey@CCDictionary@cocos2d@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForKey(
        this: *mut cocos2d_CCDictionary,
        key: *const std_string,
    );
}
extern "thiscall" {
    #[doc = "  Remove an object by the specified integer key.\n\n  @param key  The integer key for searching.\n  @see removeObjectForKey(const std::string&), removeObjectsForKeys(CCArray*),\n       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectForKey@CCDictionary@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForKey1(this: *mut cocos2d_CCDictionary, key: isize);
}
extern "thiscall" {
    #[doc = "  Remove objects by an array of keys.\n\n  @param pKeyArray  The array contains keys to be removed.\n  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),\n       removeObjectForElememt(CCDictElement*), removeAllObjects()."]
    #[link_name = "\u{1}?removeObjectsForKeys@CCDictionary@cocos2d@@QAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectsForKeys(
        this: *mut cocos2d_CCDictionary,
        pKeyArray: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = "  Remove an object by an element.\n\n  @param pElement  The element need to be removed.\n  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),\n       removeObjectsForKeys(CCArray*), removeAllObjects().\n  @lua NA"]
    #[link_name = "\u{1}?removeObjectForElememt@CCDictionary@cocos2d@@QAEXPAVCCDictElement@2@@Z"]
    pub fn cocos2d_CCDictionary_removeObjectForElememt(
        this: *mut cocos2d_CCDictionary,
        pElement: *mut cocos2d_CCDictElement,
    );
}
extern "thiscall" {
    #[doc = "  Remove all objects in the dictionary.\n\n  @see removeObjectForKey(const std::string&), removeObjectForKey(intptr_t),\n       removeObjectsForKeys(CCArray*), removeObjectForElememt(CCDictElement*)."]
    #[link_name = "\u{1}?removeAllObjects@CCDictionary@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDictionary_removeAllObjects(this: *mut cocos2d_CCDictionary);
}
extern "thiscall" {
    #[doc = "  Return a random object in the dictionary.\n\n  @return The random object.\n  @see objectForKey(intptr_t), objectForKey(const std::string&)\n  @lua NA"]
    #[link_name = "\u{1}?randomObject@CCDictionary@cocos2d@@QAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCDictionary_randomObject(
        this: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCObject;
}
extern "C" {
    #[doc = "  Create a dictionary.\n  @return A dictionary which is an autorelease object.\n  @see createWithDictionary(CCDictionary*), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?create@CCDictionary@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCDictionary_create() -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Create a dictionary with an existing dictionary.\n\n  @param srcDict The exist dictionary.\n  @return A dictionary which is an autorelease object.\n  @see create(), createWithContentsOfFile(const char*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?createWithDictionary@CCDictionary@cocos2d@@SAPAV12@PAV12@@Z"]
    pub fn cocos2d_CCDictionary_createWithDictionary(
        srcDict: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = "  Create a dictionary with a plist file.\n  @param  pFileName  The name of the plist file.\n  @return A dictionary which is an autorelease object.\n  @see create(), createWithDictionary(CCDictionary*), createWithContentsOfFileThreadSafe(const char*)."]
    #[link_name = "\u{1}?createWithContentsOfFile@CCDictionary@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCDictionary_createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = "  Write a dictionary to a plist file.\n  @param fullPath The full path of the plist file. You can get writeable path by getWritablePath()\n  @return true if successed, false if failed\n  @lua NA"]
    #[link_name = "\u{1}?writeToFile@CCDictionary@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCDictionary_writeToFile(
        this: *mut cocos2d_CCDictionary,
        fullPath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "  Create a dictionary with a plist file.\n\n  @note the return object isn't an autorelease object.\n        This can make sure not using autorelease pool in a new thread.\n        Therefore, you need to manage the lifecycle of the return object.\n        It means that when you don't need it, CC_SAFE_RELEASE needs to be invoked.\n\n  @param  pFileName  The name of the plist file.\n  @return A dictionary which isn't an autorelease object.\n  @lua NA"]
    #[link_name = "\u{1}?createWithContentsOfFileThreadSafe@CCDictionary@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCDictionary_createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " The constructor of CCDictionary.\n @lua NA"]
    #[link_name = "\u{1}??0CCDictionary@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCDictionary_CCDictionary(this: *mut cocos2d_CCDictionary);
}
impl cocos2d_CCDictionary {
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCDictionary_count(self)
    }
    #[inline]
    pub unsafe fn allKeys(&mut self) -> *mut cocos2d_CCArray {
        cocos2d_CCDictionary_allKeys(self)
    }
    #[inline]
    pub unsafe fn allKeysForObject(
        &mut self,
        object: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCArray {
        cocos2d_CCDictionary_allKeysForObject(self, object)
    }
    #[inline]
    pub unsafe fn objectForKey(&mut self, key: *const std_string) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_objectForKey(self, key)
    }
    #[inline]
    pub unsafe fn objectForKey1(&mut self, key: isize) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_objectForKey1(self, key)
    }
    #[inline]
    pub unsafe fn valueForKey(&mut self, key: *const std_string) -> *const cocos2d_CCString {
        cocos2d_CCDictionary_valueForKey(self, key)
    }
    #[inline]
    pub unsafe fn valueForKey1(&mut self, key: isize) -> *const cocos2d_CCString {
        cocos2d_CCDictionary_valueForKey1(self, key)
    }
    #[inline]
    pub unsafe fn setObject(&mut self, pObject: *mut cocos2d_CCObject, key: *const std_string) {
        cocos2d_CCDictionary_setObject(self, pObject, key)
    }
    #[inline]
    pub unsafe fn setObject1(&mut self, pObject: *mut cocos2d_CCObject, key: isize) {
        cocos2d_CCDictionary_setObject1(self, pObject, key)
    }
    #[inline]
    pub unsafe fn removeObjectForKey(&mut self, key: *const std_string) {
        cocos2d_CCDictionary_removeObjectForKey(self, key)
    }
    #[inline]
    pub unsafe fn removeObjectForKey1(&mut self, key: isize) {
        cocos2d_CCDictionary_removeObjectForKey1(self, key)
    }
    #[inline]
    pub unsafe fn removeObjectsForKeys(&mut self, pKeyArray: *mut cocos2d_CCArray) {
        cocos2d_CCDictionary_removeObjectsForKeys(self, pKeyArray)
    }
    #[inline]
    pub unsafe fn removeObjectForElememt(&mut self, pElement: *mut cocos2d_CCDictElement) {
        cocos2d_CCDictionary_removeObjectForElememt(self, pElement)
    }
    #[inline]
    pub unsafe fn removeAllObjects(&mut self) {
        cocos2d_CCDictionary_removeAllObjects(self)
    }
    #[inline]
    pub unsafe fn randomObject(&mut self) -> *mut cocos2d_CCObject {
        cocos2d_CCDictionary_randomObject(self)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_create()
    }
    #[inline]
    pub unsafe fn createWithDictionary(
        srcDict: *mut cocos2d_CCDictionary,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithDictionary(srcDict)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFile(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithContentsOfFile(pFileName)
    }
    #[inline]
    pub unsafe fn writeToFile(&mut self, fullPath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCDictionary_writeToFile(self, fullPath)
    }
    #[inline]
    pub unsafe fn createWithContentsOfFileThreadSafe(
        pFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCDictionary_createWithContentsOfFileThreadSafe(pFileName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDictionary_CCDictionary(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " The destructor of CCDictionary\n @lua NA"]
    #[link_name = "\u{1}??1CCDictionary@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCDictionary_CCDictionary_destructor(this: *mut cocos2d_CCDictionary);
}
extern "thiscall" {
    #[doc = " @{\n @name Function override\n**\n*  This function is used for deepcopy elements from source dictionary to destination dictionary.\n*  You shouldn't invoke this function manually since it's called by CCObject::copy.\n*  @lua NA\n*  @js  NA\n*/"]
    #[link_name = "\u{1}?copyWithZone@CCDictionary@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCDictionary_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?acceptVisitor@CCDictionary@cocos2d@@UAEXAAVCCDataVisitor@2@@Z"]
    pub fn cocos2d_CCDictionary_acceptVisitor(
        this: *mut ::std::os::raw::c_void,
        visitor: *mut cocos2d_CCDataVisitor,
    );
}
#[doc = " CCAnimationFrame\nA frame of the animation. It contains information like:\n- sprite frame name\n- # of delay units.\n- offset\n\n@since v2.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimationFrame {
    pub _base: cocos2d_CCObject,
    #[doc = " CCSpriteFrameName to be used"]
    pub m_pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    #[doc = "  how many units of time the frame takes"]
    pub m_fDelayUnits: f32,
    #[doc = "  A CCAnimationFrameDisplayedNotification notification will be broadcast when the frame is displayed with this dictionary as UserInfo. If UserInfo is nil, then no notification will be broadcast."]
    pub m_pUserInfo: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimationFrame() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAnimationFrame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimationFrame>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimationFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimationFrame>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimationFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSpriteFrame) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_pSpriteFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDelayUnits) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_fDelayUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUserInfo) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationFrame),
            "::",
            stringify!(m_pUserInfo)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the animation frame with a spriteframe, number of delay units and a notification user info"]
    #[link_name = "\u{1}?initWithSpriteFrame@CCAnimationFrame@cocos2d@@QAE_NPAVCCSpriteFrame@2@MPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCAnimationFrame_initWithSpriteFrame(
        this: *mut cocos2d_CCAnimationFrame,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
        delayUnits: f32,
        userInfo: *mut cocos2d_CCDictionary,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimationFrame@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAnimationFrame_CCAnimationFrame(this: *mut cocos2d_CCAnimationFrame);
}
impl cocos2d_CCAnimationFrame {
    #[inline]
    pub unsafe fn initWithSpriteFrame(
        &mut self,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
        delayUnits: f32,
        userInfo: *mut cocos2d_CCDictionary,
    ) -> bool {
        cocos2d_CCAnimationFrame_initWithSpriteFrame(self, spriteFrame, delayUnits, userInfo)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimationFrame_CCAnimationFrame(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCAnimationFrame@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAnimationFrame_CCAnimationFrame_destructor(
        this: *mut cocos2d_CCAnimationFrame,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimationFrame@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimationFrame_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " A CCAnimation object is used to perform animations on the CCSprite objects.\n\nThe CCAnimation object contains CCAnimationFrame objects, and a possible delay between the frames.\nYou can animate a CCAnimation object by using the CCAnimate action. Example:\n\n[sprite runAction:[CCAnimate actionWithAnimation:animation]];"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimation {
    pub _base: cocos2d_CCObject,
    #[doc = " total Delay units of the CCAnimation."]
    pub m_fTotalDelayUnits: f32,
    #[doc = " Delay in seconds of the \"delay unit\""]
    pub m_fDelayPerUnit: f32,
    #[doc = " duration in seconds of the whole animation. It is the result of totalDelayUnits * delayPerUnit"]
    pub m_fDuration: f32,
    #[doc = " array of CCAnimationFrames"]
    pub m_pFrames: *mut cocos2d_CCArray,
    #[doc = " whether or not it shall restore the original frame when the animation finishes"]
    pub m_bRestoreOriginalFrame: bool,
    #[doc = " how many times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ..."]
    pub m_uLoops: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimation() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAnimation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimation>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimation))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimation>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTotalDelayUnits) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fTotalDelayUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDelayPerUnit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fDelayPerUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDuration) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_fDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFrames) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_pFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRestoreOriginalFrame) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_bRestoreOriginalFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uLoops) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimation),
            "::",
            stringify!(m_uLoops)
        )
    );
}
extern "C" {
    #[doc = " Creates an animation\n@since v0.99.5"]
    #[link_name = "\u{1}?create@CCAnimation@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCAnimation_create() -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[link_name = "\u{1}?createWithSpriteFrames@CCAnimation@cocos2d@@SAPAV12@PAVCCArray@2@M@Z"]
    pub fn cocos2d_CCAnimation_createWithSpriteFrames(
        arrayOfSpriteFrameNames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> *mut cocos2d_CCAnimation;
}
extern "C" {
    #[link_name = "\u{1}?create@CCAnimation@cocos2d@@SAPAV12@PAVCCArray@2@MI@Z"]
    pub fn cocos2d_CCAnimation_create1(
        arrayOfAnimationFrameNames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAnimation;
}
extern "thiscall" {
    #[doc = " Adds a CCSpriteFrame to a CCAnimation.\nThe frame will be added with one \"delay unit\"."]
    #[link_name = "\u{1}?addSpriteFrame@CCAnimation@cocos2d@@QAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrame(
        this: *mut cocos2d_CCAnimation,
        pFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "thiscall" {
    #[doc = " Adds a frame with an image filename. Internally it will create a CCSpriteFrame and it will add it.\nThe frame will be added with one \"delay unit\".\nAdded to facilitate the migration from v0.8 to v0.9.\n @js addSpriteFrameWithFile"]
    #[link_name = "\u{1}?addSpriteFrameWithFileName@CCAnimation@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrameWithFileName(
        this: *mut cocos2d_CCAnimation,
        pszFileName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Adds a frame with a texture and a rect. Internally it will create a CCSpriteFrame and it will add it.\nThe frame will be added with one \"delay unit\".\nAdded to facilitate the migration from v0.8 to v0.9."]
    #[link_name = "\u{1}?addSpriteFrameWithTexture@CCAnimation@cocos2d@@QAEXPAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCAnimation_addSpriteFrameWithTexture(
        this: *mut cocos2d_CCAnimation,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?init@CCAnimation@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCAnimation_init(this: *mut cocos2d_CCAnimation) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a CCAnimation with frames and a delay between frames\n@since v0.99.5\n@lua NA"]
    #[link_name = "\u{1}?initWithSpriteFrames@CCAnimation@cocos2d@@QAE_NPAVCCArray@2@M@Z"]
    pub fn cocos2d_CCAnimation_initWithSpriteFrames(
        this: *mut cocos2d_CCAnimation,
        pFrames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a CCAnimation with CCAnimationFrame\n@since v2.0\n@lua NA"]
    #[link_name = "\u{1}?initWithAnimationFrames@CCAnimation@cocos2d@@QAE_NPAVCCArray@2@MI@Z"]
    pub fn cocos2d_CCAnimation_initWithAnimationFrames(
        this: *mut cocos2d_CCAnimation,
        arrayOfAnimationFrames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimation@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAnimation_CCAnimation(this: *mut cocos2d_CCAnimation);
}
impl cocos2d_CCAnimation {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_create()
    }
    #[inline]
    pub unsafe fn createWithSpriteFrames(
        arrayOfSpriteFrameNames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_createWithSpriteFrames(arrayOfSpriteFrameNames, delay)
    }
    #[inline]
    pub unsafe fn create1(
        arrayOfAnimationFrameNames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimation_create1(arrayOfAnimationFrameNames, delayPerUnit, loops)
    }
    #[inline]
    pub unsafe fn addSpriteFrame(&mut self, pFrame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCAnimation_addSpriteFrame(self, pFrame)
    }
    #[inline]
    pub unsafe fn addSpriteFrameWithFileName(
        &mut self,
        pszFileName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimation_addSpriteFrameWithFileName(self, pszFileName)
    }
    #[inline]
    pub unsafe fn addSpriteFrameWithTexture(
        &mut self,
        pobTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) {
        cocos2d_CCAnimation_addSpriteFrameWithTexture(self, pobTexture, rect)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCAnimation_init(self)
    }
    #[inline]
    pub unsafe fn initWithSpriteFrames(
        &mut self,
        pFrames: *mut cocos2d_CCArray,
        delay: f32,
    ) -> bool {
        cocos2d_CCAnimation_initWithSpriteFrames(self, pFrames, delay)
    }
    #[inline]
    pub unsafe fn initWithAnimationFrames(
        &mut self,
        arrayOfAnimationFrames: *mut cocos2d_CCArray,
        delayPerUnit: f32,
        loops: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAnimation_initWithAnimationFrames(
            self,
            arrayOfAnimationFrames,
            delayPerUnit,
            loops,
        )
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimation_CCAnimation(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCAnimation@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAnimation_CCAnimation_destructor(this: *mut cocos2d_CCAnimation);
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimation@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimation_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " duration in seconds of the whole animation. It is the result of totalDelayUnits * delayPerUnit"]
    #[link_name = "\u{1}?getDuration@CCAnimation@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCAnimation_getDuration(this: *mut ::std::os::raw::c_void) -> f32;
}
#[doc = " @addtogroup transition\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionInterval {
    pub _base: cocos2d_CCFiniteTimeAction,
    pub m_elapsed: f32,
    pub m_bFirstTick: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionInterval() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCActionInterval> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionInterval>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionInterval))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionInterval>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionInterval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_elapsed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionInterval),
            "::",
            stringify!(m_elapsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFirstTick) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionInterval),
            "::",
            stringify!(m_bFirstTick)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCActionInterval@cocos2d@@QAE_NM@Z"]
    pub fn cocos2d_CCActionInterval_initWithDuration(
        this: *mut cocos2d_CCActionInterval,
        d: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCActionInterval@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCActionInterval_create(d: f32) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?setAmplitudeRate@CCActionInterval@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCActionInterval_setAmplitudeRate(this: *mut cocos2d_CCActionInterval, amp: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getAmplitudeRate@CCActionInterval@cocos2d@@QAEMXZ"]
    pub fn cocos2d_CCActionInterval_getAmplitudeRate(this: *mut cocos2d_CCActionInterval) -> f32;
}
impl cocos2d_CCActionInterval {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, d: f32) -> bool {
        cocos2d_CCActionInterval_initWithDuration(self, d)
    }
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCActionInterval {
        cocos2d_CCActionInterval_create(d)
    }
    #[inline]
    pub unsafe fn setAmplitudeRate(&mut self, amp: f32) {
        cocos2d_CCActionInterval_setAmplitudeRate(self, amp)
    }
    #[inline]
    pub unsafe fn getAmplitudeRate(&mut self) -> f32 {
        cocos2d_CCActionInterval_getAmplitudeRate(self)
    }
}
extern "thiscall" {
    #[doc = " returns true if the action has finished"]
    #[link_name = "\u{1}?isDone@CCActionInterval@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCActionInterval_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionInterval@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionInterval_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?step@CCActionInterval@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCActionInterval_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCActionInterval@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionInterval_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " returns a reversed action"]
    #[link_name = "\u{1}?reverse@CCActionInterval@cocos2d@@UAEPAV12@XZ"]
    pub fn cocos2d_CCActionInterval_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Runs actions sequentially, one after another"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSequence {
    pub _base: cocos2d_CCActionInterval,
    pub m_pActions: [*mut cocos2d_CCFiniteTimeAction; 2usize],
    pub m_split: f32,
    pub m_last: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSequence() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSequence> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSequence>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCSequence))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSequence>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pActions) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_pActions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_split) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_last) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSequence),
            "::",
            stringify!(m_last)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action\n @lua NA"]
    #[link_name = "\u{1}?initWithTwoActions@CCSequence@cocos2d@@QAE_NPAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSequence_initWithTwoActions(
        this: *mut cocos2d_CCSequence,
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequenceable actions\n @lua NA"]
    #[link_name = "\u{1}?create@CCSequence@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@ZZ"]
    pub fn cocos2d_CCSequence_create(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        ...
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequenceable actions given an array\n @js NA"]
    #[link_name = "\u{1}?create@CCSequence@cocos2d@@SAPAV12@PAVCCArray@2@@Z"]
    pub fn cocos2d_CCSequence_create1(
        arrayOfActions: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " helper constructor to create an array of sequence-able actions\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?createWithVariableList@CCSequence@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@PAD@Z"]
    pub fn cocos2d_CCSequence_createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSequence;
}
extern "C" {
    #[doc = " creates the action\n @js NA"]
    #[link_name = "\u{1}?createWithTwoActions@CCSequence@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSequence_createWithTwoActions(
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSequence;
}
impl cocos2d_CCSequence {
    #[inline]
    pub unsafe fn initWithTwoActions(
        &mut self,
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCSequence_initWithTwoActions(self, pActionOne, pActionTwo)
    }
    #[inline]
    pub unsafe fn create(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_create1(arrayOfActions)
    }
    #[inline]
    pub unsafe fn createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_createWithVariableList(pAction1, args)
    }
    #[inline]
    pub unsafe fn createWithTwoActions(
        pActionOne: *mut cocos2d_CCFiniteTimeAction,
        pActionTwo: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSequence {
        cocos2d_CCSequence_createWithTwoActions(pActionOne, pActionTwo)
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSequence@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSequence_CCSequence_destructor(this: *mut cocos2d_CCSequence);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSequence@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSequence_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCSequence@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSequence_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?stop@CCSequence@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSequence_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?update@CCSequence@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSequence_update(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCSequence@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSequence_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Repeats an action a number of times.\n To repeat an action forever use the CCRepeatForever action."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRepeat {
    pub _base: cocos2d_CCActionInterval,
    pub m_uTimes: ::std::os::raw::c_uint,
    pub m_uTotal: ::std::os::raw::c_uint,
    pub m_fNextDt: f32,
    pub m_bActionInstant: bool,
    #[doc = " Inner action"]
    pub m_pInnerAction: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRepeat() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRepeat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRepeat>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCRepeat))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRepeat>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRepeat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTimes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_uTimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTotal) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_uTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fNextDt) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_fNextDt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bActionInstant) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_bActionInstant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInnerAction) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeat),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)"]
    #[link_name = "\u{1}?initWithAction@CCRepeat@cocos2d@@QAE_NPAVCCFiniteTimeAction@2@I@Z"]
    pub fn cocos2d_CCRepeat_initWithAction(
        this: *mut cocos2d_CCRepeat,
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)"]
    #[link_name = "\u{1}?create@CCRepeat@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@I@Z"]
    pub fn cocos2d_CCRepeat_create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCRepeat;
}
impl cocos2d_CCRepeat {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCRepeat_initWithAction(self, pAction, times)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
        times: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCRepeat {
        cocos2d_CCRepeat_create(pAction, times)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCRepeat@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCRepeat_CCRepeat_destructor(this: *mut cocos2d_CCRepeat);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRepeat@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRepeat_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCRepeat@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCRepeat_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCRepeat@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCRepeat_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCRepeat@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRepeat_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isDone@CCRepeat@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCRepeat_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCRepeat@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRepeat_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Repeats an action for ever.\nTo repeat the an action for a limited number of times use the Repeat action.\n@warning This action can't be Sequenceable because it is not an IntervalAction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRepeatForever {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " Inner action"]
    pub m_pInnerAction: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRepeatForever() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRepeatForever> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRepeatForever>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCRepeatForever))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRepeatForever>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRepeatForever))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInnerAction) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRepeatForever),
            "::",
            stringify!(m_pInnerAction)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCRepeatForever@cocos2d@@QAE_NPAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCRepeatForever_initWithAction(
        this: *mut cocos2d_CCRepeatForever,
        pAction: *mut cocos2d_CCActionInterval,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRepeatForever@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCRepeatForever_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCRepeatForever;
}
impl cocos2d_CCRepeatForever {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCActionInterval) -> bool {
        cocos2d_CCRepeatForever_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCRepeatForever {
        cocos2d_CCRepeatForever_create(pAction)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCRepeatForever@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCRepeatForever_CCRepeatForever_destructor(this: *mut cocos2d_CCRepeatForever);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRepeatForever@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRepeatForever_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCRepeatForever@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCRepeatForever_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?step@CCRepeatForever@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRepeatForever_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isDone@CCRepeatForever@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCRepeatForever_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCRepeatForever@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRepeatForever_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Spawn a new action immediately"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpawn {
    pub _base: cocos2d_CCActionInterval,
    pub m_pOne: *mut cocos2d_CCFiniteTimeAction,
    pub m_pTwo: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpawn() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSpawn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpawn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpawn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpawn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpawn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOne) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpawn),
            "::",
            stringify!(m_pOne)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTwo) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpawn),
            "::",
            stringify!(m_pTwo)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the Spawn action with the 2 actions to spawn\n @lua NA"]
    #[link_name = "\u{1}?initWithTwoActions@CCSpawn@cocos2d@@QAE_NPAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSpawn_initWithTwoActions(
        this: *mut cocos2d_CCSpawn,
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions\n @lua NA"]
    #[link_name = "\u{1}?create@CCSpawn@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@ZZ"]
    pub fn cocos2d_CCSpawn_create(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        ...
    ) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions\n @js  NA\n @lua NA"]
    #[link_name = "\u{1}?createWithVariableList@CCSpawn@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@PAD@Z"]
    pub fn cocos2d_CCSpawn_createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " helper constructor to create an array of spawned actions given an array\n @js NA"]
    #[link_name = "\u{1}?create@CCSpawn@cocos2d@@SAPAV12@PAVCCArray@2@@Z"]
    pub fn cocos2d_CCSpawn_create1(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSpawn;
}
extern "C" {
    #[doc = " creates the Spawn action\n @js NA"]
    #[link_name = "\u{1}?createWithTwoActions@CCSpawn@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@0@Z"]
    pub fn cocos2d_CCSpawn_createWithTwoActions(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSpawn;
}
impl cocos2d_CCSpawn {
    #[inline]
    pub unsafe fn initWithTwoActions(
        &mut self,
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCSpawn_initWithTwoActions(self, pAction1, pAction2)
    }
    #[inline]
    pub unsafe fn createWithVariableList(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        args: va_list,
    ) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_createWithVariableList(pAction1, args)
    }
    #[inline]
    pub unsafe fn create(arrayOfActions: *mut cocos2d_CCArray) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_create1(arrayOfActions)
    }
    #[inline]
    pub unsafe fn createWithTwoActions(
        pAction1: *mut cocos2d_CCFiniteTimeAction,
        pAction2: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCSpawn {
        cocos2d_CCSpawn_createWithTwoActions(pAction1, pAction2)
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSpawn@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSpawn_CCSpawn_destructor(this: *mut cocos2d_CCSpawn);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSpawn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSpawn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCSpawn@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpawn_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?stop@CCSpawn@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSpawn_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?update@CCSpawn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSpawn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCSpawn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSpawn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Rotates a CCNode object to a certain angle by modifying it's\nrotation attribute.\nThe direction will be decided by the shortest angle."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRotateTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fDstAngleX: f32,
    pub m_fStartAngleX: f32,
    pub m_fDiffAngleX: f32,
    pub m_fDstAngleY: f32,
    pub m_fStartAngleY: f32,
    pub m_fDiffAngleY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRotateTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRotateTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRotateTo>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCRotateTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRotateTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRotateTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDstAngleX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDstAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartAngleX) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fStartAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDiffAngleX) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDiffAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDstAngleY) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDstAngleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartAngleY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fStartAngleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDiffAngleY) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateTo),
            "::",
            stringify!(m_fDiffAngleY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRotateTo@cocos2d@@SAPAV12@MM@Z"]
    pub fn cocos2d_CCRotateTo_create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateTo;
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCRotateTo@cocos2d@@QAE_NMM@Z"]
    pub fn cocos2d_CCRotateTo_initWithDuration(
        this: *mut cocos2d_CCRotateTo,
        fDuration: f32,
        fDeltaAngle: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with separate rotation angles"]
    #[link_name = "\u{1}?create@CCRotateTo@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCRotateTo_create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateTo;
}
impl cocos2d_CCRotateTo {
    #[inline]
    pub unsafe fn create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateTo {
        cocos2d_CCRotateTo_create(fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, fDuration: f32, fDeltaAngle: f32) -> bool {
        cocos2d_CCRotateTo_initWithDuration(self, fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateTo {
        cocos2d_CCRotateTo_create1(fDuration, fDeltaAngleX, fDeltaAngleY)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDuration@CCRotateTo@cocos2d@@UAE_NMMM@Z"]
    pub fn cocos2d_CCRotateTo_initWithDuration1(
        this: *mut ::std::os::raw::c_void,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRotateTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRotateTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCRotateTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCRotateTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCRotateTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRotateTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Rotates a CCNode object clockwise a number of degrees by modifying it's rotation attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRotateBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_fAngleX: f32,
    pub m_fStartAngleX: f32,
    pub m_fAngleY: f32,
    pub m_fStartAngleY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRotateBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRotateBy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRotateBy>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCRotateBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRotateBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRotateBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngleX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartAngleX) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fStartAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngleY) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fAngleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartAngleY) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRotateBy),
            "::",
            stringify!(m_fStartAngleY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCRotateBy@cocos2d@@SAPAV12@MM@Z"]
    pub fn cocos2d_CCRotateBy_create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateBy;
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCRotateBy@cocos2d@@QAE_NMM@Z"]
    pub fn cocos2d_CCRotateBy_initWithDuration(
        this: *mut cocos2d_CCRotateBy,
        fDuration: f32,
        fDeltaAngle: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?create@CCRotateBy@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCRotateBy_create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateBy;
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDuration@CCRotateBy@cocos2d@@QAE_NMMM@Z"]
    pub fn cocos2d_CCRotateBy_initWithDuration1(
        this: *mut cocos2d_CCRotateBy,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool;
}
impl cocos2d_CCRotateBy {
    #[inline]
    pub unsafe fn create(fDuration: f32, fDeltaAngle: f32) -> *mut cocos2d_CCRotateBy {
        cocos2d_CCRotateBy_create(fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, fDuration: f32, fDeltaAngle: f32) -> bool {
        cocos2d_CCRotateBy_initWithDuration(self, fDuration, fDeltaAngle)
    }
    #[inline]
    pub unsafe fn create1(
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> *mut cocos2d_CCRotateBy {
        cocos2d_CCRotateBy_create1(fDuration, fDeltaAngleX, fDeltaAngleY)
    }
    #[inline]
    pub unsafe fn initWithDuration1(
        &mut self,
        fDuration: f32,
        fDeltaAngleX: f32,
        fDeltaAngleY: f32,
    ) -> bool {
        cocos2d_CCRotateBy_initWithDuration1(self, fDuration, fDeltaAngleX, fDeltaAngleY)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRotateBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRotateBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCRotateBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCRotateBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCRotateBy@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRotateBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCRotateBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCRotateBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "  Moves a CCNode object x,y pixels by modifying it's position attribute.\nx and y are relative to the position of the object.\nSeveral CCMoveBy actions can be concurrently called, and the resulting\nmovement will be the sum of individual movements.\n@since v2.1beta2-custom"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMoveBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_positionDelta: cocos2d_CCPoint,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_previousPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMoveBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMoveBy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMoveBy>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCMoveBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMoveBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMoveBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_positionDelta) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_positionDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPosition) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_previousPosition) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveBy),
            "::",
            stringify!(m_previousPosition)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCMoveBy@cocos2d@@QAE_NMABVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveBy_initWithDuration(
        this: *mut cocos2d_CCMoveBy,
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCMoveBy@cocos2d@@SAPAV12@MABVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveBy_create(
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveBy;
}
impl cocos2d_CCMoveBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCMoveBy_initWithDuration(self, duration, deltaPosition)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        deltaPosition: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveBy {
        cocos2d_CCMoveBy_create(duration, deltaPosition)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCMoveBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCMoveBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCMoveBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMoveBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCMoveBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCMoveBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCMoveBy@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCMoveBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " Moves a CCNode object to the position x,y. x and y are absolute coordinates by modifying it's position attribute.\nSeveral CCMoveTo actions can be concurrently called, and the resulting\nmovement will be the sum of individual movements.\n@since v2.1beta2-custom"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMoveTo {
    pub _base: cocos2d_CCMoveBy,
    pub m_endPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMoveTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMoveTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMoveTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCMoveTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMoveTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMoveTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_endPosition) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMoveTo),
            "::",
            stringify!(m_endPosition)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCMoveTo@cocos2d@@QAE_NMABVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveTo_initWithDuration(
        this: *mut cocos2d_CCMoveTo,
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCMoveTo@cocos2d@@SAPAV12@MABVCCPoint@2@@Z"]
    pub fn cocos2d_CCMoveTo_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCMoveTo;
}
impl cocos2d_CCMoveTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        position: *const cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCMoveTo_initWithDuration(self, duration, position)
    }
    #[inline]
    pub unsafe fn create(duration: f32, position: *const cocos2d_CCPoint) -> *mut cocos2d_CCMoveTo {
        cocos2d_CCMoveTo_create(duration, position)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCMoveTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCMoveTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCMoveTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMoveTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " Skews a CCNode object to given angles by modifying it's skewX and skewY attributes\n@since v1.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSkewTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fSkewX: f32,
    pub m_fSkewY: f32,
    pub m_fStartSkewX: f32,
    pub m_fStartSkewY: f32,
    pub m_fEndSkewX: f32,
    pub m_fEndSkewY: f32,
    pub m_fDeltaX: f32,
    pub m_fDeltaY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSkewTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSkewTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSkewTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCSkewTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSkewTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSkewTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSkewX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fSkewX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSkewY) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fSkewY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSkewX) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fStartSkewX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSkewY) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fStartSkewY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSkewX) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fEndSkewX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSkewY) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fEndSkewY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaX) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fDeltaX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaY) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSkewTo),
            "::",
            stringify!(m_fDeltaY)
        )
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCSkewTo@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCSkewTo_create(t: f32, sx: f32, sy: f32) -> *mut cocos2d_CCSkewTo;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCSkewTo@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSkewTo_CCSkewTo(this: *mut cocos2d_CCSkewTo);
}
impl cocos2d_CCSkewTo {
    #[inline]
    pub unsafe fn create(t: f32, sx: f32, sy: f32) -> *mut cocos2d_CCSkewTo {
        cocos2d_CCSkewTo_create(t, sx, sy)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSkewTo_CCSkewTo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDuration@CCSkewTo@cocos2d@@UAE_NMMM@Z"]
    pub fn cocos2d_CCSkewTo_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSkewTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSkewTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCSkewTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSkewTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCSkewTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSkewTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " Skews a CCNode object by skewX and skewY degrees\n@since v1.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSkewBy {
    pub _base: cocos2d_CCSkewTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSkewBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSkewBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCSkewBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSkewBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSkewBy))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCSkewBy@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCSkewBy_create(
        t: f32,
        deltaSkewX: f32,
        deltaSkewY: f32,
    ) -> *mut cocos2d_CCSkewBy;
}
impl cocos2d_CCSkewBy {
    #[inline]
    pub unsafe fn create(t: f32, deltaSkewX: f32, deltaSkewY: f32) -> *mut cocos2d_CCSkewBy {
        cocos2d_CCSkewBy_create(t, deltaSkewX, deltaSkewY)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDuration@CCSkewBy@cocos2d@@UAE_NMMM@Z"]
    pub fn cocos2d_CCSkewBy_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCSkewBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSkewBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCSkewBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCSkewBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Moves a CCNode object simulating a parabolic jump movement by modifying it's position attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_delta: cocos2d_CCPoint,
    pub m_height: f32,
    pub m_nJumps: ::std::os::raw::c_uint,
    pub m_previousPos: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCJumpBy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPosition) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_delta) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_height) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nJumps) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_nJumps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_previousPos) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpBy),
            "::",
            stringify!(m_previousPos)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCJumpBy@cocos2d@@QAE_NMABVCCPoint@2@MI@Z"]
    pub fn cocos2d_CCJumpBy_initWithDuration(
        this: *mut cocos2d_CCJumpBy,
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCJumpBy@cocos2d@@SAPAV12@MABVCCPoint@2@MI@Z"]
    pub fn cocos2d_CCJumpBy_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCJumpBy;
}
impl cocos2d_CCJumpBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCJumpBy_initWithDuration(self, duration, position, height, jumps)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCJumpBy {
        cocos2d_CCJumpBy_create(duration, position, height, jumps)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCJumpBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCJumpBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCJumpBy@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCJumpBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCJumpBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCJumpBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Moves a CCNode object to a parabolic position simulating a jump movement by modifying it's position attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpTo {
    pub _base: cocos2d_CCJumpBy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpTo))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCJumpTo@cocos2d@@SAPAV12@MABVCCPoint@2@MH@Z"]
    pub fn cocos2d_CCJumpTo_create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCJumpTo;
}
impl cocos2d_CCJumpTo {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        position: *const cocos2d_CCPoint,
        height: f32,
        jumps: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCJumpTo {
        cocos2d_CCJumpTo_create(duration, position, height, jumps)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCJumpTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCJumpTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @typedef bezier configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccBezierConfig {
    #[doc = "! end position of the bezier"]
    pub endPosition: cocos2d_CCPoint,
    #[doc = "! Bezier control point 1"]
    pub controlPoint_1: cocos2d_CCPoint,
    #[doc = "! Bezier control point 2"]
    pub controlPoint_2: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d__ccBezierConfig() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccBezierConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccBezierConfig>(),
        24usize,
        concat!("Size of: ", stringify!(cocos2d__ccBezierConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccBezierConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__ccBezierConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(endPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controlPoint_1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(controlPoint_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controlPoint_2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccBezierConfig),
            "::",
            stringify!(controlPoint_2)
        )
    );
}
#[doc = " @typedef bezier configuration structure"]
pub type cocos2d_ccBezierConfig = cocos2d__ccBezierConfig;
#[doc = " @brief An action that moves the target with a cubic Bezier curve by a certain distance."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBezierBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_sConfig: cocos2d_ccBezierConfig,
    pub m_startPosition: cocos2d_CCPoint,
    pub m_previousPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBezierBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCBezierBy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBezierBy>(),
        120usize,
        concat!("Size of: ", stringify!(cocos2d_CCBezierBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBezierBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBezierBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sConfig) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_sConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPosition) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_startPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_previousPosition) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierBy),
            "::",
            stringify!(m_previousPosition)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with a duration and a bezier configuration\n  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCBezierBy@cocos2d@@QAE_NMABU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierBy_initWithDuration(
        this: *mut cocos2d_CCBezierBy,
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a duration and a bezier configuration\n  @code\n  when this function bound to js,the input params are changed\n  js: var create(var t, var pointTable)\n  @endcode"]
    #[link_name = "\u{1}?create@CCBezierBy@cocos2d@@SAPAV12@MABU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierBy_create(
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> *mut cocos2d_CCBezierBy;
}
impl cocos2d_CCBezierBy {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, t: f32, c: *const cocos2d_ccBezierConfig) -> bool {
        cocos2d_CCBezierBy_initWithDuration(self, t, c)
    }
    #[inline]
    pub unsafe fn create(t: f32, c: *const cocos2d_ccBezierConfig) -> *mut cocos2d_CCBezierBy {
        cocos2d_CCBezierBy_create(t, c)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBezierBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCBezierBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCBezierBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCBezierBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCBezierBy@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCBezierBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCBezierBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCBezierBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief An action that moves the target with a cubic Bezier curve to a destination point.\n@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBezierTo {
    pub _base: cocos2d_CCBezierBy,
    pub m_sToConfig: cocos2d_ccBezierConfig,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBezierTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCBezierTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBezierTo>(),
        144usize,
        concat!("Size of: ", stringify!(cocos2d_CCBezierTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBezierTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBezierTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sToConfig) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBezierTo),
            "::",
            stringify!(m_sToConfig)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a duration and a bezier configuration\n  @code\n  when this function bound to js,the input params are changed\n  js: var create(var t, var pointTable)\n  @endcode"]
    #[link_name = "\u{1}?create@CCBezierTo@cocos2d@@SAPAV12@MABU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierTo_create(
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> *mut cocos2d_CCBezierTo;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCBezierTo@cocos2d@@QAE_NMABU_ccBezierConfig@2@@Z"]
    pub fn cocos2d_CCBezierTo_initWithDuration(
        this: *mut cocos2d_CCBezierTo,
        t: f32,
        c: *const cocos2d_ccBezierConfig,
    ) -> bool;
}
impl cocos2d_CCBezierTo {
    #[inline]
    pub unsafe fn create(t: f32, c: *const cocos2d_ccBezierConfig) -> *mut cocos2d_CCBezierTo {
        cocos2d_CCBezierTo_create(t, c)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, t: f32, c: *const cocos2d_ccBezierConfig) -> bool {
        cocos2d_CCBezierTo_initWithDuration(self, t, c)
    }
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCBezierTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCBezierTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBezierTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCBezierTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Scales a CCNode object to a zoom factor by modifying it's scale attribute.\n@warning This action doesn't support \"reverse\""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScaleTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fScaleX: f32,
    pub m_fScaleY: f32,
    pub m_fStartScaleX: f32,
    pub m_fStartScaleY: f32,
    pub m_fEndScaleX: f32,
    pub m_fEndScaleY: f32,
    pub m_fDeltaX: f32,
    pub m_fDeltaY: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScaleTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCScaleTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScaleTo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCScaleTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScaleTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScaleTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleX) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleY) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartScaleX) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fStartScaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartScaleY) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fStartScaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndScaleX) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fEndScaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndScaleY) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fEndScaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaX) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fDeltaX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaY) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScaleTo),
            "::",
            stringify!(m_fDeltaY)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?initWithDuration@CCScaleTo@cocos2d@@QAE_NMM@Z"]
    pub fn cocos2d_CCScaleTo_initWithDuration(
        this: *mut cocos2d_CCScaleTo,
        duration: f32,
        s: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?initWithDuration@CCScaleTo@cocos2d@@QAE_NMMM@Z"]
    pub fn cocos2d_CCScaleTo_initWithDuration1(
        this: *mut cocos2d_CCScaleTo,
        duration: f32,
        sx: f32,
        sy: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?create@CCScaleTo@cocos2d@@SAPAV12@MM@Z"]
    pub fn cocos2d_CCScaleTo_create(duration: f32, s: f32) -> *mut cocos2d_CCScaleTo;
}
extern "C" {
    #[doc = " creates the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?create@CCScaleTo@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCScaleTo_create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleTo;
}
impl cocos2d_CCScaleTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, s: f32) -> bool {
        cocos2d_CCScaleTo_initWithDuration(self, duration, s)
    }
    #[inline]
    pub unsafe fn initWithDuration1(&mut self, duration: f32, sx: f32, sy: f32) -> bool {
        cocos2d_CCScaleTo_initWithDuration1(self, duration, sx, sy)
    }
    #[inline]
    pub unsafe fn create(duration: f32, s: f32) -> *mut cocos2d_CCScaleTo {
        cocos2d_CCScaleTo_create(duration, s)
    }
    #[inline]
    pub unsafe fn create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleTo {
        cocos2d_CCScaleTo_create1(duration, sx, sy)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCScaleTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCScaleTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCScaleTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCScaleTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCScaleTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCScaleTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Scales a CCNode object a zoom factor by modifying it's scale attribute."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScaleBy {
    pub _base: cocos2d_CCScaleTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScaleBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScaleBy>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCScaleBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScaleBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScaleBy))
    );
}
extern "C" {
    #[doc = " creates the action with the same scale factor for X and Y"]
    #[link_name = "\u{1}?create@CCScaleBy@cocos2d@@SAPAV12@MM@Z"]
    pub fn cocos2d_CCScaleBy_create(duration: f32, s: f32) -> *mut cocos2d_CCScaleBy;
}
extern "C" {
    #[doc = " creates the action with and X factor and a Y factor"]
    #[link_name = "\u{1}?create@CCScaleBy@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCScaleBy_create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleBy;
}
impl cocos2d_CCScaleBy {
    #[inline]
    pub unsafe fn create(duration: f32, s: f32) -> *mut cocos2d_CCScaleBy {
        cocos2d_CCScaleBy_create(duration, s)
    }
    #[inline]
    pub unsafe fn create1(duration: f32, sx: f32, sy: f32) -> *mut cocos2d_CCScaleBy {
        cocos2d_CCScaleBy_create1(duration, sx, sy)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCScaleBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCScaleBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCScaleBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCScaleBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCScaleBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCScaleBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Blinks a CCNode object by modifying it's visible attribute"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBlink {
    pub _base: cocos2d_CCActionInterval,
    pub m_nTimes: ::std::os::raw::c_uint,
    pub m_bOriginalState: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBlink() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCBlink> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBlink>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCBlink))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBlink>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBlink))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTimes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBlink),
            "::",
            stringify!(m_nTimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOriginalState) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBlink),
            "::",
            stringify!(m_bOriginalState)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithDuration@CCBlink@cocos2d@@QAE_NMI@Z"]
    pub fn cocos2d_CCBlink_initWithDuration(
        this: *mut cocos2d_CCBlink,
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCBlink@cocos2d@@SAPAV12@MI@Z"]
    pub fn cocos2d_CCBlink_create(
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCBlink;
}
impl cocos2d_CCBlink {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        uBlinks: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCBlink_initWithDuration(self, duration, uBlinks)
    }
    #[inline]
    pub unsafe fn create(duration: f32, uBlinks: ::std::os::raw::c_uint) -> *mut cocos2d_CCBlink {
        cocos2d_CCBlink_create(duration, uBlinks)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCBlink@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCBlink_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCBlink@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCBlink_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCBlink@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCBlink_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCBlink@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCBlink_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCBlink@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCBlink_stop(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Fades In an object that implements the CCRGBAProtocol protocol. It modifies the opacity from 0 to 255.\nThe \"reverse\" of this action is FadeOut"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeIn {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeIn>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCFadeIn@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCFadeIn_create(d: f32) -> *mut cocos2d_CCFadeIn;
}
impl cocos2d_CCFadeIn {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCFadeIn {
        cocos2d_CCFadeIn_create(d)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFadeIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFadeIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCFadeIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCFadeIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Fades Out an object that implements the CCRGBAProtocol protocol. It modifies the opacity from 255 to 0.\nThe \"reverse\" of this action is FadeIn"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOut {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOut>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCFadeOut@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCFadeOut_create(d: f32) -> *mut cocos2d_CCFadeOut;
}
impl cocos2d_CCFadeOut {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCFadeOut {
        cocos2d_CCFadeOut_create(d)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFadeOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFadeOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCFadeOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCFadeOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Fades an object that implements the CCRGBAProtocol protocol. It modifies the opacity from the current value to a custom one.\n@warning This action doesn't support \"reverse\""]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_toOpacity: GLubyte,
    pub m_fromOpacity: GLubyte,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFadeTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeTo>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_toOpacity) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFadeTo),
            "::",
            stringify!(m_toOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fromOpacity) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFadeTo),
            "::",
            stringify!(m_fromOpacity)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with duration and opacity"]
    #[link_name = "\u{1}?initWithDuration@CCFadeTo@cocos2d@@QAE_NME@Z"]
    pub fn cocos2d_CCFadeTo_initWithDuration(
        this: *mut cocos2d_CCFadeTo,
        duration: f32,
        opacity: GLubyte,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and opacity"]
    #[link_name = "\u{1}?create@CCFadeTo@cocos2d@@SAPAV12@ME@Z"]
    pub fn cocos2d_CCFadeTo_create(duration: f32, opacity: GLubyte) -> *mut cocos2d_CCFadeTo;
}
impl cocos2d_CCFadeTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, opacity: GLubyte) -> bool {
        cocos2d_CCFadeTo_initWithDuration(self, duration, opacity)
    }
    #[inline]
    pub unsafe fn create(duration: f32, opacity: GLubyte) -> *mut cocos2d_CCFadeTo {
        cocos2d_CCFadeTo_create(duration, opacity)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFadeTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFadeTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCFadeTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCFadeTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFadeTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFadeTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Tints a CCNode that implements the CCNodeRGB protocol from current tint to a custom one.\n@warning This action doesn't support \"reverse\"\n@since v0.7.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTintTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_to: cocos2d_ccColor3B,
    pub m_from: cocos2d_ccColor3B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTintTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTintTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTintTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTintTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTintTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTintTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_to) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintTo),
            "::",
            stringify!(m_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_from) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintTo),
            "::",
            stringify!(m_from)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with duration and color"]
    #[link_name = "\u{1}?initWithDuration@CCTintTo@cocos2d@@QAE_NMEEE@Z"]
    pub fn cocos2d_CCTintTo_initWithDuration(
        this: *mut cocos2d_CCTintTo,
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and color"]
    #[link_name = "\u{1}?create@CCTintTo@cocos2d@@SAPAV12@MEEE@Z"]
    pub fn cocos2d_CCTintTo_create(
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> *mut cocos2d_CCTintTo;
}
impl cocos2d_CCTintTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> bool {
        cocos2d_CCTintTo_initWithDuration(self, duration, red, green, blue)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        red: GLubyte,
        green: GLubyte,
        blue: GLubyte,
    ) -> *mut cocos2d_CCTintTo {
        cocos2d_CCTintTo_create(duration, red, green, blue)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTintTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCTintTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCTintTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCTintTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCTintTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTintTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief Tints a CCNode that implements the CCNodeRGB protocol from current tint to a custom one.\n@since v0.7.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTintBy {
    pub _base: cocos2d_CCActionInterval,
    pub m_deltaR: GLshort,
    pub m_deltaG: GLshort,
    pub m_deltaB: GLshort,
    pub m_fromR: GLshort,
    pub m_fromG: GLshort,
    pub m_fromB: GLshort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTintBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTintBy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTintBy>(),
        92usize,
        concat!("Size of: ", stringify!(cocos2d_CCTintBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTintBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTintBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deltaR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deltaG) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deltaB) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_deltaB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fromR) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fromG) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fromB) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTintBy),
            "::",
            stringify!(m_fromB)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with duration and color"]
    #[link_name = "\u{1}?initWithDuration@CCTintBy@cocos2d@@QAE_NMFFF@Z"]
    pub fn cocos2d_CCTintBy_initWithDuration(
        this: *mut cocos2d_CCTintBy,
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration and color"]
    #[link_name = "\u{1}?create@CCTintBy@cocos2d@@SAPAV12@MFFF@Z"]
    pub fn cocos2d_CCTintBy_create(
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> *mut cocos2d_CCTintBy;
}
impl cocos2d_CCTintBy {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> bool {
        cocos2d_CCTintBy_initWithDuration(self, duration, deltaRed, deltaGreen, deltaBlue)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        deltaRed: GLshort,
        deltaGreen: GLshort,
        deltaBlue: GLshort,
    ) -> *mut cocos2d_CCTintBy {
        cocos2d_CCTintBy_create(duration, deltaRed, deltaGreen, deltaBlue)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTintBy@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCTintBy_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCTintBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCTintBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCTintBy@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTintBy_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCTintBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTintBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Delays the action a certain amount of seconds"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDelayTime {
    pub _base: cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDelayTime() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDelayTime>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCDelayTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDelayTime>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDelayTime))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCDelayTime@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCDelayTime_create(d: f32) -> *mut cocos2d_CCDelayTime;
}
impl cocos2d_CCDelayTime {
    #[inline]
    pub unsafe fn create(d: f32) -> *mut cocos2d_CCDelayTime {
        cocos2d_CCDelayTime_create(d)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCDelayTime@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCDelayTime_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCDelayTime@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCDelayTime_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCDelayTime@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCDelayTime_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Executes an action in reverse order, from time=duration to time=0\n\n@warning Use this action carefully. This action is not\nsequenceable. Use it as the default \"reversed\" method\nof your own actions, but using it outside the \"reversed\"\nscope is not recommended."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCReverseTime {
    pub _base: cocos2d_CCActionInterval,
    pub m_pOther: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCReverseTime() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCReverseTime> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCReverseTime>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCReverseTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCReverseTime>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCReverseTime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOther) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCReverseTime),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCReverseTime@cocos2d@@QAE_NPAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCReverseTime_initWithAction(
        this: *mut cocos2d_CCReverseTime,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCReverseTime@cocos2d@@SAPAV12@PAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCReverseTime_create(
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCReverseTime;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??0CCReverseTime@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCReverseTime_CCReverseTime(this: *mut cocos2d_CCReverseTime);
}
impl cocos2d_CCReverseTime {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCFiniteTimeAction) -> bool {
        cocos2d_CCReverseTime_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCFiniteTimeAction) -> *mut cocos2d_CCReverseTime {
        cocos2d_CCReverseTime_create(pAction)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCReverseTime_CCReverseTime(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??1CCReverseTime@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCReverseTime_CCReverseTime_destructor(this: *mut cocos2d_CCReverseTime);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCReverseTime@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCReverseTime_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCReverseTime@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCReverseTime_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCReverseTime@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCReverseTime_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCReverseTime@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCReverseTime_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCReverseTime@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCReverseTime_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief Animates a sprite given the name of an Animation"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimate {
    pub _base: cocos2d_CCActionInterval,
    pub m_pAnimation: *mut cocos2d_CCAnimation,
    pub m_pSplitTimes: *mut u8,
    pub m_nNextFrame: ::std::os::raw::c_int,
    pub m_pOrigFrame: *mut cocos2d_CCSpriteFrame,
    pub m_uExecutedLoops: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimate() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAnimate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimate>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAnimation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pAnimation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSplitTimes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pSplitTimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nNextFrame) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_nNextFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOrigFrame) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_pOrigFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uExecutedLoops) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimate),
            "::",
            stringify!(m_uExecutedLoops)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with an Animation and will restore the original frame when the animation is over"]
    #[link_name = "\u{1}?initWithAnimation@CCAnimate@cocos2d@@QAE_NPAVCCAnimation@2@@Z"]
    pub fn cocos2d_CCAnimate_initWithAnimation(
        this: *mut cocos2d_CCAnimate,
        pAnimation: *mut cocos2d_CCAnimation,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an Animation and will restore the original frame when the animation is over"]
    #[link_name = "\u{1}?create@CCAnimate@cocos2d@@SAPAV12@PAVCCAnimation@2@@Z"]
    pub fn cocos2d_CCAnimate_create(pAnimation: *mut cocos2d_CCAnimation)
        -> *mut cocos2d_CCAnimate;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCAnimate@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAnimate_CCAnimate(this: *mut cocos2d_CCAnimate);
}
impl cocos2d_CCAnimate {
    #[inline]
    pub unsafe fn initWithAnimation(&mut self, pAnimation: *mut cocos2d_CCAnimation) -> bool {
        cocos2d_CCAnimate_initWithAnimation(self, pAnimation)
    }
    #[inline]
    pub unsafe fn create(pAnimation: *mut cocos2d_CCAnimation) -> *mut cocos2d_CCAnimate {
        cocos2d_CCAnimate_create(pAnimation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimate_CCAnimate(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCAnimate@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAnimate_CCAnimate_destructor(this: *mut cocos2d_CCAnimate);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCAnimate@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCAnimate_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCAnimate@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCAnimate_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCAnimate@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCAnimate_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCAnimate@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCAnimate_update(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCAnimate@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAnimate_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " Overrides the target of an action so that it always runs on the target\n specified at action creation rather than the one specified by runAction."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedAction {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " This is the target that the action will be forced to run with"]
    pub m_pForcedTarget: *mut cocos2d_CCNode,
    pub m_pAction: *mut cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedAction() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTargetedAction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedAction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pForcedTarget) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedAction),
            "::",
            stringify!(m_pForcedTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAction) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedAction),
            "::",
            stringify!(m_pAction)
        )
    );
}
extern "C" {
    #[doc = " Create an action with the specified action and forced target"]
    #[link_name = "\u{1}?create@CCTargetedAction@cocos2d@@SAPAV12@PAVCCNode@2@PAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCTargetedAction_create(
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCTargetedAction;
}
extern "thiscall" {
    #[doc = " Init an action with the specified action and forced target"]
    #[link_name = "\u{1}?initWithTarget@CCTargetedAction@cocos2d@@QAE_NPAVCCNode@2@PAVCCFiniteTimeAction@2@@Z"]
    pub fn cocos2d_CCTargetedAction_initWithTarget(
        this: *mut cocos2d_CCTargetedAction,
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTargetedAction@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTargetedAction_CCTargetedAction(this: *mut cocos2d_CCTargetedAction);
}
impl cocos2d_CCTargetedAction {
    #[inline]
    pub unsafe fn create(
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> *mut cocos2d_CCTargetedAction {
        cocos2d_CCTargetedAction_create(pTarget, pAction)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pTarget: *mut cocos2d_CCNode,
        pAction: *mut cocos2d_CCFiniteTimeAction,
    ) -> bool {
        cocos2d_CCTargetedAction_initWithTarget(self, pTarget, pAction)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTargetedAction_CCTargetedAction(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTargetedAction@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTargetedAction_CCTargetedAction_destructor(
        this: *mut cocos2d_CCTargetedAction,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTargetedAction@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCTargetedAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCTargetedAction@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCTargetedAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCTargetedAction@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTargetedAction_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCTargetedAction@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTargetedAction_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Base class for CCCamera actions\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionCamera {
    pub _base: cocos2d_CCActionInterval,
    pub m_fCenterXOrig: f32,
    pub m_fCenterYOrig: f32,
    pub m_fCenterZOrig: f32,
    pub m_fEyeXOrig: f32,
    pub m_fEyeYOrig: f32,
    pub m_fEyeZOrig: f32,
    pub m_fUpXOrig: f32,
    pub m_fUpYOrig: f32,
    pub m_fUpZOrig: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionCamera() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCActionCamera> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionCamera>(),
        116usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionCamera>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionCamera))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterXOrig) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterXOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterYOrig) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterYOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterZOrig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fCenterZOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeXOrig) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeXOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeYOrig) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeYOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeZOrig) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fEyeZOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpXOrig) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpXOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpYOrig) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpYOrig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpZOrig) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionCamera),
            "::",
            stringify!(m_fUpZOrig)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCActionCamera@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionCamera_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCActionCamera@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionCamera_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCOrbitCamera action\nOrbits the camera around the center of the screen using spherical coordinates\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCOrbitCamera {
    pub _base: cocos2d_CCActionCamera,
    pub m_fRadius: f32,
    pub m_fDeltaRadius: f32,
    pub m_fAngleZ: f32,
    pub m_fDeltaAngleZ: f32,
    pub m_fAngleX: f32,
    pub m_fDeltaAngleX: f32,
    pub m_fRadZ: f32,
    pub m_fRadDeltaZ: f32,
    pub m_fRadX: f32,
    pub m_fRadDeltaX: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCOrbitCamera() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCOrbitCamera> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCOrbitCamera>(),
        156usize,
        concat!("Size of: ", stringify!(cocos2d_CCOrbitCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCOrbitCamera>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCOrbitCamera))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadius) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaRadius) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngleZ) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fAngleZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaAngleZ) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaAngleZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngleX) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaAngleX) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fDeltaAngleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadZ) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadDeltaZ) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadDeltaZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadX) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadDeltaX) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCOrbitCamera),
            "::",
            stringify!(m_fRadDeltaX)
        )
    );
}
extern "C" {
    #[doc = " creates a CCOrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX"]
    #[link_name = "\u{1}?create@CCOrbitCamera@cocos2d@@SAPAV12@MMMMMMM@Z"]
    pub fn cocos2d_CCOrbitCamera_create(
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> *mut cocos2d_CCOrbitCamera;
}
extern "thiscall" {
    #[doc = " initializes a CCOrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX"]
    #[link_name = "\u{1}?initWithDuration@CCOrbitCamera@cocos2d@@QAE_NMMMMMMM@Z"]
    pub fn cocos2d_CCOrbitCamera_initWithDuration(
        this: *mut cocos2d_CCOrbitCamera,
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " positions the camera according to spherical coordinates"]
    #[link_name = "\u{1}?sphericalRadius@CCOrbitCamera@cocos2d@@QAEXPAM00@Z"]
    pub fn cocos2d_CCOrbitCamera_sphericalRadius(
        this: *mut cocos2d_CCOrbitCamera,
        r: *mut f32,
        zenith: *mut f32,
        azimuth: *mut f32,
    );
}
impl cocos2d_CCOrbitCamera {
    #[inline]
    pub unsafe fn create(
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> *mut cocos2d_CCOrbitCamera {
        cocos2d_CCOrbitCamera_create(
            t,
            radius,
            deltaRadius,
            angleZ,
            deltaAngleZ,
            angleX,
            deltaAngleX,
        )
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        t: f32,
        radius: f32,
        deltaRadius: f32,
        angleZ: f32,
        deltaAngleZ: f32,
        angleX: f32,
        deltaAngleX: f32,
    ) -> bool {
        cocos2d_CCOrbitCamera_initWithDuration(
            self,
            t,
            radius,
            deltaRadius,
            angleZ,
            deltaAngleZ,
            angleX,
            deltaAngleX,
        )
    }
    #[inline]
    pub unsafe fn sphericalRadius(&mut self, r: *mut f32, zenith: *mut f32, azimuth: *mut f32) {
        cocos2d_CCOrbitCamera_sphericalRadius(self, r, zenith, azimuth)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCOrbitCamera@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCOrbitCamera_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCOrbitCamera@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCOrbitCamera_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCOrbitCamera@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCOrbitCamera_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashElement {
    _unused: [u8; 0],
}
#[doc = "@brief CCActionManager is a singleton that manages all the actions.\nNormally you won't need to use this singleton directly. 99% of the cases you will use the CCNode interface,\nwhich uses this singleton.\nBut there are some cases where you might need to use this singleton.\nExamples:\n- When you want to run an action where the target is different from a CCNode.\n- When you want to pause / resume the actions\n\n@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionManager {
    pub _base: cocos2d_CCObject,
    pub m_pTargets: *mut cocos2d__hashElement,
    pub m_pCurrentTarget: *mut cocos2d__hashElement,
    pub m_bCurrentTargetSalvaged: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionManager() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCActionManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionManager>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionManager>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTargets) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_pTargets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCurrentTarget) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_pCurrentTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCurrentTargetSalvaged) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionManager),
            "::",
            stringify!(m_bCurrentTargetSalvaged)
        )
    );
}
extern "thiscall" {
    #[doc = " Adds an action with a target.\nIf the target is already present, then the action will be added to the existing target.\nIf the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.\nWhen the target is paused, the queued actions won't be 'ticked'."]
    #[link_name = "\u{1}?addAction@CCActionManager@cocos2d@@QAEXPAVCCAction@2@PAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCActionManager_addAction(
        this: *mut cocos2d_CCActionManager,
        pAction: *mut cocos2d_CCAction,
        pTarget: *mut cocos2d_CCNode,
        paused: bool,
    );
}
extern "thiscall" {
    #[doc = " Removes all actions from all the targets."]
    #[link_name = "\u{1}?removeAllActions@CCActionManager@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCActionManager_removeAllActions(this: *mut cocos2d_CCActionManager);
}
extern "thiscall" {
    #[doc = " Removes all actions from a certain target.\nAll the actions that belongs to the target will be removed."]
    #[link_name = "\u{1}?removeAllActionsFromTarget@CCActionManager@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_removeAllActionsFromTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Removes an action given an action reference."]
    #[link_name = "\u{1}?removeAction@CCActionManager@cocos2d@@QAEXPAVCCAction@2@@Z"]
    pub fn cocos2d_CCActionManager_removeAction(
        this: *mut cocos2d_CCActionManager,
        pAction: *mut cocos2d_CCAction,
    );
}
extern "thiscall" {
    #[doc = " Removes an action given its tag and the target"]
    #[link_name = "\u{1}?removeActionByTag@CCActionManager@cocos2d@@QAEXIPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_removeActionByTag(
        this: *mut cocos2d_CCActionManager,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Gets an action given its tag an a target\n@return the Action the with the given tag"]
    #[link_name = "\u{1}?getActionByTag@CCActionManager@cocos2d@@QAEPAVCCAction@2@IPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_getActionByTag(
        this: *mut cocos2d_CCActionManager,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCAction;
}
extern "thiscall" {
    #[doc = " Returns the numbers of actions that are running in a certain target.\n Composable actions are counted as 1 action. Example:\n - If you are running 1 Sequence of 7 actions, it will return 1.\n - If you are running 7 Sequences of 2 actions, it will return 7."]
    #[link_name = "\u{1}?numberOfRunningActionsInTarget@CCActionManager@cocos2d@@QAEIPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_numberOfRunningActionsInTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Pauses the target: all running actions and newly added actions will be paused."]
    #[link_name = "\u{1}?pauseTarget@CCActionManager@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_pauseTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Resumes the target. All queued actions will be resumed."]
    #[link_name = "\u{1}?resumeTarget@CCActionManager@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCActionManager_resumeTarget(
        this: *mut cocos2d_CCActionManager,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Pauses all running actions, returning a list of targets whose actions were paused."]
    #[link_name = "\u{1}?pauseAllRunningActions@CCActionManager@cocos2d@@QAEPAVCCSet@2@XZ"]
    pub fn cocos2d_CCActionManager_pauseAllRunningActions(
        this: *mut cocos2d_CCActionManager,
    ) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = " Resume a set of targets (convenience function to reverse a pauseAllRunningActions call)"]
    #[link_name = "\u{1}?resumeTargets@CCActionManager@cocos2d@@QAEXPAVCCSet@2@@Z"]
    pub fn cocos2d_CCActionManager_resumeTargets(
        this: *mut cocos2d_CCActionManager,
        targetsToResume: *mut cocos2d_CCSet,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeActionAtIndex@CCActionManager@cocos2d@@IAEXIPAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_removeActionAtIndex(
        this: *mut cocos2d_CCActionManager,
        uIndex: ::std::os::raw::c_uint,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?deleteHashElement@CCActionManager@cocos2d@@IAEXPAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_deleteHashElement(
        this: *mut cocos2d_CCActionManager,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?actionAllocWithHashElement@CCActionManager@cocos2d@@IAEXPAU_hashElement@2@@Z"]
    pub fn cocos2d_CCActionManager_actionAllocWithHashElement(
        this: *mut cocos2d_CCActionManager,
        pElement: *mut cocos2d__hashElement,
    );
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCActionManager@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCActionManager_CCActionManager(this: *mut cocos2d_CCActionManager);
}
impl cocos2d_CCActionManager {
    #[inline]
    pub unsafe fn addAction(
        &mut self,
        pAction: *mut cocos2d_CCAction,
        pTarget: *mut cocos2d_CCNode,
        paused: bool,
    ) {
        cocos2d_CCActionManager_addAction(self, pAction, pTarget, paused)
    }
    #[inline]
    pub unsafe fn removeAllActions(&mut self) {
        cocos2d_CCActionManager_removeAllActions(self)
    }
    #[inline]
    pub unsafe fn removeAllActionsFromTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_removeAllActionsFromTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn removeAction(&mut self, pAction: *mut cocos2d_CCAction) {
        cocos2d_CCActionManager_removeAction(self, pAction)
    }
    #[inline]
    pub unsafe fn removeActionByTag(
        &mut self,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCActionManager_removeActionByTag(self, tag, pTarget)
    }
    #[inline]
    pub unsafe fn getActionByTag(
        &mut self,
        tag: ::std::os::raw::c_uint,
        pTarget: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCAction {
        cocos2d_CCActionManager_getActionByTag(self, tag, pTarget)
    }
    #[inline]
    pub unsafe fn numberOfRunningActionsInTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCActionManager_numberOfRunningActionsInTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_pauseTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn resumeTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCActionManager_resumeTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseAllRunningActions(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCActionManager_pauseAllRunningActions(self)
    }
    #[inline]
    pub unsafe fn resumeTargets(&mut self, targetsToResume: *mut cocos2d_CCSet) {
        cocos2d_CCActionManager_resumeTargets(self, targetsToResume)
    }
    #[inline]
    pub unsafe fn removeActionAtIndex(
        &mut self,
        uIndex: ::std::os::raw::c_uint,
        pElement: *mut cocos2d__hashElement,
    ) {
        cocos2d_CCActionManager_removeActionAtIndex(self, uIndex, pElement)
    }
    #[inline]
    pub unsafe fn deleteHashElement(&mut self, pElement: *mut cocos2d__hashElement) {
        cocos2d_CCActionManager_deleteHashElement(self, pElement)
    }
    #[inline]
    pub unsafe fn actionAllocWithHashElement(&mut self, pElement: *mut cocos2d__hashElement) {
        cocos2d_CCActionManager_actionAllocWithHashElement(self, pElement)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCActionManager_CCActionManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCActionManager@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCActionManager_CCActionManager_destructor(this: *mut cocos2d_CCActionManager);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCActionManager@cocos2d@@MAEXM@Z"]
    pub fn cocos2d_CCActionManager_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[doc = "@brief Base class for Easing actions\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionEase {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " The inner action"]
    pub m_pInner: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionEase() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCActionEase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionEase>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionEase))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionEase>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionEase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInner) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionEase),
            "::",
            stringify!(m_pInner)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action"]
    #[link_name = "\u{1}?initWithAction@CCActionEase@cocos2d@@QAE_NPAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCActionEase_initWithAction(
        this: *mut cocos2d_CCActionEase,
        pAction: *mut cocos2d_CCActionInterval,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCActionEase@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCActionEase_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionEase;
}
impl cocos2d_CCActionEase {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCActionInterval) -> bool {
        cocos2d_CCActionEase_initWithAction(self, pAction)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCActionEase {
        cocos2d_CCActionEase_create(pAction)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCActionEase@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCActionEase_CCActionEase_destructor(this: *mut cocos2d_CCActionEase);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionEase@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionEase_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCActionEase@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionEase_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?stop@CCActionEase@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCActionEase_stop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCActionEase@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCActionEase_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCActionEase@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionEase_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?getInnerAction@CCActionEase@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionEase_getInnerAction(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Base class for Easing actions with rate parameters\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseRateAction {
    pub _base: cocos2d_CCActionEase,
    pub m_fRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseRateAction() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCEaseRateAction> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseRateAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseRateAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseRateAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseRateAction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRate) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEaseRateAction),
            "::",
            stringify!(m_fRate)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?initWithAction@CCEaseRateAction@cocos2d@@QAE_NPAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseRateAction_initWithAction(
        this: *mut cocos2d_CCEaseRateAction,
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseRateAction@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseRateAction_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseRateAction;
}
impl cocos2d_CCEaseRateAction {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> bool {
        cocos2d_CCEaseRateAction_initWithAction(self, pAction, fRate)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseRateAction {
        cocos2d_CCEaseRateAction_create(pAction, fRate)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCEaseRateAction@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCEaseRateAction_CCEaseRateAction_destructor(
        this: *mut cocos2d_CCEaseRateAction,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseRateAction@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseRateAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseRateAction@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseRateAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseIn action with a rate\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseIn {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseIn))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseIn_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseIn;
}
impl cocos2d_CCEaseIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseIn {
        cocos2d_CCEaseIn_create(pAction, fRate)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseOut action with a rate\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseOut {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseOut;
}
impl cocos2d_CCEaseOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseOut {
        cocos2d_CCEaseOut_create(pAction, fRate)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseInOut action with a rate\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseInOut {
    pub _base: cocos2d_CCEaseRateAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseInOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the rate parameter"]
    #[link_name = "\u{1}?create@CCEaseInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseInOut;
}
impl cocos2d_CCEaseInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fRate: f32,
    ) -> *mut cocos2d_CCEaseInOut {
        cocos2d_CCEaseInOut_create(pAction, fRate)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEase Exponential In\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialIn>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialIn;
}
impl cocos2d_CCEaseExponentialIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialIn {
        cocos2d_CCEaseExponentialIn_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseExponentialIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseExponentialIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Exponential Out\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialOut;
}
impl cocos2d_CCEaseExponentialOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialOut {
        cocos2d_CCEaseExponentialOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseExponentialOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseExponentialOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Exponential InOut\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseExponentialInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseExponentialInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseExponentialInOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseExponentialInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseExponentialInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseExponentialInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseExponentialInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialInOut;
}
impl cocos2d_CCEaseExponentialInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseExponentialInOut {
        cocos2d_CCEaseExponentialInOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseExponentialInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseExponentialInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseExponentialInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseExponentialInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseExponentialInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Ease Sine In\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineIn>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineIn;
}
impl cocos2d_CCEaseSineIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineIn {
        cocos2d_CCEaseSineIn_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseSineIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseSineIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseSineIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Sine Out\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineOut;
}
impl cocos2d_CCEaseSineOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineOut {
        cocos2d_CCEaseSineOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseSineOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseSineOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseSineOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Sine InOut\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseSineInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseSineInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseSineInOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseSineInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseSineInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseSineInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseSineInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseSineInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseSineInOut;
}
impl cocos2d_CCEaseSineInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseSineInOut {
        cocos2d_CCEaseSineInOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseSineInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseSineInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseSineInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseSineInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseSineInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseSineInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief Ease Elastic abstract class\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElastic {
    pub _base: cocos2d_CCActionEase,
    pub m_fPeriod: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElastic() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCEaseElastic> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElastic>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElastic))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElastic>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElastic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fPeriod) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEaseElastic),
            "::",
            stringify!(m_fPeriod)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?initWithAction@CCEaseElastic@cocos2d@@QAE_NPAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElastic_initWithAction(
        this: *mut cocos2d_CCEaseElastic,
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElastic@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElastic_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElastic;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElastic@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElastic_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElastic;
}
impl cocos2d_CCEaseElastic {
    #[inline]
    pub unsafe fn initWithAction(
        &mut self,
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> bool {
        cocos2d_CCEaseElastic_initWithAction(self, pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElastic {
        cocos2d_CCEaseElastic_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElastic {
        cocos2d_CCEaseElastic_create1(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseElastic@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElastic_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElastic@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElastic_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic In action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticIn {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticIn>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticIn))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticIn_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticIn;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticIn_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticIn;
}
impl cocos2d_CCEaseElasticIn {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticIn {
        cocos2d_CCEaseElasticIn_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElasticIn {
        cocos2d_CCEaseElasticIn_create1(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseElasticIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseElasticIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseElasticIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic Out action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticOut {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticOut;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticOut_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticOut;
}
impl cocos2d_CCEaseElasticOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticOut {
        cocos2d_CCEaseElasticOut_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseElasticOut {
        cocos2d_CCEaseElasticOut_create1(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseElasticOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseElasticOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseElasticOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Ease Elastic InOut action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseElasticInOut {
    pub _base: cocos2d_CCEaseElastic,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseElasticInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseElasticInOut>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseElasticInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseElasticInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseElasticInOut))
    );
}
extern "C" {
    #[doc = " Creates the action with the inner action and the period in radians (default is 0.3)"]
    #[link_name = "\u{1}?create@CCEaseElasticInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@M@Z"]
    pub fn cocos2d_CCEaseElasticInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticInOut;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEaseElasticInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseElasticInOut_create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticInOut;
}
impl cocos2d_CCEaseElasticInOut {
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCActionInterval,
        fPeriod: f32,
    ) -> *mut cocos2d_CCEaseElasticInOut {
        cocos2d_CCEaseElasticInOut_create(pAction, fPeriod)
    }
    #[inline]
    pub unsafe fn create1(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseElasticInOut {
        cocos2d_CCEaseElasticInOut_create1(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseElasticInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseElasticInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseElasticInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseElasticInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseElasticInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseElasticInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBounce abstract class.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounce {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounce() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounce>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounce))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounce>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounce))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?bounceTime@CCEaseBounce@cocos2d@@QAEMM@Z"]
    pub fn cocos2d_CCEaseBounce_bounceTime(this: *mut cocos2d_CCEaseBounce, time: f32) -> f32;
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounce@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounce_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounce;
}
impl cocos2d_CCEaseBounce {
    #[inline]
    pub unsafe fn bounceTime(&mut self, time: f32) -> f32 {
        cocos2d_CCEaseBounce_bounceTime(self, time)
    }
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounce {
        cocos2d_CCEaseBounce_create(pAction)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounce@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounce_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBounce@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounce_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseBounceIn action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceIn {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceIn>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceIn;
}
impl cocos2d_CCEaseBounceIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceIn {
        cocos2d_CCEaseBounceIn_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBounceIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBounceIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBounceIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief EaseBounceOut action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceOut {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceOut;
}
impl cocos2d_CCEaseBounceOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceOut {
        cocos2d_CCEaseBounceOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBounceOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBounceOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBounceOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBounceInOut action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBounceInOut {
    pub _base: cocos2d_CCEaseBounce,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBounceInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBounceInOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBounceInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBounceInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBounceInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBounceInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBounceInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBounceInOut;
}
impl cocos2d_CCEaseBounceInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBounceInOut {
        cocos2d_CCEaseBounceInOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBounceInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBounceInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBounceInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBounceInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBounceInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBounceInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief CCEaseBackIn action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackIn {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackIn>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackIn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackIn))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackIn@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackIn_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackIn;
}
impl cocos2d_CCEaseBackIn {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackIn {
        cocos2d_CCEaseBackIn_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBackIn@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBackIn_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBackIn@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackIn_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackIn@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackIn_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBackOut action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackOut;
}
impl cocos2d_CCEaseBackOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackOut {
        cocos2d_CCEaseBackOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBackOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBackOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBackOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief CCEaseBackInOut action.\n@warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.\n@since v0.8.2\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEaseBackInOut {
    pub _base: cocos2d_CCActionEase,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEaseBackInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEaseBackInOut>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCEaseBackInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEaseBackInOut>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEaseBackInOut))
    );
}
extern "C" {
    #[doc = " creates the action"]
    #[link_name = "\u{1}?create@CCEaseBackInOut@cocos2d@@SAPAV12@PAVCCActionInterval@2@@Z"]
    pub fn cocos2d_CCEaseBackInOut_create(
        pAction: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCEaseBackInOut;
}
impl cocos2d_CCEaseBackInOut {
    #[inline]
    pub unsafe fn create(pAction: *mut cocos2d_CCActionInterval) -> *mut cocos2d_CCEaseBackInOut {
        cocos2d_CCEaseBackInOut_create(pAction)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCEaseBackInOut@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCEaseBackInOut_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCEaseBackInOut@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCEaseBackInOut_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCEaseBackInOut@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCEaseBackInOut_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[repr(C)]
pub struct cocos2d_TypeInfo__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_TypeInfo {
    pub vtable_: *const cocos2d_TypeInfo__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_TypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_TypeInfo>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_TypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_TypeInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_TypeInfo))
    );
}
#[doc = "@brief Instant actions are immediate actions. They don't have a duration like\nthe CCIntervalAction actions."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionInstant {
    pub _base: cocos2d_CCFiniteTimeAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionInstant() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionInstant>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionInstant))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionInstant>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionInstant))
    );
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCActionInstant@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCActionInstant_CCActionInstant(this: *mut cocos2d_CCActionInstant);
}
impl cocos2d_CCActionInstant {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCActionInstant_CCActionInstant(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCActionInstant@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCActionInstant_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?isDone@CCActionInstant@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCActionInstant_isDone(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?step@CCActionInstant@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCActionInstant_step(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCActionInstant@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCActionInstant_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCActionInstant@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCActionInstant_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
#[doc = " @brief Show the node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShow {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShow>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCShow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShow))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCShow@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCShow_create() -> *mut cocos2d_CCShow;
}
impl cocos2d_CCShow {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCShow {
        cocos2d_CCShow_create()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCShow@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCShow_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCShow@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCShow_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShow@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCShow_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Hide the node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCHide {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCHide() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCHide>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCHide))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCHide>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCHide))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCHide@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCHide_create() -> *mut cocos2d_CCHide;
}
impl cocos2d_CCHide {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCHide {
        cocos2d_CCHide_create()
    }
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCHide@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCHide_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCHide@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCHide_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCHide@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCHide_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Toggles the visibility of a node"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCToggleVisibility {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCToggleVisibility() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCToggleVisibility>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCToggleVisibility))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCToggleVisibility>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCToggleVisibility))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCToggleVisibility@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCToggleVisibility_create() -> *mut cocos2d_CCToggleVisibility;
}
impl cocos2d_CCToggleVisibility {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCToggleVisibility {
        cocos2d_CCToggleVisibility_create()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCToggleVisibility@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCToggleVisibility_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCToggleVisibility@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCToggleVisibility_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Remove the node\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRemoveSelf {
    pub _base: cocos2d_CCActionInstant,
    pub m_bIsNeedCleanUp: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRemoveSelf() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRemoveSelf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRemoveSelf>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCRemoveSelf))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRemoveSelf>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRemoveSelf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsNeedCleanUp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRemoveSelf),
            "::",
            stringify!(m_bIsNeedCleanUp)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCRemoveSelf@cocos2d@@SAPAV12@_N@Z"]
    pub fn cocos2d_CCRemoveSelf_create(isNeedCleanUp: bool) -> *mut cocos2d_CCRemoveSelf;
}
extern "thiscall" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?init@CCRemoveSelf@cocos2d@@QAE_N_N@Z"]
    pub fn cocos2d_CCRemoveSelf_init(this: *mut cocos2d_CCRemoveSelf, isNeedCleanUp: bool) -> bool;
}
impl cocos2d_CCRemoveSelf {
    #[inline]
    pub unsafe fn create(isNeedCleanUp: bool) -> *mut cocos2d_CCRemoveSelf {
        cocos2d_CCRemoveSelf_create(isNeedCleanUp)
    }
    #[inline]
    pub unsafe fn init(&mut self, isNeedCleanUp: bool) -> bool {
        cocos2d_CCRemoveSelf_init(self, isNeedCleanUp)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCRemoveSelf@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRemoveSelf_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCRemoveSelf@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCRemoveSelf_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "thiscall" {
    #[link_name = "\u{1}?copyWithZone@CCRemoveSelf@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRemoveSelf_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Flips the sprite horizontally\n@since v0.99.0\n@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipX {
    pub _base: cocos2d_CCActionInstant,
    pub m_bFlipX: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipX() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFlipX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipX>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipX>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFlipX) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFlipX),
            "::",
            stringify!(m_bFlipX)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCFlipX@cocos2d@@SAPAV12@_N@Z"]
    pub fn cocos2d_CCFlipX_create(x: bool) -> *mut cocos2d_CCFlipX;
}
extern "thiscall" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?initWithFlipX@CCFlipX@cocos2d@@QAE_N_N@Z"]
    pub fn cocos2d_CCFlipX_initWithFlipX(this: *mut cocos2d_CCFlipX, x: bool) -> bool;
}
impl cocos2d_CCFlipX {
    #[inline]
    pub unsafe fn create(x: bool) -> *mut cocos2d_CCFlipX {
        cocos2d_CCFlipX_create(x)
    }
    #[inline]
    pub unsafe fn initWithFlipX(&mut self, x: bool) -> bool {
        cocos2d_CCFlipX_initWithFlipX(self, x)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFlipX@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFlipX_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCFlipX@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCFlipX_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipX@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipX_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Flips the sprite vertically\n@since v0.99.0\n@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipY {
    pub _base: cocos2d_CCActionInstant,
    pub m_bFlipY: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipY() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFlipY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipY>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipY>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFlipY) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFlipY),
            "::",
            stringify!(m_bFlipY)
        )
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCFlipY@cocos2d@@SAPAV12@_N@Z"]
    pub fn cocos2d_CCFlipY_create(y: bool) -> *mut cocos2d_CCFlipY;
}
extern "thiscall" {
    #[doc = " init the action"]
    #[link_name = "\u{1}?initWithFlipY@CCFlipY@cocos2d@@QAE_N_N@Z"]
    pub fn cocos2d_CCFlipY_initWithFlipY(this: *mut cocos2d_CCFlipY, y: bool) -> bool;
}
impl cocos2d_CCFlipY {
    #[inline]
    pub unsafe fn create(y: bool) -> *mut cocos2d_CCFlipY {
        cocos2d_CCFlipY_create(y)
    }
    #[inline]
    pub unsafe fn initWithFlipY(&mut self, y: bool) -> bool {
        cocos2d_CCFlipY_initWithFlipY(self, y)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFlipY@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFlipY_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCFlipY@cocos2d@@UAEPAVCCFiniteTimeAction@2@XZ"]
    pub fn cocos2d_CCFlipY_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCFiniteTimeAction;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipY@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipY_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Places the node in a certain position"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPlace {
    pub _base: cocos2d_CCActionInstant,
    pub m_tPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPlace() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPlace> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPlace>(),
        80usize,
        concat!("Size of: ", stringify!(cocos2d_CCPlace))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPlace>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPlace))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tPosition) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPlace),
            "::",
            stringify!(m_tPosition)
        )
    );
}
extern "C" {
    #[doc = " creates a Place action with a position"]
    #[link_name = "\u{1}?create@CCPlace@cocos2d@@SAPAV12@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCPlace_create(pos: *const cocos2d_CCPoint) -> *mut cocos2d_CCPlace;
}
extern "thiscall" {
    #[doc = " Initializes a Place action with a position"]
    #[link_name = "\u{1}?initWithPosition@CCPlace@cocos2d@@QAE_NABVCCPoint@2@@Z"]
    pub fn cocos2d_CCPlace_initWithPosition(
        this: *mut cocos2d_CCPlace,
        pos: *const cocos2d_CCPoint,
    ) -> bool;
}
impl cocos2d_CCPlace {
    #[inline]
    pub unsafe fn create(pos: *const cocos2d_CCPoint) -> *mut cocos2d_CCPlace {
        cocos2d_CCPlace_create(pos)
    }
    #[inline]
    pub unsafe fn initWithPosition(&mut self, pos: *const cocos2d_CCPoint) -> bool {
        cocos2d_CCPlace_initWithPosition(self, pos)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCPlace@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCPlace_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCPlace@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCPlace_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief Calls a 'callback'"]
#[repr(C)]
pub struct cocos2d_CCCallFunc {
    pub _base: cocos2d_CCActionInstant,
    #[doc = " Target that will be called"]
    pub m_pSelectorTarget: *mut cocos2d_CCObject,
    pub m_nScriptHandler: ::std::os::raw::c_int,
    pub __bindgen_anon_1: cocos2d_CCCallFunc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cocos2d_CCCallFunc__bindgen_ty_1 {
    pub m_pCallFunc: cocos2d_SEL_CallFunc,
    pub m_pCallFuncN: cocos2d_SEL_CallFuncN,
    pub m_pCallFuncND: cocos2d_SEL_CallFuncND,
    pub m_pCallFuncO: cocos2d_SEL_CallFuncO,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFunc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCallFunc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFunc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFunc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFunc__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCallFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCallFuncN) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncN)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCallFuncND) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncND)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCallFuncO) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc__bindgen_ty_1),
            "::",
            stringify!(m_pCallFuncO)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFunc() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCallFunc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFunc>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFunc>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFunc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSelectorTarget) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc),
            "::",
            stringify!(m_pSelectorTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScriptHandler) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFunc),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the callback\n\n typedef void (CCObject::*SEL_CallFunc)();\n @lua NA"]
    #[link_name = "\u{1}?create@CCCallFunc@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEXXZ@Z"]
    pub fn cocos2d_CCCallFunc_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFunc,
    ) -> *mut cocos2d_CCCallFunc;
}
extern "C" {
    #[doc = " creates the action with the handler script function\n @js NA"]
    #[link_name = "\u{1}?create@CCCallFunc@cocos2d@@SAPAV12@H@Z"]
    pub fn cocos2d_CCCallFunc_create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFunc;
}
impl cocos2d_CCCallFunc {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFunc,
    ) -> *mut cocos2d_CCCallFunc {
        cocos2d_CCCallFunc_create(pSelectorTarget, selector)
    }
    #[inline]
    pub unsafe fn create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFunc {
        cocos2d_CCCallFunc_create1(nHandler)
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCCallFunc@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCCallFunc_CCCallFunc_destructor(this: *mut cocos2d_CCCallFunc);
}
extern "thiscall" {
    #[doc = " initializes the action with the callback\n\n typedef void (CCObject::*SEL_CallFunc)();\n @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCCallFunc@cocos2d@@UAE_NPAVCCObject@2@@Z"]
    pub fn cocos2d_CCCallFunc_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " executes the callback\n @lua NA"]
    #[link_name = "\u{1}?execute@CCCallFunc@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCCallFunc_execute(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " super methods\n @lua NA"]
    #[link_name = "\u{1}?update@CCCallFunc@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCCallFunc_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = " @js  NA\n @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFunc@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFunc_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = "@brief Calls a 'callback' with the node as the first argument\nN means Node\n @js NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncN {
    pub _base: cocos2d_CCCallFunc,
    pub _base_1: cocos2d_TypeInfo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncN() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncN>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncN))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncN>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncN))
    );
}
extern "C" {
    #[doc = " creates the action with the callback\n\n typedef void (CCObject::*SEL_CallFuncN)(CCNode*);\n @lua NA"]
    #[link_name = "\u{1}?create@CCCallFuncN@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEXPAVCCNode@2@@Z@Z"]
    pub fn cocos2d_CCCallFuncN_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> *mut cocos2d_CCCallFuncN;
}
extern "C" {
    #[doc = " creates the action with the handler script function"]
    #[link_name = "\u{1}?create@CCCallFuncN@cocos2d@@SAPAV12@H@Z"]
    pub fn cocos2d_CCCallFuncN_create1(nHandler: ::std::os::raw::c_int)
        -> *mut cocos2d_CCCallFuncN;
}
impl cocos2d_CCCallFuncN {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> *mut cocos2d_CCCallFuncN {
        cocos2d_CCCallFuncN_create(pSelectorTarget, selector)
    }
    #[inline]
    pub unsafe fn create1(nHandler: ::std::os::raw::c_int) -> *mut cocos2d_CCCallFuncN {
        cocos2d_CCCallFuncN_create1(nHandler)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with the callback\n\n typedef void (CCObject::*SEL_CallFuncN)(CCNode*);\n @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncN@cocos2d@@UAE_NPAVCCObject@2@P832@AEXPAVCCNode@2@@Z@Z"]
    pub fn cocos2d_CCCallFuncN_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncN,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " super methods\n @js  NA\n @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncN@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncN_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?execute@CCCallFuncN@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCCallFuncN_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Calls a 'callback' with the node as the first argument and the 2nd argument is data\n ND means: Node and Data. Data is void *, so it could be anything.\n @js NA\n @lua NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncND {
    pub _base: cocos2d_CCCallFuncN,
    pub m_pData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncND() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCallFuncND> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncND>(),
        92usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncND))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncND>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncND))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFuncND),
            "::",
            stringify!(m_pData)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the callback and the data to pass as an argument"]
    #[link_name = "\u{1}?create@CCCallFuncND@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEXPAVCCNode@2@PAX@Z2@Z"]
    pub fn cocos2d_CCCallFuncND_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCCallFuncND;
}
impl cocos2d_CCCallFuncND {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCCallFuncND {
        cocos2d_CCCallFuncND_create(pSelectorTarget, selector, d)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with the callback and the data to pass as an argument"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncND@cocos2d@@UAE_NPAVCCObject@2@P832@AEXPAVCCNode@2@PAX@Z2@Z"]
    pub fn cocos2d_CCCallFuncND_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncND,
        d: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncND@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncND_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?execute@CCCallFuncND@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCCallFuncND_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief Calls a 'callback' with an object as the first argument.\nO means Object.\n@since v0.99.5\n@js NA\n@lua NA"]
#[repr(C)]
pub struct cocos2d_CCCallFuncO {
    pub _base: cocos2d_CCCallFunc,
    pub _base_1: cocos2d_TypeInfo,
    #[doc = " object to be passed as argument"]
    pub m_pObject: *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCallFuncO() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCallFuncO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCallFuncO>(),
        92usize,
        concat!("Size of: ", stringify!(cocos2d_CCCallFuncO))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCallFuncO>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCallFuncO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pObject) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCallFuncO),
            "::",
            stringify!(m_pObject)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the callback\n\ntypedef void (CCObject::*SEL_CallFuncO)(CCObject*);"]
    #[link_name = "\u{1}?create@CCCallFuncO@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEX0@Z0@Z"]
    pub fn cocos2d_CCCallFuncO_create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCCallFuncO;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCCallFuncO@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCCallFuncO_CCCallFuncO(this: *mut cocos2d_CCCallFuncO);
}
impl cocos2d_CCCallFuncO {
    #[inline]
    pub unsafe fn create(
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> *mut cocos2d_CCCallFuncO {
        cocos2d_CCCallFuncO_create(pSelectorTarget, selector, pObject)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCallFuncO_CCCallFuncO(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCCallFuncO@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCCallFuncO_CCCallFuncO_destructor(this: *mut cocos2d_CCCallFuncO);
}
extern "thiscall" {
    #[doc = " initializes the action with the callback\n\ntypedef void (CCObject::*SEL_CallFuncO)(CCObject*);"]
    #[link_name = "\u{1}?initWithTarget@CCCallFuncO@cocos2d@@UAE_NPAVCCObject@2@P832@AEX0@Z0@Z"]
    pub fn cocos2d_CCCallFuncO_initWithTarget(
        this: *mut ::std::os::raw::c_void,
        pSelectorTarget: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        pObject: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCallFuncO@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCallFuncO_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?execute@CCCallFuncO@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCCallFuncO_execute(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief Base class for Grid actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGridAction {
    pub _base: cocos2d_CCActionInterval,
    pub m_sGridSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGridAction() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCGridAction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGridAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCGridAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGridAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGridAction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sGridSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridAction),
            "::",
            stringify!(m_sGridSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with size and duration"]
    #[link_name = "\u{1}?create@CCGridAction@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCGridAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGridAction;
}
impl cocos2d_CCGridAction {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGridAction {
        cocos2d_CCGridAction_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCGridAction@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCGridAction_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCGridAction@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCGridAction_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCGridAction@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCGridAction_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = " initializes the action with size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCGridAction@cocos2d@@UAE_NMABVCCSize@2@@Z"]
    pub fn cocos2d_CCGridAction_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCGridAction@cocos2d@@UAEPAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCGridAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = "@brief Base class for CCGrid3D actions.\nGrid3D actions can modify a non-tiled grid."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrid3DAction {
    pub _base: cocos2d_CCGridAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrid3DAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrid3DAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrid3DAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrid3DAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrid3DAction))
    );
}
extern "thiscall" {
    #[doc = " returns the vertex than belongs to certain position in the grid"]
    #[link_name = "\u{1}?vertex@CCGrid3DAction@cocos2d@@QAE?AU_ccVertex3F@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_vertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "thiscall" {
    #[doc = " returns the non-transformed vertex than belongs to certain position in the grid"]
    #[link_name = "\u{1}?originalVertex@CCGrid3DAction@cocos2d@@QAE?AU_ccVertex3F@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_originalVertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "thiscall" {
    #[doc = " sets a new vertex to a certain position of the grid"]
    #[link_name = "\u{1}?setVertex@CCGrid3DAction@cocos2d@@QAEXABVCCPoint@2@ABU_ccVertex3F@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_setVertex(
        this: *mut cocos2d_CCGrid3DAction,
        position: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    );
}
extern "C" {
    #[doc = " creates the action with size and duration\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?create@CCGrid3DAction@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCGrid3DAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGrid3DAction;
}
impl cocos2d_CCGrid3DAction {
    #[inline]
    pub unsafe fn vertex(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3DAction_vertex(self, position)
    }
    #[inline]
    pub unsafe fn originalVertex(
        &mut self,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3DAction_originalVertex(self, position)
    }
    #[inline]
    pub unsafe fn setVertex(
        &mut self,
        position: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    ) {
        cocos2d_CCGrid3DAction_setVertex(self, position, vertex)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCGrid3DAction {
        cocos2d_CCGrid3DAction_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCGrid3DAction@cocos2d@@UAEPAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCGrid3DAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = " @brief Base class for CCTiledGrid3D actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTiledGrid3DAction {
    pub _base: cocos2d_CCGridAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTiledGrid3DAction() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTiledGrid3DAction>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTiledGrid3DAction))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTiledGrid3DAction>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTiledGrid3DAction))
    );
}
extern "thiscall" {
    #[doc = " returns the tile that belongs to a certain position of the grid"]
    #[link_name = "\u{1}?tile@CCTiledGrid3DAction@cocos2d@@QAE?AU_ccQuad3@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_tile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "thiscall" {
    #[doc = " returns the non-transformed tile that belongs to a certain position of the grid"]
    #[link_name = "\u{1}?originalTile@CCTiledGrid3DAction@cocos2d@@QAE?AU_ccQuad3@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_originalTile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "thiscall" {
    #[doc = " sets a new tile to a certain position of the grid"]
    #[link_name = "\u{1}?setTile@CCTiledGrid3DAction@cocos2d@@QAEXABVCCPoint@2@ABU_ccQuad3@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_setTile(
        this: *mut cocos2d_CCTiledGrid3DAction,
        position: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    );
}
extern "C" {
    #[doc = " creates the action with size and duration\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?create@CCTiledGrid3DAction@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCTiledGrid3DAction_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3DAction;
}
impl cocos2d_CCTiledGrid3DAction {
    #[inline]
    pub unsafe fn tile(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3DAction_tile(self, position)
    }
    #[inline]
    pub unsafe fn originalTile(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3DAction_originalTile(self, position)
    }
    #[inline]
    pub unsafe fn setTile(
        &mut self,
        position: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    ) {
        cocos2d_CCTiledGrid3DAction_setTile(self, position, coords)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3DAction {
        cocos2d_CCTiledGrid3DAction_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[doc = " returns the grid"]
    #[link_name = "\u{1}?getGrid@CCTiledGrid3DAction@cocos2d@@UAEPAVCCGridBase@2@XZ"]
    pub fn cocos2d_CCTiledGrid3DAction_getGrid(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCGridBase;
}
#[doc = " @brief CCAccelDeccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelDeccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelDeccelAmplitude() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAccelDeccelAmplitude> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelDeccelAmplitude>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelDeccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelDeccelAmplitude>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelDeccelAmplitude))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelDeccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOther) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelDeccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCAccelDeccelAmplitude@cocos2d@@QAE_NPAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_initWithAction(
        this: *mut cocos2d_CCAccelDeccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCAccelDeccelAmplitude@cocos2d@@SAPAV12@PAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelDeccelAmplitude;
}
impl cocos2d_CCAccelDeccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCAccelDeccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelDeccelAmplitude {
        cocos2d_CCAccelDeccelAmplitude_create(pAction, duration)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCAccelDeccelAmplitude@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAccelDeccelAmplitude_CCAccelDeccelAmplitude_destructor(
        this: *mut cocos2d_CCAccelDeccelAmplitude,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCAccelDeccelAmplitude@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCAccelDeccelAmplitude@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCAccelDeccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCAccelDeccelAmplitude@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAccelDeccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCAccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAccelAmplitude() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAccelAmplitude> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAccelAmplitude>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCAccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAccelAmplitude>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAccelAmplitude))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOther) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCAccelAmplitude@cocos2d@@QAE_NPAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelAmplitude_initWithAction(
        this: *mut cocos2d_CCAccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCAccelAmplitude@cocos2d@@SAPAV12@PAVCCAction@2@M@Z"]
    pub fn cocos2d_CCAccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelAmplitude;
}
impl cocos2d_CCAccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCAccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCAccelAmplitude {
        cocos2d_CCAccelAmplitude_create(pAction, duration)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCAccelAmplitude@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAccelAmplitude_CCAccelAmplitude_destructor(
        this: *mut cocos2d_CCAccelAmplitude,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCAccelAmplitude@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCAccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCAccelAmplitude@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCAccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCAccelAmplitude@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCAccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCDeccelAmplitude action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDeccelAmplitude {
    pub _base: cocos2d_CCActionInterval,
    pub m_fRate: f32,
    pub m_pOther: *mut cocos2d_CCActionInterval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDeccelAmplitude() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDeccelAmplitude> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDeccelAmplitude>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCDeccelAmplitude))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDeccelAmplitude>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDeccelAmplitude))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDeccelAmplitude),
            "::",
            stringify!(m_fRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOther) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDeccelAmplitude),
            "::",
            stringify!(m_pOther)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?initWithAction@CCDeccelAmplitude@cocos2d@@QAE_NPAVCCAction@2@M@Z"]
    pub fn cocos2d_CCDeccelAmplitude_initWithAction(
        this: *mut cocos2d_CCDeccelAmplitude,
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with an inner action that has the amplitude property, and a duration time"]
    #[link_name = "\u{1}?create@CCDeccelAmplitude@cocos2d@@SAPAV12@PAVCCAction@2@M@Z"]
    pub fn cocos2d_CCDeccelAmplitude_create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCDeccelAmplitude;
}
impl cocos2d_CCDeccelAmplitude {
    #[inline]
    pub unsafe fn initWithAction(&mut self, pAction: *mut cocos2d_CCAction, duration: f32) -> bool {
        cocos2d_CCDeccelAmplitude_initWithAction(self, pAction, duration)
    }
    #[inline]
    pub unsafe fn create(
        pAction: *mut cocos2d_CCAction,
        duration: f32,
    ) -> *mut cocos2d_CCDeccelAmplitude {
        cocos2d_CCDeccelAmplitude_create(pAction, duration)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCDeccelAmplitude@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCDeccelAmplitude_CCDeccelAmplitude_destructor(
        this: *mut cocos2d_CCDeccelAmplitude,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCDeccelAmplitude@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCDeccelAmplitude_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCDeccelAmplitude@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCDeccelAmplitude_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCDeccelAmplitude@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCDeccelAmplitude_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCStopGrid action.\n@warning Don't call this action if another grid action is active.\nCall if you want to remove the the grid effect. Example:\nCCSequence::actions(Lens::action(...), CCStopGrid::action(...), NULL);"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStopGrid {
    pub _base: cocos2d_CCActionInstant,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStopGrid() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStopGrid>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCStopGrid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStopGrid>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStopGrid))
    );
}
extern "C" {
    #[doc = " Allocates and initializes the action"]
    #[link_name = "\u{1}?create@CCStopGrid@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCStopGrid_create() -> *mut cocos2d_CCStopGrid;
}
impl cocos2d_CCStopGrid {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCStopGrid {
        cocos2d_CCStopGrid_create()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCStopGrid@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCStopGrid_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " @brief CCReuseGrid action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCReuseGrid {
    pub _base: cocos2d_CCActionInstant,
    pub m_nTimes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCReuseGrid() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCReuseGrid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCReuseGrid>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCReuseGrid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCReuseGrid>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCReuseGrid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTimes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCReuseGrid),
            "::",
            stringify!(m_nTimes)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes an action with the number of times that the current grid will be reused"]
    #[link_name = "\u{1}?initWithTimes@CCReuseGrid@cocos2d@@QAE_NH@Z"]
    pub fn cocos2d_CCReuseGrid_initWithTimes(
        this: *mut cocos2d_CCReuseGrid,
        times: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with the number of times that the current grid will be reused"]
    #[link_name = "\u{1}?create@CCReuseGrid@cocos2d@@SAPAV12@H@Z"]
    pub fn cocos2d_CCReuseGrid_create(times: ::std::os::raw::c_int) -> *mut cocos2d_CCReuseGrid;
}
impl cocos2d_CCReuseGrid {
    #[inline]
    pub unsafe fn initWithTimes(&mut self, times: ::std::os::raw::c_int) -> bool {
        cocos2d_CCReuseGrid_initWithTimes(self, times)
    }
    #[inline]
    pub unsafe fn create(times: ::std::os::raw::c_int) -> *mut cocos2d_CCReuseGrid {
        cocos2d_CCReuseGrid_create(times)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCReuseGrid@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCReuseGrid_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = "@brief CCWaves3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWaves3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWaves3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCWaves3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWaves3D>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCWaves3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWaves3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWaves3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWaves) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes an action with duration, grid size, waves and amplitude"]
    #[link_name = "\u{1}?initWithDuration@CCWaves3D@cocos2d@@QAE_NMABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWaves3D_initWithDuration(
        this: *mut cocos2d_CCWaves3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates an action with duration, grid size, waves and amplitude"]
    #[link_name = "\u{1}?create@CCWaves3D@cocos2d@@SAPAV12@MABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWaves3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWaves3D;
}
impl cocos2d_CCWaves3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCWaves3D_initWithDuration(self, duration, gridSize, waves, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWaves3D {
        cocos2d_CCWaves3D_create(duration, gridSize, waves, amplitude)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWaves3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCWaves3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCWaves3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCWaves3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFlipX3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipX3D {
    pub _base: cocos2d_CCGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipX3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipX3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipX3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipX3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipX3D))
    );
}
extern "C" {
    #[doc = " creates the action with duration"]
    #[link_name = "\u{1}?create@CCFlipX3D@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCFlipX3D_create(duration: f32) -> *mut cocos2d_CCFlipX3D;
}
impl cocos2d_CCFlipX3D {
    #[inline]
    pub unsafe fn create(duration: f32) -> *mut cocos2d_CCFlipX3D {
        cocos2d_CCFlipX3D_create(duration)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with duration"]
    #[link_name = "\u{1}?initWithDuration@CCFlipX3D@cocos2d@@UAE_NM@Z"]
    pub fn cocos2d_CCFlipX3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithSize@CCFlipX3D@cocos2d@@UAE_NABVCCSize@2@M@Z"]
    pub fn cocos2d_CCFlipX3D_initWithSize(
        this: *mut ::std::os::raw::c_void,
        gridSize: *const cocos2d_CCSize,
        duration: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipX3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipX3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFlipX3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFlipX3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFlipY3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFlipY3D {
    pub _base: cocos2d_CCFlipX3D,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFlipY3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFlipY3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFlipY3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFlipY3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFlipY3D))
    );
}
extern "C" {
    #[doc = " creates the action with duration"]
    #[link_name = "\u{1}?create@CCFlipY3D@cocos2d@@SAPAV12@M@Z"]
    pub fn cocos2d_CCFlipY3D_create(duration: f32) -> *mut cocos2d_CCFlipY3D;
}
impl cocos2d_CCFlipY3D {
    #[inline]
    pub unsafe fn create(duration: f32) -> *mut cocos2d_CCFlipY3D {
        cocos2d_CCFlipY3D_create(duration)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFlipY3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFlipY3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCFlipY3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCFlipY3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief CCLens3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLens3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_fRadius: f32,
    #[doc = " lens effect. Defaults to 0.7 - 0 means no effect, 1 is very strong effect"]
    pub m_fLensEffect: f32,
    #[doc = " lens is concave. (true = concave, false = convex) default is convex i.e. false"]
    pub m_bConcave: bool,
    pub m_bDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLens3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLens3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLens3D>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCLens3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLens3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLens3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_position) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadius) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fLensEffect) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_fLensEffect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bConcave) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_bConcave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDirty) as usize - ptr as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLens3D),
            "::",
            stringify!(m_bDirty)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setPosition@CCLens3D@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCLens3D_setPosition(
        this: *mut cocos2d_CCLens3D,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " initializes the action with center position, radius, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCLens3D@cocos2d@@QAE_NMABVCCSize@2@ABVCCPoint@2@M@Z"]
    pub fn cocos2d_CCLens3D_initWithDuration(
        this: *mut cocos2d_CCLens3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with center position, radius, a grid size and duration"]
    #[link_name = "\u{1}?create@CCLens3D@cocos2d@@SAPAV12@MABVCCSize@2@ABVCCPoint@2@M@Z"]
    pub fn cocos2d_CCLens3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> *mut cocos2d_CCLens3D;
}
impl cocos2d_CCLens3D {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCLens3D_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> bool {
        cocos2d_CCLens3D_initWithDuration(self, duration, gridSize, position, radius)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
    ) -> *mut cocos2d_CCLens3D {
        cocos2d_CCLens3D_create(duration, gridSize, position, radius)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCLens3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCLens3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCLens3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLens3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCRipple3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRipple3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_fRadius: f32,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRipple3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRipple3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRipple3D>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCRipple3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRipple3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRipple3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_position) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fRadius) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWaves) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRipple3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "thiscall" {
    #[doc = " set center position"]
    #[link_name = "\u{1}?setPosition@CCRipple3D@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCRipple3D_setPosition(
        this: *mut cocos2d_CCRipple3D,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " initializes the action with radius, number of waves, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCRipple3D@cocos2d@@QAE_NMABVCCSize@2@ABVCCPoint@2@MIM@Z"]
    pub fn cocos2d_CCRipple3D_initWithDuration(
        this: *mut cocos2d_CCRipple3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with radius, number of waves, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?create@CCRipple3D@cocos2d@@SAPAV12@MABVCCSize@2@ABVCCPoint@2@MIM@Z"]
    pub fn cocos2d_CCRipple3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCRipple3D;
}
impl cocos2d_CCRipple3D {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCRipple3D_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCRipple3D_initWithDuration(
            self, duration, gridSize, position, radius, waves, amplitude,
        )
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: *const cocos2d_CCPoint,
        radius: f32,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCRipple3D {
        cocos2d_CCRipple3D_create(duration, gridSize, position, radius, waves, amplitude)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCRipple3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCRipple3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCRipple3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCRipple3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShaky3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShaky3D {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bShakeZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShaky3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCShaky3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShaky3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShaky3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShaky3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShaky3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRandrange) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaky3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShakeZ) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaky3D),
            "::",
            stringify!(m_bShakeZ)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with a range, shake Z vertices, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShaky3D@cocos2d@@QAE_NMABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShaky3D_initWithDuration(
        this: *mut cocos2d_CCShaky3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with a range, shake Z vertices, a grid and duration"]
    #[link_name = "\u{1}?create@CCShaky3D@cocos2d@@SAPAV12@MABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShaky3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> *mut cocos2d_CCShaky3D;
}
impl cocos2d_CCShaky3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> bool {
        cocos2d_CCShaky3D_initWithDuration(self, duration, gridSize, range, shakeZ)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        range: ::std::os::raw::c_int,
        shakeZ: bool,
    ) -> *mut cocos2d_CCShaky3D {
        cocos2d_CCShaky3D_create(duration, gridSize, range, shakeZ)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShaky3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCShaky3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCShaky3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCShaky3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCLiquid action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLiquid {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLiquid() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLiquid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLiquid>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCLiquid))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLiquid>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLiquid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWaves) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLiquid),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with amplitude, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCLiquid@cocos2d@@QAE_NMABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCLiquid_initWithDuration(
        this: *mut cocos2d_CCLiquid,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with amplitude, a grid and duration"]
    #[link_name = "\u{1}?create@CCLiquid@cocos2d@@SAPAV12@MABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCLiquid_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCLiquid;
}
impl cocos2d_CCLiquid {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCLiquid_initWithDuration(self, duration, gridSize, waves, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCLiquid {
        cocos2d_CCLiquid_create(duration, gridSize, waves, amplitude)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCLiquid@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCLiquid_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCLiquid@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLiquid_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCWaves action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWaves {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
    pub m_bVertical: bool,
    pub m_bHorizontal: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWaves() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCWaves> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWaves>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCWaves))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWaves>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWaves))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWaves) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVertical) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_bVertical)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHorizontal) as usize - ptr as usize },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWaves),
            "::",
            stringify!(m_bHorizontal)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration"]
    #[link_name = "\u{1}?initWithDuration@CCWaves@cocos2d@@QAE_NMABVCCSize@2@IM_N1@Z"]
    pub fn cocos2d_CCWaves_initWithDuration(
        this: *mut cocos2d_CCWaves,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " initializes the action with amplitude, horizontal sin, vertical sin, a grid and duration"]
    #[link_name = "\u{1}?create@CCWaves@cocos2d@@SAPAV12@MABVCCSize@2@IM_N1@Z"]
    pub fn cocos2d_CCWaves_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> *mut cocos2d_CCWaves;
}
impl cocos2d_CCWaves {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> bool {
        cocos2d_CCWaves_initWithDuration(
            self, duration, gridSize, waves, amplitude, horizontal, vertical,
        )
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
        horizontal: bool,
        vertical: bool,
    ) -> *mut cocos2d_CCWaves {
        cocos2d_CCWaves_create(duration, gridSize, waves, amplitude, horizontal, vertical)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWaves@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCWaves_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCWaves@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCWaves_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCTwirl action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTwirl {
    pub _base: cocos2d_CCGrid3DAction,
    pub m_position: cocos2d_CCPoint,
    pub m_nTwirls: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTwirl() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTwirl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTwirl>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCTwirl))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTwirl>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTwirl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_position) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTwirls) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_nTwirls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTwirl),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "thiscall" {
    #[doc = " set twirl center"]
    #[link_name = "\u{1}?setPosition@CCTwirl@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTwirl_setPosition(
        this: *mut cocos2d_CCTwirl,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " initializes the action with center position, number of twirls, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCTwirl@cocos2d@@QAE_NMABVCCSize@2@VCCPoint@2@IM@Z"]
    pub fn cocos2d_CCTwirl_initWithDuration(
        this: *mut cocos2d_CCTwirl,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with center position, number of twirls, amplitude, a grid size and duration"]
    #[link_name = "\u{1}?create@CCTwirl@cocos2d@@SAPAV12@MABVCCSize@2@VCCPoint@2@IM@Z"]
    pub fn cocos2d_CCTwirl_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCTwirl;
}
impl cocos2d_CCTwirl {
    #[inline]
    pub unsafe fn setPosition(&mut self, position: *const cocos2d_CCPoint) {
        cocos2d_CCTwirl_setPosition(self, position)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCTwirl_initWithDuration(self, duration, gridSize, position, twirls, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        position: cocos2d_CCPoint,
        twirls: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCTwirl {
        cocos2d_CCTwirl_create(duration, gridSize, position, twirls, amplitude)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTwirl@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCTwirl_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCTwirl@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTwirl_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief This action simulates a page turn from the bottom right hand corner of the screen.\nIt's not much use by itself but is used by the PageTurnTransition.\n\nBased on an original paper by L Hong et al.\nhttp://www.parc.com/publication/1638/turning-pages-of-3d-electronic-books.html\n\n@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPageTurn3D {
    pub _base: cocos2d_CCGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPageTurn3D() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPageTurn3D>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCPageTurn3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPageTurn3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPageTurn3D))
    );
}
extern "C" {
    #[doc = " create the action"]
    #[link_name = "\u{1}?create@CCPageTurn3D@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCPageTurn3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCPageTurn3D;
}
impl cocos2d_CCPageTurn3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCPageTurn3D {
        cocos2d_CCPageTurn3D_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCPageTurn3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCPageTurn3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Progress to percentage\n@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fTo: f32,
    pub m_fFrom: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCProgressTo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTo),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrom) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTo),
            "::",
            stringify!(m_fFrom)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes with a duration and a percent"]
    #[link_name = "\u{1}?initWithDuration@CCProgressTo@cocos2d@@QAE_NMM@Z"]
    pub fn cocos2d_CCProgressTo_initWithDuration(
        this: *mut cocos2d_CCProgressTo,
        duration: f32,
        fPercent: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates and initializes with a duration and a percent"]
    #[link_name = "\u{1}?create@CCProgressTo@cocos2d@@SAPAV12@MM@Z"]
    pub fn cocos2d_CCProgressTo_create(duration: f32, fPercent: f32) -> *mut cocos2d_CCProgressTo;
}
impl cocos2d_CCProgressTo {
    #[inline]
    pub unsafe fn initWithDuration(&mut self, duration: f32, fPercent: f32) -> bool {
        cocos2d_CCProgressTo_initWithDuration(self, duration, fPercent)
    }
    #[inline]
    pub unsafe fn create(duration: f32, fPercent: f32) -> *mut cocos2d_CCProgressTo {
        cocos2d_CCProgressTo_create(duration, fPercent)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCProgressTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCProgressTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCProgressTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCProgressTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCProgressTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCProgressTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = "@brief Progress from a percentage to another percentage\n@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressFromTo {
    pub _base: cocos2d_CCActionInterval,
    pub m_fTo: f32,
    pub m_fFrom: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressFromTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCProgressFromTo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressFromTo>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressFromTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressFromTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressFromTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressFromTo),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrom) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressFromTo),
            "::",
            stringify!(m_fFrom)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes the action with a duration, a \"from\" percentage and a \"to\" percentage"]
    #[link_name = "\u{1}?initWithDuration@CCProgressFromTo@cocos2d@@QAE_NMMM@Z"]
    pub fn cocos2d_CCProgressFromTo_initWithDuration(
        this: *mut cocos2d_CCProgressFromTo,
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates and initializes the action with a duration, a \"from\" percentage and a \"to\" percentage"]
    #[link_name = "\u{1}?create@CCProgressFromTo@cocos2d@@SAPAV12@MMM@Z"]
    pub fn cocos2d_CCProgressFromTo_create(
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> *mut cocos2d_CCProgressFromTo;
}
impl cocos2d_CCProgressFromTo {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> bool {
        cocos2d_CCProgressFromTo_initWithDuration(self, duration, fFromPercentage, fToPercentage)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        fFromPercentage: f32,
        fToPercentage: f32,
    ) -> *mut cocos2d_CCProgressFromTo {
        cocos2d_CCProgressFromTo_create(duration, fFromPercentage, fToPercentage)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCProgressFromTo@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCProgressFromTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCProgressFromTo@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCProgressFromTo_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCProgressFromTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCProgressFromTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCProgressFromTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCProgressFromTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShakyTiles3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShakyTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bShakeZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShakyTiles3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCShakyTiles3D> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShakyTiles3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShakyTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShakyTiles3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShakyTiles3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRandrange) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShakyTiles3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShakeZ) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShakyTiles3D),
            "::",
            stringify!(m_bShakeZ)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a range, whether or not to shake Z vertices, a grid size, and duration"]
    #[link_name = "\u{1}?create@CCShakyTiles3D@cocos2d@@SAPAV12@MABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShakyTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> *mut cocos2d_CCShakyTiles3D;
}
impl cocos2d_CCShakyTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> *mut cocos2d_CCShakyTiles3D {
        cocos2d_CCShakyTiles3D_create(duration, gridSize, nRange, bShakeZ)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with a range, whether or not to shake Z vertices, a grid size, and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShakyTiles3D@cocos2d@@UAE_NMABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShakyTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShakeZ: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShakyTiles3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCShakyTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCShakyTiles3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCShakyTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCShatteredTiles3D action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShatteredTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRandrange: ::std::os::raw::c_int,
    pub m_bOnce: bool,
    pub m_bShatterZ: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShatteredTiles3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCShatteredTiles3D> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShatteredTiles3D>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCShatteredTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShatteredTiles3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShatteredTiles3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRandrange) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_nRandrange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOnce) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_bOnce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShatterZ) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShatteredTiles3D),
            "::",
            stringify!(m_bShatterZ)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a range, whether of not to shatter Z vertices, a grid size and duration"]
    #[link_name = "\u{1}?create@CCShatteredTiles3D@cocos2d@@SAPAV12@MABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShatteredTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> *mut cocos2d_CCShatteredTiles3D;
}
impl cocos2d_CCShatteredTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> *mut cocos2d_CCShatteredTiles3D {
        cocos2d_CCShatteredTiles3D_create(duration, gridSize, nRange, bShatterZ)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with a range, whether or not to shatter Z vertices, a grid size and duration"]
    #[link_name = "\u{1}?initWithDuration@CCShatteredTiles3D@cocos2d@@UAE_NMABVCCSize@2@H_N@Z"]
    pub fn cocos2d_CCShatteredTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        nRange: ::std::os::raw::c_int,
        bShatterZ: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShatteredTiles3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCShatteredTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCShatteredTiles3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCShatteredTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_Tile {
    _unused: [u8; 0],
}
#[doc = " @brief CCShuffleTiles action\nShuffle the tiles in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShuffleTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nSeed: ::std::os::raw::c_uint,
    pub m_nTilesCount: ::std::os::raw::c_uint,
    pub m_pTilesOrder: *mut ::std::os::raw::c_uint,
    pub m_pTiles: *mut cocos2d_Tile,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShuffleTiles() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCShuffleTiles> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShuffleTiles>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCShuffleTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShuffleTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShuffleTiles))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSeed) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_nSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTilesCount) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_nTilesCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTilesOrder) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_pTilesOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTiles) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShuffleTiles),
            "::",
            stringify!(m_pTiles)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?shuffle@CCShuffleTiles@cocos2d@@QAEXPAII@Z"]
    pub fn cocos2d_CCShuffleTiles_shuffle(
        this: *mut cocos2d_CCShuffleTiles,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getDelta@CCShuffleTiles@cocos2d@@QAE?AVCCSize@2@ABV32@@Z"]
    pub fn cocos2d_CCShuffleTiles_getDelta(
        this: *mut cocos2d_CCShuffleTiles,
        pos: *const cocos2d_CCSize,
    ) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[link_name = "\u{1}?placeTile@CCShuffleTiles@cocos2d@@QAEXABVCCPoint@2@PAUTile@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_placeTile(
        this: *mut cocos2d_CCShuffleTiles,
        pos: *const cocos2d_CCPoint,
        t: *mut cocos2d_Tile,
    );
}
extern "C" {
    #[doc = " creates the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCShuffleTiles@cocos2d@@SAPAV12@MABVCCSize@2@I@Z"]
    pub fn cocos2d_CCShuffleTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCShuffleTiles;
}
impl cocos2d_CCShuffleTiles {
    #[inline]
    pub unsafe fn shuffle(
        &mut self,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCShuffleTiles_shuffle(self, pArray, nLen)
    }
    #[inline]
    pub unsafe fn getDelta(&mut self, pos: *const cocos2d_CCSize) -> cocos2d_CCSize {
        cocos2d_CCShuffleTiles_getDelta(self, pos)
    }
    #[inline]
    pub unsafe fn placeTile(&mut self, pos: *const cocos2d_CCPoint, t: *mut cocos2d_Tile) {
        cocos2d_CCShuffleTiles_placeTile(self, pos, t)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCShuffleTiles {
        cocos2d_CCShuffleTiles_create(duration, gridSize, seed)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCShuffleTiles@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCShuffleTiles_CCShuffleTiles_destructor(this: *mut cocos2d_CCShuffleTiles);
}
extern "thiscall" {
    #[doc = " initializes the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCShuffleTiles@cocos2d@@UAE_NMABVCCSize@2@I@Z"]
    pub fn cocos2d_CCShuffleTiles_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCShuffleTiles@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCShuffleTiles@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCShuffleTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCShuffleTiles@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCShuffleTiles_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " @brief CCFadeOutTRTiles action\nFades out the tiles in a Top-Right direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutTRTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutTRTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutTRTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutTRTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutTRTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutTRTiles))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?turnOnTile@CCFadeOutTRTiles@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_turnOnTile(
        this: *mut cocos2d_CCFadeOutTRTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?turnOffTile@CCFadeOutTRTiles@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_turnOffTile(
        this: *mut cocos2d_CCFadeOutTRTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutTRTiles@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutTRTiles;
}
impl cocos2d_CCFadeOutTRTiles {
    #[inline]
    pub unsafe fn turnOnTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCFadeOutTRTiles_turnOnTile(self, pos)
    }
    #[inline]
    pub unsafe fn turnOffTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCFadeOutTRTiles_turnOffTile(self, pos)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutTRTiles {
        cocos2d_CCFadeOutTRTiles_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?testFunc@CCFadeOutTRTiles@cocos2d@@UAEMABVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?transformTile@CCFadeOutTRTiles@cocos2d@@UAEXABVCCPoint@2@M@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_transformTile(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
        distance: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCFadeOutTRTiles@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCFadeOutTRTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCFadeOutBLTiles action.\nFades out the tiles in a Bottom-Left direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutBLTiles {
    pub _base: cocos2d_CCFadeOutTRTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutBLTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutBLTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutBLTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutBLTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutBLTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutBLTiles@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutBLTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutBLTiles;
}
impl cocos2d_CCFadeOutBLTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutBLTiles {
        cocos2d_CCFadeOutBLTiles_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?testFunc@CCFadeOutBLTiles@cocos2d@@UAEMABVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutBLTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
#[doc = " @brief CCFadeOutUpTiles action.\nFades out the tiles in upwards direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutUpTiles {
    pub _base: cocos2d_CCFadeOutTRTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutUpTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutUpTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutUpTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutUpTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutUpTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutUpTiles@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutUpTiles;
}
impl cocos2d_CCFadeOutUpTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutUpTiles {
        cocos2d_CCFadeOutUpTiles_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?testFunc@CCFadeOutUpTiles@cocos2d@@UAEMABVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?transformTile@CCFadeOutUpTiles@cocos2d@@UAEXABVCCPoint@2@M@Z"]
    pub fn cocos2d_CCFadeOutUpTiles_transformTile(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
        distance: f32,
    );
}
#[doc = " @brief CCFadeOutDownTiles action.\nFades out the tiles in downwards direction"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFadeOutDownTiles {
    pub _base: cocos2d_CCFadeOutUpTiles,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFadeOutDownTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFadeOutDownTiles>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCFadeOutDownTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFadeOutDownTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFadeOutDownTiles))
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCFadeOutDownTiles@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCFadeOutDownTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutDownTiles;
}
impl cocos2d_CCFadeOutDownTiles {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCFadeOutDownTiles {
        cocos2d_CCFadeOutDownTiles_create(duration, gridSize)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?testFunc@CCFadeOutDownTiles@cocos2d@@UAEMABVCCSize@2@M@Z"]
    pub fn cocos2d_CCFadeOutDownTiles_testFunc(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCSize,
        time: f32,
    ) -> f32;
}
#[doc = " @brief CCTurnOffTiles action.\nTurn off the files in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTurnOffTiles {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nSeed: ::std::os::raw::c_uint,
    pub m_nTilesCount: ::std::os::raw::c_uint,
    pub m_pTilesOrder: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTurnOffTiles() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTurnOffTiles> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTurnOffTiles>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCTurnOffTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTurnOffTiles>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTurnOffTiles))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSeed) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_nSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTilesCount) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_nTilesCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTilesOrder) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTurnOffTiles),
            "::",
            stringify!(m_pTilesOrder)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?shuffle@CCTurnOffTiles@cocos2d@@QAEXPAII@Z"]
    pub fn cocos2d_CCTurnOffTiles_shuffle(
        this: *mut cocos2d_CCTurnOffTiles,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?turnOnTile@CCTurnOffTiles@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_turnOnTile(
        this: *mut cocos2d_CCTurnOffTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?turnOffTile@CCTurnOffTiles@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_turnOffTile(
        this: *mut cocos2d_CCTurnOffTiles,
        pos: *const cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " creates the action with the grid size and the duration"]
    #[link_name = "\u{1}?create@CCTurnOffTiles@cocos2d@@SAPAV12@MABVCCSize@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTurnOffTiles;
}
extern "C" {
    #[doc = " creates the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCTurnOffTiles@cocos2d@@SAPAV12@MABVCCSize@2@I@Z"]
    pub fn cocos2d_CCTurnOffTiles_create1(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTurnOffTiles;
}
impl cocos2d_CCTurnOffTiles {
    #[inline]
    pub unsafe fn shuffle(
        &mut self,
        pArray: *mut ::std::os::raw::c_uint,
        nLen: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTurnOffTiles_shuffle(self, pArray, nLen)
    }
    #[inline]
    pub unsafe fn turnOnTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCTurnOffTiles_turnOnTile(self, pos)
    }
    #[inline]
    pub unsafe fn turnOffTile(&mut self, pos: *const cocos2d_CCPoint) {
        cocos2d_CCTurnOffTiles_turnOffTile(self, pos)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTurnOffTiles {
        cocos2d_CCTurnOffTiles_create(duration, gridSize)
    }
    #[inline]
    pub unsafe fn create1(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTurnOffTiles {
        cocos2d_CCTurnOffTiles_create1(duration, gridSize, seed)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTurnOffTiles@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTurnOffTiles_CCTurnOffTiles_destructor(this: *mut cocos2d_CCTurnOffTiles);
}
extern "thiscall" {
    #[doc = " initializes the action with a random seed, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCTurnOffTiles@cocos2d@@UAE_NMABVCCSize@2@I@Z"]
    pub fn cocos2d_CCTurnOffTiles_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        seed: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCTurnOffTiles@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCTurnOffTiles@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCTurnOffTiles_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCTurnOffTiles@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTurnOffTiles_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCWavesTiles3D action."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCWavesTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nWaves: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCWavesTiles3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCWavesTiles3D> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCWavesTiles3D>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCWavesTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCWavesTiles3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCWavesTiles3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWaves) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_nWaves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCWavesTiles3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "C" {
    #[doc = " creates the action with a number of waves, the waves amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCWavesTiles3D@cocos2d@@SAPAV12@MABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWavesTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWavesTiles3D;
}
impl cocos2d_CCWavesTiles3D {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCWavesTiles3D {
        cocos2d_CCWavesTiles3D_create(duration, gridSize, waves, amplitude)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with a number of waves, the waves amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCWavesTiles3D@cocos2d@@UAE_NMABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCWavesTiles3D_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        waves: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCWavesTiles3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCWavesTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCWavesTiles3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCWavesTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCJumpTiles3D action.\nA sin function is executed to move the tiles across the Z axis"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCJumpTiles3D {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nJumps: ::std::os::raw::c_uint,
    pub m_fAmplitude: f32,
    pub m_fAmplitudeRate: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCJumpTiles3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCJumpTiles3D> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCJumpTiles3D>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCJumpTiles3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCJumpTiles3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCJumpTiles3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nJumps) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_nJumps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitude) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_fAmplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAmplitudeRate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCJumpTiles3D),
            "::",
            stringify!(m_fAmplitudeRate)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes the action with the number of jumps, the sin amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCJumpTiles3D@cocos2d@@QAE_NMABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCJumpTiles3D_initWithDuration(
        this: *mut cocos2d_CCJumpTiles3D,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " creates the action with the number of jumps, the sin amplitude, the grid size and the duration"]
    #[link_name = "\u{1}?create@CCJumpTiles3D@cocos2d@@SAPAV12@MABVCCSize@2@IM@Z"]
    pub fn cocos2d_CCJumpTiles3D_create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCJumpTiles3D;
}
impl cocos2d_CCJumpTiles3D {
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> bool {
        cocos2d_CCJumpTiles3D_initWithDuration(self, duration, gridSize, numberOfJumps, amplitude)
    }
    #[inline]
    pub unsafe fn create(
        duration: f32,
        gridSize: *const cocos2d_CCSize,
        numberOfJumps: ::std::os::raw::c_uint,
        amplitude: f32,
    ) -> *mut cocos2d_CCJumpTiles3D {
        cocos2d_CCJumpTiles3D_create(duration, gridSize, numberOfJumps, amplitude)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCJumpTiles3D@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCJumpTiles3D_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCJumpTiles3D@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCJumpTiles3D_update(this: *mut ::std::os::raw::c_void, time: f32);
}
#[doc = " @brief CCSplitRows action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSplitRows {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nRows: ::std::os::raw::c_uint,
    pub m_winSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSplitRows() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSplitRows> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSplitRows>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCSplitRows))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSplitRows>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSplitRows))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRows) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitRows),
            "::",
            stringify!(m_nRows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_winSize) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitRows),
            "::",
            stringify!(m_winSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the number of rows to split and the duration"]
    #[link_name = "\u{1}?create@CCSplitRows@cocos2d@@SAPAV12@MI@Z"]
    pub fn cocos2d_CCSplitRows_create(
        duration: f32,
        nRows: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSplitRows;
}
impl cocos2d_CCSplitRows {
    #[inline]
    pub unsafe fn create(duration: f32, nRows: ::std::os::raw::c_uint) -> *mut cocos2d_CCSplitRows {
        cocos2d_CCSplitRows_create(duration, nRows)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with the number of rows to split and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCSplitRows@cocos2d@@UAE_NMI@Z"]
    pub fn cocos2d_CCSplitRows_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        nRows: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSplitRows@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSplitRows_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCSplitRows@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSplitRows_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCSplitRows@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSplitRows_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[doc = " @brief CCSplitCols action"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSplitCols {
    pub _base: cocos2d_CCTiledGrid3DAction,
    pub m_nCols: ::std::os::raw::c_uint,
    pub m_winSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSplitCols() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSplitCols> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSplitCols>(),
        100usize,
        concat!("Size of: ", stringify!(cocos2d_CCSplitCols))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSplitCols>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSplitCols))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCols) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitCols),
            "::",
            stringify!(m_nCols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_winSize) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSplitCols),
            "::",
            stringify!(m_winSize)
        )
    );
}
extern "C" {
    #[doc = " creates the action with the number of columns to split and the duration"]
    #[link_name = "\u{1}?create@CCSplitCols@cocos2d@@SAPAV12@MI@Z"]
    pub fn cocos2d_CCSplitCols_create(
        duration: f32,
        nCols: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSplitCols;
}
impl cocos2d_CCSplitCols {
    #[inline]
    pub unsafe fn create(duration: f32, nCols: ::std::os::raw::c_uint) -> *mut cocos2d_CCSplitCols {
        cocos2d_CCSplitCols_create(duration, nCols)
    }
}
extern "thiscall" {
    #[doc = " initializes the action with the number of columns to split and the duration"]
    #[link_name = "\u{1}?initWithDuration@CCSplitCols@cocos2d@@UAE_NMI@Z"]
    pub fn cocos2d_CCSplitCols_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        duration: f32,
        nCols: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCSplitCols@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCSplitCols_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCSplitCols@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSplitCols_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCSplitCols@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSplitCols_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
#[repr(C)]
pub struct cocos2d_CCActionTweenDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup actions\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionTweenDelegate {
    pub vtable_: *const cocos2d_CCActionTweenDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionTweenDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionTweenDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionTweenDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionTweenDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionTweenDelegate))
    );
}
#[doc = " CCActionTween\n\nCCActionTween is an action that lets you update any property of an object.\nFor example, if you want to modify the \"width\" property of a target from 200 to 300 in 2 seconds, then:\n\nid modifyWidth = [CCActionTween actionWithDuration:2 key:@\"width\" from:200 to:300];\n[target runAction:modifyWidth];\n\n\nAnother example: CCScaleTo action could be rewritten using CCPropertyAction:\n\n// scaleA and scaleB are equivalents\nid scaleA = [CCScaleTo actionWithDuration:2 scale:3];\nid scaleB = [CCActionTween actionWithDuration:2 key:@\"scale\" from:1 to:3];\n\n\n@since v0.99.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCActionTween {
    pub _base: cocos2d_CCActionInterval,
    pub m_strKey: std_string,
    pub m_fFrom: f32,
    pub m_fTo: f32,
    pub m_fDelta: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCActionTween() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCActionTween> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCActionTween>(),
        116usize,
        concat!("Size of: ", stringify!(cocos2d_CCActionTween))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCActionTween>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCActionTween))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strKey) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_strKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrom) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fFrom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTo) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDelta) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCActionTween),
            "::",
            stringify!(m_fDelta)
        )
    );
}
extern "C" {
    #[doc = " creates an initializes the action with the property name (key), and the from and to parameters."]
    #[link_name = "\u{1}?create@CCActionTween@cocos2d@@SAPAV12@MPBDMM@Z"]
    pub fn cocos2d_CCActionTween_create(
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> *mut cocos2d_CCActionTween;
}
extern "thiscall" {
    #[doc = " initializes the action with the property name (key), and the from and to parameters."]
    #[link_name = "\u{1}?initWithDuration@CCActionTween@cocos2d@@QAE_NMPBDMM@Z"]
    pub fn cocos2d_CCActionTween_initWithDuration(
        this: *mut cocos2d_CCActionTween,
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> bool;
}
impl cocos2d_CCActionTween {
    #[inline]
    pub unsafe fn create(
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> *mut cocos2d_CCActionTween {
        cocos2d_CCActionTween_create(aDuration, key, from, to)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        aDuration: f32,
        key: *const ::std::os::raw::c_char,
        from: f32,
        to: f32,
    ) -> bool {
        cocos2d_CCActionTween_initWithDuration(self, aDuration, key, from, to)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?startWithTarget@CCActionTween@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCActionTween_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCActionTween@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCActionTween_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCActionTween@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCActionTween_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " An Array that contain control points.\n Used by CCCardinalSplineTo and (By) and CCCatmullRomTo (and By) actions.\n @ingroup Actions\n @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPointArray {
    pub _base: cocos2d_CCObject,
    #[doc = " Array that contains the control points"]
    pub m_pControlPoints: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPointArray() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPointArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPointArray>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCPointArray))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPointArray>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPointArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pControlPoints) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPointArray),
            "::",
            stringify!(m_pControlPoints)
        )
    );
}
extern "C" {
    #[doc = " creates and initializes a Points array with capacity\n @lua NA"]
    #[link_name = "\u{1}?create@CCPointArray@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCPointArray_create(
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCPointArray;
}
extern "thiscall" {
    #[doc = " initializes a Catmull Rom config with a capacity hint"]
    #[link_name = "\u{1}?initWithCapacity@CCPointArray@cocos2d@@QAE_NI@Z"]
    pub fn cocos2d_CCPointArray_initWithCapacity(
        this: *mut cocos2d_CCPointArray,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " appends a control point"]
    #[link_name = "\u{1}?addControlPoint@CCPointArray@cocos2d@@QAEXVCCPoint@2@@Z"]
    pub fn cocos2d_CCPointArray_addControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " inserts a controlPoint at index"]
    #[link_name = "\u{1}?insertControlPoint@CCPointArray@cocos2d@@QAEXAAVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_insertControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " replaces an existing controlPoint at index"]
    #[link_name = "\u{1}?replaceControlPoint@CCPointArray@cocos2d@@QAEXAAVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_replaceControlPoint(
        this: *mut cocos2d_CCPointArray,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " get the value of a controlPoint at a given index"]
    #[link_name = "\u{1}?getControlPointAtIndex@CCPointArray@cocos2d@@QAE?AVCCPoint@2@I@Z"]
    pub fn cocos2d_CCPointArray_getControlPointAtIndex(
        this: *mut cocos2d_CCPointArray,
        index: ::std::os::raw::c_uint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " deletes a control point at a given index"]
    #[link_name = "\u{1}?removeControlPointAtIndex@CCPointArray@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCPointArray_removeControlPointAtIndex(
        this: *mut cocos2d_CCPointArray,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " returns the number of objects of the control point array"]
    #[link_name = "\u{1}?count@CCPointArray@cocos2d@@QAEIXZ"]
    pub fn cocos2d_CCPointArray_count(this: *mut cocos2d_CCPointArray) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " returns a new copy of the array reversed. User is responsible for releasing this copy"]
    #[link_name = "\u{1}?reverse@CCPointArray@cocos2d@@QAEPAV12@XZ"]
    pub fn cocos2d_CCPointArray_reverse(
        this: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCPointArray;
}
extern "thiscall" {
    #[doc = " reverse the current control point array inline, without generating a new one"]
    #[link_name = "\u{1}?reverseInline@CCPointArray@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCPointArray_reverseInline(this: *mut cocos2d_CCPointArray);
}
extern "thiscall" {
    #[link_name = "\u{1}?getControlPoints@CCPointArray@cocos2d@@QAEPBV?$vector@PAVCCPoint@cocos2d@@V?$allocator@PAVCCPoint@cocos2d@@@std@@@std@@XZ"]
    pub fn cocos2d_CCPointArray_getControlPoints(this: *mut cocos2d_CCPointArray) -> *const u8;
}
extern "thiscall" {
    #[link_name = "\u{1}?setControlPoints@CCPointArray@cocos2d@@QAEXPAV?$vector@PAVCCPoint@cocos2d@@V?$allocator@PAVCCPoint@cocos2d@@@std@@@std@@@Z"]
    pub fn cocos2d_CCPointArray_setControlPoints(
        this: *mut cocos2d_CCPointArray,
        controlPoints: *mut u8,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCPointArray@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCPointArray_CCPointArray(this: *mut cocos2d_CCPointArray);
}
impl cocos2d_CCPointArray {
    #[inline]
    pub unsafe fn create(capacity: ::std::os::raw::c_uint) -> *mut cocos2d_CCPointArray {
        cocos2d_CCPointArray_create(capacity)
    }
    #[inline]
    pub unsafe fn initWithCapacity(&mut self, capacity: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCPointArray_initWithCapacity(self, capacity)
    }
    #[inline]
    pub unsafe fn addControlPoint(&mut self, controlPoint: cocos2d_CCPoint) {
        cocos2d_CCPointArray_addControlPoint(self, controlPoint)
    }
    #[inline]
    pub unsafe fn insertControlPoint(
        &mut self,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCPointArray_insertControlPoint(self, controlPoint, index)
    }
    #[inline]
    pub unsafe fn replaceControlPoint(
        &mut self,
        controlPoint: *mut cocos2d_CCPoint,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCPointArray_replaceControlPoint(self, controlPoint, index)
    }
    #[inline]
    pub unsafe fn getControlPointAtIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
    ) -> cocos2d_CCPoint {
        cocos2d_CCPointArray_getControlPointAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn removeControlPointAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCPointArray_removeControlPointAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn count(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCPointArray_count(self)
    }
    #[inline]
    pub unsafe fn reverse(&mut self) -> *mut cocos2d_CCPointArray {
        cocos2d_CCPointArray_reverse(self)
    }
    #[inline]
    pub unsafe fn reverseInline(&mut self) {
        cocos2d_CCPointArray_reverseInline(self)
    }
    #[inline]
    pub unsafe fn getControlPoints(&mut self) -> *const u8 {
        cocos2d_CCPointArray_getControlPoints(self)
    }
    #[inline]
    pub unsafe fn setControlPoints(&mut self, controlPoints: *mut u8) {
        cocos2d_CCPointArray_setControlPoints(self, controlPoints)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPointArray_CCPointArray(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??1CCPointArray@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCPointArray_CCPointArray_destructor(this: *mut cocos2d_CCPointArray);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCPointArray@cocos2d@@UAEPAVCCObject@2@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCPointArray_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        zone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCObject;
}
#[doc = " Cardinal Spline path.\nhttp://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCardinalSplineTo {
    pub _base: cocos2d_CCActionInterval,
    #[doc = " Array of control points"]
    pub m_pPoints: *mut cocos2d_CCPointArray,
    pub m_fDeltaT: f32,
    pub m_fTension: f32,
    pub m_previousPosition: cocos2d_CCPoint,
    pub m_accumulatedDiff: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCardinalSplineTo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCardinalSplineTo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCardinalSplineTo>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCCardinalSplineTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCardinalSplineTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCardinalSplineTo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPoints) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_pPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaT) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_fDeltaT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTension) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_fTension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_previousPosition) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_previousPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_accumulatedDiff) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineTo),
            "::",
            stringify!(m_accumulatedDiff)
        )
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension\n  @code\n  when thie function bound to js,the input params are changed\n  js:var create(var duration,var pointTable,var tension)\n  @endcode"]
    #[link_name = "\u{1}?create@CCCardinalSplineTo@cocos2d@@SAPAV12@MPAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineTo_create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineTo;
}
extern "thiscall" {
    #[doc = " initializes the action with a duration and an array of points\n  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCardinalSplineTo@cocos2d@@QAE_NMPAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineTo_initWithDuration(
        this: *mut cocos2d_CCCardinalSplineTo,
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js ctor\n  @lua NA"]
    #[link_name = "\u{1}??0CCCardinalSplineTo@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCCardinalSplineTo_CCCardinalSplineTo(this: *mut cocos2d_CCCardinalSplineTo);
}
impl cocos2d_CCCardinalSplineTo {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineTo {
        cocos2d_CCCardinalSplineTo_create(duration, points, tension)
    }
    #[inline]
    pub unsafe fn initWithDuration(
        &mut self,
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> bool {
        cocos2d_CCCardinalSplineTo_initWithDuration(self, duration, points, tension)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCardinalSplineTo_CCCardinalSplineTo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCCardinalSplineTo@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCCardinalSplineTo_CCCardinalSplineTo_destructor(
        this: *mut cocos2d_CCCardinalSplineTo,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?copyWithZone@CCCardinalSplineTo@cocos2d@@UAEPAV12@PAVCCZone@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_copyWithZone(
        this: *mut ::std::os::raw::c_void,
        pZone: *mut cocos2d_CCZone,
    ) -> *mut cocos2d_CCCardinalSplineTo;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCCardinalSplineTo@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?update@CCCardinalSplineTo@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCCardinalSplineTo_update(this: *mut ::std::os::raw::c_void, time: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCCardinalSplineTo@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCCardinalSplineTo_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?updatePosition@CCCardinalSplineTo@cocos2d@@UAEXAAVCCPoint@2@@Z"]
    pub fn cocos2d_CCCardinalSplineTo_updatePosition(
        this: *mut ::std::os::raw::c_void,
        newPos: *mut cocos2d_CCPoint,
    );
}
#[doc = " Cardinal Spline path.\nhttp://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCardinalSplineBy {
    pub _base: cocos2d_CCCardinalSplineTo,
    pub m_startPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCardinalSplineBy() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCardinalSplineBy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCardinalSplineBy>(),
        116usize,
        concat!("Size of: ", stringify!(cocos2d_CCCardinalSplineBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCardinalSplineBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCardinalSplineBy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startPosition) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCardinalSplineBy),
            "::",
            stringify!(m_startPosition)
        )
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension\n  @code\n  when thie function bound to js,the input params are changed\n  js:var create(var duration,var pointTable,var tension)\n  @endcode"]
    #[link_name = "\u{1}?create@CCCardinalSplineBy@cocos2d@@SAPAV12@MPAVCCPointArray@2@M@Z"]
    pub fn cocos2d_CCCardinalSplineBy_create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineBy;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??0CCCardinalSplineBy@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCCardinalSplineBy_CCCardinalSplineBy(this: *mut cocos2d_CCCardinalSplineBy);
}
impl cocos2d_CCCardinalSplineBy {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        points: *mut cocos2d_CCPointArray,
        tension: f32,
    ) -> *mut cocos2d_CCCardinalSplineBy {
        cocos2d_CCCardinalSplineBy_create(duration, points, tension)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCardinalSplineBy_CCCardinalSplineBy(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?startWithTarget@CCCardinalSplineBy@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCCardinalSplineBy_startWithTarget(
        this: *mut ::std::os::raw::c_void,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reverse@CCCardinalSplineBy@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCCardinalSplineBy_reverse(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?updatePosition@CCCardinalSplineBy@cocos2d@@UAEXAAVCCPoint@2@@Z"]
    pub fn cocos2d_CCCardinalSplineBy_updatePosition(
        this: *mut ::std::os::raw::c_void,
        newPos: *mut cocos2d_CCPoint,
    );
}
#[doc = " An action that moves the target with a CatmullRom curve to a destination point.\nA Catmull Rom is a Cardinal Spline with a tension of 0.5.\nhttp://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCatmullRomTo {
    pub _base: cocos2d_CCCardinalSplineTo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCatmullRomTo() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCatmullRomTo>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCCatmullRomTo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCatmullRomTo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCatmullRomTo))
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension\n  @code\n  when this function bound to js,the input params are changed\n  js:var create(var dt,var pointTable)\n  @endcode"]
    #[link_name = "\u{1}?create@CCCatmullRomTo@cocos2d@@SAPAV12@MPAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomTo_create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomTo;
}
extern "thiscall" {
    #[doc = " initializes the action with a duration and an array of points\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCatmullRomTo@cocos2d@@QAE_NMPAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomTo_initWithDuration(
        this: *mut cocos2d_CCCatmullRomTo,
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> bool;
}
impl cocos2d_CCCatmullRomTo {
    #[inline]
    pub unsafe fn create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomTo {
        cocos2d_CCCatmullRomTo_create(dt, points)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, dt: f32, points: *mut cocos2d_CCPointArray) -> bool {
        cocos2d_CCCatmullRomTo_initWithDuration(self, dt, points)
    }
}
#[doc = " An action that moves the target with a CatmullRom curve by a certain distance.\nA Catmull Rom is a Cardinal Spline with a tension of 0.5.\nhttp://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline\n@ingroup Actions"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCatmullRomBy {
    pub _base: cocos2d_CCCardinalSplineBy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCatmullRomBy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCatmullRomBy>(),
        116usize,
        concat!("Size of: ", stringify!(cocos2d_CCCatmullRomBy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCatmullRomBy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCatmullRomBy))
    );
}
extern "C" {
    #[doc = " creates an action with a Cardinal Spline array of points and tension\n  @code\n  when this function bound to js,the input params are changed\n  js:var create(var dt,var pointTable)\n  @endcode"]
    #[link_name = "\u{1}?create@CCCatmullRomBy@cocos2d@@SAPAV12@MPAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomBy_create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomBy;
}
extern "thiscall" {
    #[doc = " initializes the action with a duration and an array of points\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?initWithDuration@CCCatmullRomBy@cocos2d@@QAE_NMPAVCCPointArray@2@@Z"]
    pub fn cocos2d_CCCatmullRomBy_initWithDuration(
        this: *mut cocos2d_CCCatmullRomBy,
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> bool;
}
impl cocos2d_CCCatmullRomBy {
    #[inline]
    pub unsafe fn create(
        dt: f32,
        points: *mut cocos2d_CCPointArray,
    ) -> *mut cocos2d_CCCatmullRomBy {
        cocos2d_CCCatmullRomBy_create(dt, points)
    }
    #[inline]
    pub unsafe fn initWithDuration(&mut self, dt: f32, points: *mut cocos2d_CCPointArray) -> bool {
        cocos2d_CCCatmullRomBy_initWithDuration(self, dt, points)
    }
}
extern "C" {
    #[doc = " Returns the Cardinal Spline position for a given set of control points, tension and time"]
    #[link_name = "\u{1}?ccCardinalSplineAt@cocos2d@@YA?AVCCPoint@1@AAV21@000MM@Z"]
    pub fn cocos2d_ccCardinalSplineAt(
        p0: *mut cocos2d_CCPoint,
        p1: *mut cocos2d_CCPoint,
        p2: *mut cocos2d_CCPoint,
        p3: *mut cocos2d_CCPoint,
        tension: f32,
        t: f32,
    ) -> cocos2d_CCPoint;
}
#[doc = " @brief CCAtlasNode is a subclass of CCNode that implements the CCRGBAProtocol and CCTextureProtocol protocol\n\nIt knows how to render a TextureAtlas object.\nIf you are going to render a TextureAtlas consider subclassing CCAtlasNode (or a subclass of CCAtlasNode)\n\nAll features from CCNode are valid, plus the following features:\n- opacity and RGB colors"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAtlasNode {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    #[doc = "! chars per row"]
    pub m_uItemsPerRow: ::std::os::raw::c_uint,
    #[doc = "! chars per column"]
    pub m_uItemsPerColumn: ::std::os::raw::c_uint,
    #[doc = "! width of each char"]
    pub m_uItemWidth: ::std::os::raw::c_uint,
    #[doc = "! height of each char"]
    pub m_uItemHeight: ::std::os::raw::c_uint,
    pub m_tColorUnmodified: cocos2d_ccColor3B,
    pub m_pTextureAtlas: *mut cocos2d_CCTextureAtlas,
    pub m_bIsOpacityModifyRGB: bool,
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    pub m_uQuadsToDraw: ::std::os::raw::c_uint,
    pub m_nUniformColor: GLint,
    pub m_bIgnoreContentScaleFactor: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAtlasNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAtlasNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAtlasNode>(),
        332usize,
        concat!("Size of: ", stringify!(cocos2d_CCAtlasNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAtlasNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAtlasNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uItemsPerRow) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_uItemsPerRow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uItemsPerColumn) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_uItemsPerColumn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uItemWidth) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_uItemWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uItemHeight) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_uItemHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tColorUnmodified) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_tColorUnmodified)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTextureAtlas) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_pTextureAtlas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsOpacityModifyRGB) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_bIsOpacityModifyRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBlendFunc) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_tBlendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uQuadsToDraw) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_uQuadsToDraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUniformColor) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_nUniformColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIgnoreContentScaleFactor) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAtlasNode),
            "::",
            stringify!(m_bIgnoreContentScaleFactor)
        )
    );
}
extern "C" {
    #[doc = " creates a CCAtlasNode  with an Atlas file the width and height of each item and the quantity of items to render"]
    #[link_name = "\u{1}?create@CCAtlasNode@cocos2d@@SAPAV12@PBDIII@Z"]
    pub fn cocos2d_CCAtlasNode_create(
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAtlasNode;
}
extern "thiscall" {
    #[doc = " initializes an CCAtlasNode  with an Atlas file the width and height of each item and the quantity of items to render"]
    #[link_name = "\u{1}?initWithTileFile@CCAtlasNode@cocos2d@@QAE_NPBDIII@Z"]
    pub fn cocos2d_CCAtlasNode_initWithTileFile(
        this: *mut cocos2d_CCAtlasNode,
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes an CCAtlasNode  with a texture the width and height of each item measured in points and the quantity of items to render"]
    #[link_name = "\u{1}?initWithTexture@CCAtlasNode@cocos2d@@QAE_NPAVCCTexture2D@2@III@Z"]
    pub fn cocos2d_CCAtlasNode_initWithTexture(
        this: *mut cocos2d_CCAtlasNode,
        texture: *mut cocos2d_CCTexture2D,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCAtlasNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAtlasNode_CCAtlasNode(this: *mut cocos2d_CCAtlasNode);
}
impl cocos2d_CCAtlasNode {
    #[inline]
    pub unsafe fn create(
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCAtlasNode {
        cocos2d_CCAtlasNode_create(tile, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn initWithTileFile(
        &mut self,
        tile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAtlasNode_initWithTileFile(self, tile, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        tileWidth: ::std::os::raw::c_uint,
        tileHeight: ::std::os::raw::c_uint,
        itemsToRender: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCAtlasNode_initWithTexture(self, texture, tileWidth, tileHeight, itemsToRender)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAtlasNode_CCAtlasNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?getTextureAtlas@CCAtlasNode@cocos2d@@UAEPAVCCTextureAtlas@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getTextureAtlas(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTextureAtlas@CCAtlasNode@cocos2d@@UAEXPAVCCTextureAtlas@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setTextureAtlas(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTextureAtlas,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getBlendFunc@CCAtlasNode@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[link_name = "\u{1}?setBlendFunc@CCAtlasNode@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getQuadsToDraw@CCAtlasNode@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCAtlasNode_getQuadsToDraw(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?setQuadsToDraw@CCAtlasNode@cocos2d@@UAEXI@Z"]
    pub fn cocos2d_CCAtlasNode_setQuadsToDraw(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCAtlasNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAtlasNode_CCAtlasNode_destructor(this: *mut cocos2d_CCAtlasNode);
}
extern "thiscall" {
    #[doc = " updates the Atlas (indexed vertex array).\n Shall be overridden in subclasses"]
    #[link_name = "\u{1}?updateAtlasValues@CCAtlasNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCAtlasNode_updateAtlasValues(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCAtlasNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCAtlasNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the used texture"]
    #[link_name = "\u{1}?getTexture@CCAtlasNode@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " sets a new texture. it will be retained"]
    #[link_name = "\u{1}?setTexture@CCAtlasNode@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCAtlasNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCAtlasNode_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCAtlasNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCAtlasNode_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        isOpacityModifyRGB: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getColor@CCAtlasNode@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCAtlasNode_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setColor@CCAtlasNode@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCAtlasNode_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCAtlasNode@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCAtlasNode_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
#[doc = " @addtogroup base_nodes\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAutoreleasePool {
    pub _base: cocos2d_CCObject,
    pub m_pManagedObjectArray: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCAutoreleasePool() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAutoreleasePool> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAutoreleasePool>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCAutoreleasePool))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAutoreleasePool>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAutoreleasePool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pManagedObjectArray) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAutoreleasePool),
            "::",
            stringify!(m_pManagedObjectArray)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addObject@CCAutoreleasePool@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCAutoreleasePool_addObject(
        this: *mut cocos2d_CCAutoreleasePool,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeObject@CCAutoreleasePool@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCAutoreleasePool_removeObject(
        this: *mut cocos2d_CCAutoreleasePool,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?clear@CCAutoreleasePool@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCAutoreleasePool_clear(this: *mut cocos2d_CCAutoreleasePool);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCAutoreleasePool@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAutoreleasePool_CCAutoreleasePool(this: *mut cocos2d_CCAutoreleasePool);
}
impl cocos2d_CCAutoreleasePool {
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCAutoreleasePool_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCAutoreleasePool_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        cocos2d_CCAutoreleasePool_clear(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAutoreleasePool_CCAutoreleasePool(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCAutoreleasePool@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAutoreleasePool_CCAutoreleasePool_destructor(
        this: *mut cocos2d_CCAutoreleasePool,
    );
}
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCPoolManager {
    pub m_pReleasePoolStack: *mut cocos2d_CCArray,
    pub m_pCurReleasePool: *mut cocos2d_CCAutoreleasePool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPoolManager() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPoolManager> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPoolManager>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCPoolManager))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPoolManager>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPoolManager))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pReleasePoolStack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoolManager),
            "::",
            stringify!(m_pReleasePoolStack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCurReleasePool) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPoolManager),
            "::",
            stringify!(m_pCurReleasePool)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?finalize@CCPoolManager@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCPoolManager_finalize(this: *mut cocos2d_CCPoolManager);
}
extern "thiscall" {
    #[link_name = "\u{1}?push@CCPoolManager@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCPoolManager_push(this: *mut cocos2d_CCPoolManager);
}
extern "thiscall" {
    #[link_name = "\u{1}?pop@CCPoolManager@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCPoolManager_pop(this: *mut cocos2d_CCPoolManager);
}
extern "thiscall" {
    #[link_name = "\u{1}?removeObject@CCPoolManager@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCPoolManager_removeObject(
        this: *mut cocos2d_CCPoolManager,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addObject@CCPoolManager@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCPoolManager_addObject(
        this: *mut cocos2d_CCPoolManager,
        pObject: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?sharedPoolManager@CCPoolManager@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCPoolManager_sharedPoolManager() -> *mut cocos2d_CCPoolManager;
}
extern "C" {
    #[link_name = "\u{1}?purgePoolManager@CCPoolManager@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCPoolManager_purgePoolManager();
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCPoolManager@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCPoolManager_CCPoolManager(this: *mut cocos2d_CCPoolManager);
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCPoolManager@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCPoolManager_CCPoolManager_destructor(this: *mut cocos2d_CCPoolManager);
}
impl cocos2d_CCPoolManager {
    #[inline]
    pub unsafe fn finalize(&mut self) {
        cocos2d_CCPoolManager_finalize(self)
    }
    #[inline]
    pub unsafe fn push(&mut self) {
        cocos2d_CCPoolManager_push(self)
    }
    #[inline]
    pub unsafe fn pop(&mut self) {
        cocos2d_CCPoolManager_pop(self)
    }
    #[inline]
    pub unsafe fn removeObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCPoolManager_removeObject(self, pObject)
    }
    #[inline]
    pub unsafe fn addObject(&mut self, pObject: *mut cocos2d_CCObject) {
        cocos2d_CCPoolManager_addObject(self, pObject)
    }
    #[inline]
    pub unsafe fn sharedPoolManager() -> *mut cocos2d_CCPoolManager {
        cocos2d_CCPoolManager_sharedPoolManager()
    }
    #[inline]
    pub unsafe fn purgePoolManager() {
        cocos2d_CCPoolManager_purgePoolManager()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCPoolManager_CCPoolManager(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCPoolManager_CCPoolManager_destructor(self)
    }
}
#[doc = " @addtogroup data_structures\n @{\n @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCInteger {
    pub _base: cocos2d_CCObject,
    pub m_nValue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCInteger() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCInteger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCInteger>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCInteger>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCInteger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCInteger),
            "::",
            stringify!(m_nValue)
        )
    );
}
#[doc = " @addtogroup data_structures\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFloat {
    pub _base: cocos2d_CCObject,
    pub m_fValue: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCFloat() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFloat>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFloat>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFloat),
            "::",
            stringify!(m_fValue)
        )
    );
}
#[doc = " @addtogroup data_structures\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDouble {
    pub _base: cocos2d_CCObject,
    pub m_dValue: f64,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDouble() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDouble>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dValue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDouble),
            "::",
            stringify!(m_dValue)
        )
    );
}
#[doc = " @addtogroup data_structures\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBool {
    pub _base: cocos2d_CCObject,
    pub m_bValue: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBool() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCBool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBool>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCBool))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBool>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBool),
            "::",
            stringify!(m_bValue)
        )
    );
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics rectangle structure corresponding to the data in a given string.\n@param pszContent   A string object whose contents are of the form \"{{x,y},{w, h}}\",\nwhere x is the x coordinate, y is the y coordinate, w is the width, and h is the height.\nThese components can represent integer or float values.\nAn example of a valid string is \"{{3,2},{4,5}}\".\nThe string is not localized, so items are always separated with a comma.\n@return A Core Graphics structure that represents a rectangle.\nIf the string is not well-formed, the function returns CCRectZero."]
    #[link_name = "\u{1}?CCRectFromString@cocos2d@@YA?AVCCRect@1@PBD@Z"]
    pub fn cocos2d_CCRectFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCRect;
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics point structure corresponding to the data in a given string.\n@param pszContent   A string object whose contents are of the form \"{x,y}\",\nwhere x is the x coordinate and y is the y coordinate.\nThe x and y values can represent integer or float values.\nAn example of a valid string is \"{3.0,2.5}\".\nThe string is not localized, so items are always separated with a comma.\n@return A Core Graphics structure that represents a point.\nIf the string is not well-formed, the function returns CCPointZero."]
    #[link_name = "\u{1}?CCPointFromString@cocos2d@@YA?AVCCPoint@1@PBD@Z"]
    pub fn cocos2d_CCPointFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = "@brief Returns a Core Graphics size structure corresponding to the data in a given string.\n@param pszContent   A string object whose contents are of the form \"{w, h}\",\nwhere w is the width and h is the height.\nThe w and h values can be integer or float values.\nAn example of a valid string is \"{3.0,2.5}\".\nThe string is not localized, so items are always separated with a comma.\n@return A Core Graphics structure that represents a size.\nIf the string is not well-formed, the function returns CCSizeZero."]
    #[link_name = "\u{1}?CCSizeFromString@cocos2d@@YA?AVCCSize@1@PBD@Z"]
    pub fn cocos2d_CCSizeFromString(pszContent: *const ::std::os::raw::c_char) -> cocos2d_CCSize;
}
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCZone {
    pub m_pCopyObject: *mut cocos2d_CCObject,
}
#[test]
fn bindgen_test_layout_cocos2d_CCZone() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCZone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCZone>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCZone))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCZone>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCZone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCopyObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCZone),
            "::",
            stringify!(m_pCopyObject)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCZone@cocos2d@@QAE@PAVCCObject@1@@Z"]
    pub fn cocos2d_CCZone_CCZone(this: *mut cocos2d_CCZone, pObject: *mut cocos2d_CCObject);
}
impl cocos2d_CCZone {
    #[inline]
    pub unsafe fn new(pObject: *mut cocos2d_CCObject) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCZone_CCZone(__bindgen_tmp.as_mut_ptr(), pObject);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Initializes the drawing primitives"]
    #[link_name = "\u{1}?ccDrawInit@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccDrawInit();
}
extern "C" {
    #[doc = " Frees allocated resources by the drawing primitives"]
    #[link_name = "\u{1}?ccDrawFree@cocos2d@@YAXXZ"]
    pub fn cocos2d_ccDrawFree();
}
extern "C" {
    #[doc = " draws a point given x and y coordinate measured in points"]
    #[link_name = "\u{1}?ccDrawPoint@cocos2d@@YAXABVCCPoint@1@@Z"]
    pub fn cocos2d_ccDrawPoint(point: *const cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws an array of points.\n@since v0.7.2"]
    #[link_name = "\u{1}?ccDrawPoints@cocos2d@@YAXPBVCCPoint@1@I@Z"]
    pub fn cocos2d_ccDrawPoints(
        points: *const cocos2d_CCPoint,
        numberOfPoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a line given the origin and destination point measured in points"]
    #[link_name = "\u{1}?ccDrawLine@cocos2d@@YAXABVCCPoint@1@0@Z"]
    pub fn cocos2d_ccDrawLine(origin: *const cocos2d_CCPoint, destination: *const cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws a rectangle given the origin and destination point measured in points."]
    #[link_name = "\u{1}?ccDrawRect@cocos2d@@YAXVCCPoint@1@0@Z"]
    pub fn cocos2d_ccDrawRect(origin: cocos2d_CCPoint, destination: cocos2d_CCPoint);
}
extern "C" {
    #[doc = " draws a solid rectangle given the origin and destination point measured in points.\n@since 1.1"]
    #[link_name = "\u{1}?ccDrawSolidRect@cocos2d@@YAXVCCPoint@1@0U_ccColor4F@1@@Z"]
    pub fn cocos2d_ccDrawSolidRect(
        origin: cocos2d_CCPoint,
        destination: cocos2d_CCPoint,
        color: cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draws a polygon given a pointer to CCPoint coordinates and the number of vertices measured in points.\nThe polygon can be closed or open"]
    #[link_name = "\u{1}?ccDrawPoly@cocos2d@@YAXPBVCCPoint@1@I_N@Z"]
    pub fn cocos2d_ccDrawPoly(
        vertices: *const cocos2d_CCPoint,
        numOfVertices: ::std::os::raw::c_uint,
        closePolygon: bool,
    );
}
extern "C" {
    #[doc = " draws a solid polygon given a pointer to CGPoint coordinates, the number of vertices measured in points, and a color."]
    #[link_name = "\u{1}?ccDrawSolidPoly@cocos2d@@YAXPBVCCPoint@1@IU_ccColor4F@1@@Z"]
    pub fn cocos2d_ccDrawSolidPoly(
        poli: *const cocos2d_CCPoint,
        numberOfPoints: ::std::os::raw::c_uint,
        color: cocos2d_ccColor4F,
    );
}
extern "C" {
    #[doc = " draws a circle given the center, radius and number of segments."]
    #[link_name = "\u{1}?ccDrawCircle@cocos2d@@YAXABVCCPoint@1@MMI_NMM@Z"]
    pub fn cocos2d_ccDrawCircle(
        center: *const cocos2d_CCPoint,
        radius: f32,
        angle: f32,
        segments: ::std::os::raw::c_uint,
        drawLineToCenter: bool,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}?ccDrawCircle@cocos2d@@YAXABVCCPoint@1@MMI_N@Z"]
    pub fn cocos2d_ccDrawCircle1(
        center: *const cocos2d_CCPoint,
        radius: f32,
        angle: f32,
        segments: ::std::os::raw::c_uint,
        drawLineToCenter: bool,
    );
}
extern "C" {
    #[doc = " draws a quad bezier path\n@warning This function could be pretty slow. Use it only for debugging purposes.\n@since v0.8"]
    #[link_name = "\u{1}?ccDrawQuadBezier@cocos2d@@YAXABVCCPoint@1@00I@Z"]
    pub fn cocos2d_ccDrawQuadBezier(
        origin: *const cocos2d_CCPoint,
        control: *const cocos2d_CCPoint,
        destination: *const cocos2d_CCPoint,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a cubic bezier path\n@warning This function could be pretty slow. Use it only for debugging purposes.\n@since v0.8"]
    #[link_name = "\u{1}?ccDrawCubicBezier@cocos2d@@YAXABVCCPoint@1@000I@Z"]
    pub fn cocos2d_ccDrawCubicBezier(
        origin: *const cocos2d_CCPoint,
        control1: *const cocos2d_CCPoint,
        control2: *const cocos2d_CCPoint,
        destination: *const cocos2d_CCPoint,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a Catmull Rom path.\n@warning This function could be pretty slow. Use it only for debugging purposes.\n@since v2.0"]
    #[link_name = "\u{1}?ccDrawCatmullRom@cocos2d@@YAXPAVCCPointArray@1@I@Z"]
    pub fn cocos2d_ccDrawCatmullRom(
        arrayOfControlPoints: *mut cocos2d_CCPointArray,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " draws a Cardinal Spline path.\n@warning This function could be pretty slow. Use it only for debugging purposes.\n@since v2.0"]
    #[link_name = "\u{1}?ccDrawCardinalSpline@cocos2d@@YAXPAVCCPointArray@1@MI@Z"]
    pub fn cocos2d_ccDrawCardinalSpline(
        config: *mut cocos2d_CCPointArray,
        tension: f32,
        segments: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " set the drawing color with 4 unsigned bytes\n@since v2.0"]
    #[link_name = "\u{1}?ccDrawColor4B@cocos2d@@YAXEEEE@Z"]
    pub fn cocos2d_ccDrawColor4B(r: GLubyte, g: GLubyte, b: GLubyte, a: GLubyte);
}
extern "C" {
    #[doc = " set the drawing color with 4 floats\n@since v2.0"]
    #[link_name = "\u{1}?ccDrawColor4F@cocos2d@@YAXMMMM@Z"]
    pub fn cocos2d_ccDrawColor4F(r: GLfloat, g: GLfloat, b: GLfloat, a: GLfloat);
}
extern "C" {
    #[doc = " set the point size in points. Default 1.\n@since v2.0"]
    #[link_name = "\u{1}?ccPointSize@cocos2d@@YAXM@Z"]
    pub fn cocos2d_ccPointSize(pointSize: GLfloat);
}
#[doc = " CCDrawNode\nNode that draws dots, segments and polygons.\nFaster than the \"drawing primitives\" since they it draws everything in one single batch.\n\n@since v2.1\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDrawNode {
    pub _base: cocos2d_CCNode,
    pub m_uVao: GLuint,
    pub m_uVbo: GLuint,
    pub m_uBufferCapacity: ::std::os::raw::c_uint,
    pub m_nBufferCount: GLsizei,
    pub m_pBuffer: *mut cocos2d_ccV2F_C4B_T2F,
    pub m_sBlendFunc: cocos2d_ccBlendFunc,
    pub m_bDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDrawNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDrawNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDrawNode>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCDrawNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDrawNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDrawNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uVao) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uVao)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uVbo) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uVbo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uBufferCapacity) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_uBufferCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBufferCount) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_nBufferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pBuffer) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_pBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sBlendFunc) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_sBlendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDirty) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDrawNode),
            "::",
            stringify!(m_bDirty)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCDrawNode@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCDrawNode_create() -> *mut cocos2d_CCDrawNode;
}
extern "thiscall" {
    #[doc = " draw a dot at a position, with a given radius and color"]
    #[link_name = "\u{1}?drawDot@CCDrawNode@cocos2d@@QAEXABVCCPoint@2@MABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCDrawNode_drawDot(
        this: *mut cocos2d_CCDrawNode,
        pos: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " draw a segment with a radius and color"]
    #[link_name = "\u{1}?drawSegment@CCDrawNode@cocos2d@@QAEXABVCCPoint@2@0MABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCDrawNode_drawSegment(
        this: *mut cocos2d_CCDrawNode,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " draw a polygon with a fill color and line color\n @code\n when this funciton bound to js,the input params are changed\n js:var drawPolygon(var verts, var fillColor,var borderWidth,var borderColor)\n @endcode"]
    #[link_name = "\u{1}?drawPolygon@CCDrawNode@cocos2d@@QAEXPAVCCPoint@2@IABU_ccColor4F@2@M1@Z"]
    pub fn cocos2d_CCDrawNode_drawPolygon(
        this: *mut cocos2d_CCDrawNode,
        verts: *mut cocos2d_CCPoint,
        count: ::std::os::raw::c_uint,
        fillColor: *const cocos2d_ccColor4F,
        borderWidth: f32,
        borderColor: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " Clear the geometry in the node's buffer."]
    #[link_name = "\u{1}?clear@CCDrawNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDrawNode_clear(this: *mut cocos2d_CCDrawNode);
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCDrawNode@cocos2d@@QBE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCDrawNode_getBlendFunc(this: *const cocos2d_CCDrawNode) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[doc = " @code\n when this function bound to js ,the input param is change\n js:var setBlendFunc(var src,var dst)\n @endcode"]
    #[link_name = "\u{1}?setBlendFunc@CCDrawNode@cocos2d@@QAEXABU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCDrawNode_setBlendFunc(
        this: *mut cocos2d_CCDrawNode,
        blendFunc: *const cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " listen the event that coming to foreground on Android\n @js NA"]
    #[link_name = "\u{1}?listenBackToForeground@CCDrawNode@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCDrawNode_listenBackToForeground(
        this: *mut cocos2d_CCDrawNode,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCDrawNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCDrawNode_CCDrawNode(this: *mut cocos2d_CCDrawNode);
}
impl cocos2d_CCDrawNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCDrawNode {
        cocos2d_CCDrawNode_create()
    }
    #[inline]
    pub unsafe fn drawDot(
        &mut self,
        pos: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawDot(self, pos, radius, color)
    }
    #[inline]
    pub unsafe fn drawSegment(
        &mut self,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
        radius: f32,
        color: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawSegment(self, from, to, radius, color)
    }
    #[inline]
    pub unsafe fn drawPolygon(
        &mut self,
        verts: *mut cocos2d_CCPoint,
        count: ::std::os::raw::c_uint,
        fillColor: *const cocos2d_ccColor4F,
        borderWidth: f32,
        borderColor: *const cocos2d_ccColor4F,
    ) {
        cocos2d_CCDrawNode_drawPolygon(self, verts, count, fillColor, borderWidth, borderColor)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        cocos2d_CCDrawNode_clear(self)
    }
    #[inline]
    pub unsafe fn getBlendFunc(&self) -> cocos2d_ccBlendFunc {
        cocos2d_CCDrawNode_getBlendFunc(self)
    }
    #[inline]
    pub unsafe fn setBlendFunc(&mut self, blendFunc: *const cocos2d_ccBlendFunc) {
        cocos2d_CCDrawNode_setBlendFunc(self, blendFunc)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCDrawNode_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDrawNode_CCDrawNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCDrawNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCDrawNode_CCDrawNode_destructor(this: *mut cocos2d_CCDrawNode);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCDrawNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCDrawNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCDrawNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCDrawNode_draw(this: *mut ::std::os::raw::c_void);
}
pub const cocos2d__ccConfigurationType_ConfigurationError: cocos2d__ccConfigurationType = 0;
pub const cocos2d__ccConfigurationType_ConfigurationString: cocos2d__ccConfigurationType = 1;
pub const cocos2d__ccConfigurationType_ConfigurationInt: cocos2d__ccConfigurationType = 2;
pub const cocos2d__ccConfigurationType_ConfigurationDouble: cocos2d__ccConfigurationType = 3;
pub const cocos2d__ccConfigurationType_ConfigurationBoolean: cocos2d__ccConfigurationType = 4;
pub type cocos2d__ccConfigurationType = ::std::os::raw::c_int;
pub use self::cocos2d__ccConfigurationType as cocos2d_ccConfigurationType;
#[doc = " @addtogroup global\n @{\n/\n/**\n@brief CCConfiguration contains some openGL variables\n@since v0.99.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCConfiguration {
    pub _base: cocos2d_CCObject,
    pub m_nMaxTextureSize: GLint,
    pub m_nMaxModelviewStackDepth: GLint,
    pub m_bSupportsPVRTC: bool,
    pub m_bSupportsNPOT: bool,
    pub m_bSupportsBGRA8888: bool,
    pub m_bSupportsDiscardFramebuffer: bool,
    pub m_bSupportsShareableVAO: bool,
    pub m_nMaxSamplesAllowed: GLint,
    pub m_nMaxTextureUnits: GLint,
    pub m_pGlExtensions: *mut ::std::os::raw::c_char,
    pub m_pValueDict: *mut cocos2d_CCDictionary,
}
extern "C" {
    #[link_name = "\u{1}?s_gSharedConfiguration@CCConfiguration@cocos2d@@0PAV12@A"]
    pub static mut cocos2d_CCConfiguration_s_gSharedConfiguration: *mut cocos2d_CCConfiguration;
}
extern "C" {
    #[link_name = "\u{1}?s_sConfigfile@CCConfiguration@cocos2d@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut cocos2d_CCConfiguration_s_sConfigfile: std_string;
}
#[test]
fn bindgen_test_layout_cocos2d_CCConfiguration() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCConfiguration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCConfiguration>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCConfiguration>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCConfiguration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxTextureSize) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxTextureSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxModelviewStackDepth) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxModelviewStackDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSupportsPVRTC) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsPVRTC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSupportsNPOT) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsNPOT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSupportsBGRA8888) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsBGRA8888)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bSupportsDiscardFramebuffer) as usize - ptr as usize
        },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsDiscardFramebuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSupportsShareableVAO) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_bSupportsShareableVAO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxSamplesAllowed) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxSamplesAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMaxTextureUnits) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_nMaxTextureUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pGlExtensions) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_pGlExtensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pValueDict) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCConfiguration),
            "::",
            stringify!(m_pValueDict)
        )
    );
}
extern "C" {
    #[doc = " returns a shared instance of CCConfiguration"]
    #[link_name = "\u{1}?sharedConfiguration@CCConfiguration@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCConfiguration_sharedConfiguration() -> *mut cocos2d_CCConfiguration;
}
extern "C" {
    #[doc = " purge the shared instance of CCConfiguration"]
    #[link_name = "\u{1}?purgeConfiguration@CCConfiguration@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCConfiguration_purgeConfiguration();
}
extern "thiscall" {
    #[doc = " OpenGL Max texture size."]
    #[link_name = "\u{1}?getMaxTextureSize@CCConfiguration@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxTextureSize(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " OpenGL Max Modelview Stack Depth."]
    #[link_name = "\u{1}?getMaxModelviewStackDepth@CCConfiguration@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxModelviewStackDepth(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " returns the maximum texture units\n@since v2.0.0"]
    #[link_name = "\u{1}?getMaxTextureUnits@CCConfiguration@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCConfiguration_getMaxTextureUnits(
        this: *const cocos2d_CCConfiguration,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " Whether or not the GPU supports NPOT (Non Power Of Two) textures.\nOpenGL ES 2.0 already supports NPOT (iOS).\n\n@since v0.99.2"]
    #[link_name = "\u{1}?supportsNPOT@CCConfiguration@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsNPOT(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "thiscall" {
    #[doc = " Whether or not PVR Texture Compressed is supported"]
    #[link_name = "\u{1}?supportsPVRTC@CCConfiguration@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsPVRTC(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "thiscall" {
    #[doc = " Whether or not BGRA8888 textures are supported.\n@since v0.99.2"]
    #[link_name = "\u{1}?supportsBGRA8888@CCConfiguration@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsBGRA8888(this: *const cocos2d_CCConfiguration) -> bool;
}
extern "thiscall" {
    #[doc = " Whether or not glDiscardFramebufferEXT is supported\n@since v0.99.2"]
    #[link_name = "\u{1}?supportsDiscardFramebuffer@CCConfiguration@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsDiscardFramebuffer(
        this: *const cocos2d_CCConfiguration,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Whether or not shareable VAOs are supported.\n@since v2.0.0"]
    #[link_name = "\u{1}?supportsShareableVAO@CCConfiguration@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCConfiguration_supportsShareableVAO(
        this: *const cocos2d_CCConfiguration,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " returns whether or not an OpenGL is supported"]
    #[link_name = "\u{1}?checkForGLExtension@CCConfiguration@cocos2d@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCConfiguration_checkForGLExtension(
        this: *const cocos2d_CCConfiguration,
        searchName: *const std_string,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCConfiguration@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCConfiguration_init(this: *mut cocos2d_CCConfiguration) -> bool;
}
extern "thiscall" {
    #[doc = " returns the value of a given key as a string.\nIf the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getCString@CCConfiguration@cocos2d@@QBEPBDPBD0@Z"]
    pub fn cocos2d_CCConfiguration_getCString(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " returns the value of a given key as a boolean.\nIf the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getBool@CCConfiguration@cocos2d@@QBE_NPBD_N@Z"]
    pub fn cocos2d_CCConfiguration_getBool(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " returns the value of a given key as a double.\nIf the key is not found, it will return the default value"]
    #[link_name = "\u{1}?getNumber@CCConfiguration@cocos2d@@QBENPBDN@Z"]
    pub fn cocos2d_CCConfiguration_getNumber(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        default_value: f64,
    ) -> f64;
}
extern "thiscall" {
    #[doc = " returns the value of a given key as a double"]
    #[link_name = "\u{1}?getObject@CCConfiguration@cocos2d@@QBEPAVCCObject@2@PBD@Z"]
    pub fn cocos2d_CCConfiguration_getObject(
        this: *const cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[doc = " sets a new key/value pair  in the configuration dictionary"]
    #[link_name = "\u{1}?setObject@CCConfiguration@cocos2d@@QAEXPBDPAVCCObject@2@@Z"]
    pub fn cocos2d_CCConfiguration_setObject(
        this: *mut cocos2d_CCConfiguration,
        key: *const ::std::os::raw::c_char,
        value: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " dumps the current configuration on the console"]
    #[link_name = "\u{1}?dumpInfo@CCConfiguration@cocos2d@@QBEXXZ"]
    pub fn cocos2d_CCConfiguration_dumpInfo(this: *const cocos2d_CCConfiguration);
}
extern "thiscall" {
    #[doc = " gathers OpenGL / GPU information"]
    #[link_name = "\u{1}?gatherGPUInfo@CCConfiguration@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCConfiguration_gatherGPUInfo(this: *mut cocos2d_CCConfiguration);
}
extern "thiscall" {
    #[doc = " Loads a config file. If the keys are already present, then they are going to be replaced. Otherwise the new keys are added."]
    #[link_name = "\u{1}?loadConfigFile@CCConfiguration@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCConfiguration_loadConfigFile(
        this: *mut cocos2d_CCConfiguration,
        filename: *const ::std::os::raw::c_char,
    );
}
impl cocos2d_CCConfiguration {
    #[inline]
    pub unsafe fn sharedConfiguration() -> *mut cocos2d_CCConfiguration {
        cocos2d_CCConfiguration_sharedConfiguration()
    }
    #[inline]
    pub unsafe fn purgeConfiguration() {
        cocos2d_CCConfiguration_purgeConfiguration()
    }
    #[inline]
    pub unsafe fn getMaxTextureSize(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxTextureSize(self)
    }
    #[inline]
    pub unsafe fn getMaxModelviewStackDepth(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxModelviewStackDepth(self)
    }
    #[inline]
    pub unsafe fn getMaxTextureUnits(&self) -> ::std::os::raw::c_int {
        cocos2d_CCConfiguration_getMaxTextureUnits(self)
    }
    #[inline]
    pub unsafe fn supportsNPOT(&self) -> bool {
        cocos2d_CCConfiguration_supportsNPOT(self)
    }
    #[inline]
    pub unsafe fn supportsPVRTC(&self) -> bool {
        cocos2d_CCConfiguration_supportsPVRTC(self)
    }
    #[inline]
    pub unsafe fn supportsBGRA8888(&self) -> bool {
        cocos2d_CCConfiguration_supportsBGRA8888(self)
    }
    #[inline]
    pub unsafe fn supportsDiscardFramebuffer(&self) -> bool {
        cocos2d_CCConfiguration_supportsDiscardFramebuffer(self)
    }
    #[inline]
    pub unsafe fn supportsShareableVAO(&self) -> bool {
        cocos2d_CCConfiguration_supportsShareableVAO(self)
    }
    #[inline]
    pub unsafe fn checkForGLExtension(&self, searchName: *const std_string) -> bool {
        cocos2d_CCConfiguration_checkForGLExtension(self, searchName)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCConfiguration_init(self)
    }
    #[inline]
    pub unsafe fn getCString(
        &self,
        key: *const ::std::os::raw::c_char,
        default_value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char {
        cocos2d_CCConfiguration_getCString(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getBool(&self, key: *const ::std::os::raw::c_char, default_value: bool) -> bool {
        cocos2d_CCConfiguration_getBool(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getNumber(&self, key: *const ::std::os::raw::c_char, default_value: f64) -> f64 {
        cocos2d_CCConfiguration_getNumber(self, key, default_value)
    }
    #[inline]
    pub unsafe fn getObject(&self, key: *const ::std::os::raw::c_char) -> *mut cocos2d_CCObject {
        cocos2d_CCConfiguration_getObject(self, key)
    }
    #[inline]
    pub unsafe fn setObject(
        &mut self,
        key: *const ::std::os::raw::c_char,
        value: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCConfiguration_setObject(self, key, value)
    }
    #[inline]
    pub unsafe fn dumpInfo(&self) {
        cocos2d_CCConfiguration_dumpInfo(self)
    }
    #[inline]
    pub unsafe fn gatherGPUInfo(&mut self) {
        cocos2d_CCConfiguration_gatherGPUInfo(self)
    }
    #[inline]
    pub unsafe fn loadConfigFile(&mut self, filename: *const ::std::os::raw::c_char) {
        cocos2d_CCConfiguration_loadConfigFile(self, filename)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCConfiguration@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCConfiguration_CCConfiguration_destructor(this: *mut cocos2d_CCConfiguration);
}
#[doc = " FBO class that grabs the the contents of the screen\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrabber {
    pub _base: cocos2d_CCObject,
    pub m_FBO: GLuint,
    pub m_oldFBO: GLint,
    pub m_oldClearColor: [GLfloat; 4usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrabber() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCGrabber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrabber>(),
        76usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrabber))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrabber>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrabber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_FBO) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_FBO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_oldFBO) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_oldFBO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_oldClearColor) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrabber),
            "::",
            stringify!(m_oldClearColor)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?grab@CCGrabber@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_grab(this: *mut cocos2d_CCGrabber, pTexture: *mut cocos2d_CCTexture2D);
}
extern "thiscall" {
    #[link_name = "\u{1}?beforeRender@CCGrabber@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_beforeRender(
        this: *mut cocos2d_CCGrabber,
        pTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?afterRender@CCGrabber@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCGrabber_afterRender(
        this: *mut cocos2d_CCGrabber,
        pTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCGrabber@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCGrabber_CCGrabber(this: *mut cocos2d_CCGrabber);
}
impl cocos2d_CCGrabber {
    #[inline]
    pub unsafe fn grab(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_grab(self, pTexture)
    }
    #[inline]
    pub unsafe fn beforeRender(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_beforeRender(self, pTexture)
    }
    #[inline]
    pub unsafe fn afterRender(&mut self, pTexture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCGrabber_afterRender(self, pTexture)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGrabber_CCGrabber(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCGrabber@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCGrabber_CCGrabber_destructor(this: *mut cocos2d_CCGrabber);
}
#[doc = "A CCCamera is used in every CCNode.\nUseful to look at the object from different views.\nThe OpenGL gluLookAt() function is used to locate the\ncamera.\n\nIf the object is transformed by any of the scale, rotation or\nposition attributes, then they will override the camera.\n\nIMPORTANT: Either your use the camera or the rotation/scale/position properties. You can't use both.\nWorld coordinates won't work if you use the camera.\n\nLimitations:\n\n- Some nodes, like CCParallaxNode, CCParticle uses world node coordinates, and they won't work properly if you move them (or any of their ancestors)\nusing the camera.\n\n- It doesn't work on batched nodes like CCSprite objects when they are parented to a CCSpriteBatchNode object.\n\n- It is recommended to use it ONLY if you are going to create 3D effects. For 2D effects, use the action CCFollow or position/scale/rotate."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCCamera {
    pub _base: cocos2d_CCObject,
    pub m_fEyeX: f32,
    pub m_fEyeY: f32,
    pub m_fEyeZ: f32,
    pub m_fCenterX: f32,
    pub m_fCenterY: f32,
    pub m_fCenterZ: f32,
    pub m_fUpX: f32,
    pub m_fUpY: f32,
    pub m_fUpZ: f32,
    pub m_bDirty: bool,
    pub m_lookupMatrix: kmMat4,
}
#[test]
fn bindgen_test_layout_cocos2d_CCCamera() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCCamera> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCCamera>(),
        156usize,
        concat!("Size of: ", stringify!(cocos2d_CCCamera))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCCamera>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCCamera))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeX) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeY) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEyeZ) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fEyeZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterX) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterY) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fCenterZ) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fCenterZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpX) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpY) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fUpZ) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_fUpZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDirty) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_bDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lookupMatrix) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCCamera),
            "::",
            stringify!(m_lookupMatrix)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCCamera@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCCamera_init(this: *mut cocos2d_CCCamera);
}
extern "thiscall" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?description@CCCamera@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCCamera_description(
        this: *mut cocos2d_CCCamera,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " sets the camera in the default position"]
    #[link_name = "\u{1}?restore@CCCamera@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCCamera_restore(this: *mut cocos2d_CCCamera);
}
extern "thiscall" {
    #[doc = " Sets the camera using gluLookAt using its eye, center and up_vector"]
    #[link_name = "\u{1}?locate@CCCamera@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCCamera_locate(this: *mut cocos2d_CCCamera);
}
extern "thiscall" {
    #[doc = " sets the eye values in points\n  @js setEye"]
    #[link_name = "\u{1}?setEyeXYZ@CCCamera@cocos2d@@QAEXMMM@Z"]
    pub fn cocos2d_CCCamera_setEyeXYZ(
        this: *mut cocos2d_CCCamera,
        fEyeX: f32,
        fEyeY: f32,
        fEyeZ: f32,
    );
}
extern "thiscall" {
    #[doc = " sets the center values in points\n  @js setCenter"]
    #[link_name = "\u{1}?setCenterXYZ@CCCamera@cocos2d@@QAEXMMM@Z"]
    pub fn cocos2d_CCCamera_setCenterXYZ(
        this: *mut cocos2d_CCCamera,
        fCenterX: f32,
        fCenterY: f32,
        fCenterZ: f32,
    );
}
extern "thiscall" {
    #[doc = " sets the up values\n  @js setUp"]
    #[link_name = "\u{1}?setUpXYZ@CCCamera@cocos2d@@QAEXMMM@Z"]
    pub fn cocos2d_CCCamera_setUpXYZ(this: *mut cocos2d_CCCamera, fUpX: f32, fUpY: f32, fUpZ: f32);
}
extern "thiscall" {
    #[doc = " get the eye vector values in points\n  @js NA"]
    #[link_name = "\u{1}?getEyeXYZ@CCCamera@cocos2d@@QAEXPAM00@Z"]
    pub fn cocos2d_CCCamera_getEyeXYZ(
        this: *mut cocos2d_CCCamera,
        pEyeX: *mut f32,
        pEyeY: *mut f32,
        pEyeZ: *mut f32,
    );
}
extern "thiscall" {
    #[doc = " get the center vector values int points\n  @js NA"]
    #[link_name = "\u{1}?getCenterXYZ@CCCamera@cocos2d@@QAEXPAM00@Z"]
    pub fn cocos2d_CCCamera_getCenterXYZ(
        this: *mut cocos2d_CCCamera,
        pCenterX: *mut f32,
        pCenterY: *mut f32,
        pCenterZ: *mut f32,
    );
}
extern "thiscall" {
    #[doc = " get the up vector values\n  @js NA"]
    #[link_name = "\u{1}?getUpXYZ@CCCamera@cocos2d@@QAEXPAM00@Z"]
    pub fn cocos2d_CCCamera_getUpXYZ(
        this: *mut cocos2d_CCCamera,
        pUpX: *mut f32,
        pUpY: *mut f32,
        pUpZ: *mut f32,
    );
}
extern "C" {
    #[doc = " returns the Z eye"]
    #[link_name = "\u{1}?getZEye@CCCamera@cocos2d@@SAMXZ"]
    pub fn cocos2d_CCCamera_getZEye() -> f32;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCCamera@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCCamera_CCCamera(this: *mut cocos2d_CCCamera);
}
impl cocos2d_CCCamera {
    #[inline]
    pub unsafe fn init(&mut self) {
        cocos2d_CCCamera_init(self)
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCCamera_description(self)
    }
    #[inline]
    pub unsafe fn restore(&mut self) {
        cocos2d_CCCamera_restore(self)
    }
    #[inline]
    pub unsafe fn locate(&mut self) {
        cocos2d_CCCamera_locate(self)
    }
    #[inline]
    pub unsafe fn setEyeXYZ(&mut self, fEyeX: f32, fEyeY: f32, fEyeZ: f32) {
        cocos2d_CCCamera_setEyeXYZ(self, fEyeX, fEyeY, fEyeZ)
    }
    #[inline]
    pub unsafe fn setCenterXYZ(&mut self, fCenterX: f32, fCenterY: f32, fCenterZ: f32) {
        cocos2d_CCCamera_setCenterXYZ(self, fCenterX, fCenterY, fCenterZ)
    }
    #[inline]
    pub unsafe fn setUpXYZ(&mut self, fUpX: f32, fUpY: f32, fUpZ: f32) {
        cocos2d_CCCamera_setUpXYZ(self, fUpX, fUpY, fUpZ)
    }
    #[inline]
    pub unsafe fn getEyeXYZ(&mut self, pEyeX: *mut f32, pEyeY: *mut f32, pEyeZ: *mut f32) {
        cocos2d_CCCamera_getEyeXYZ(self, pEyeX, pEyeY, pEyeZ)
    }
    #[inline]
    pub unsafe fn getCenterXYZ(
        &mut self,
        pCenterX: *mut f32,
        pCenterY: *mut f32,
        pCenterZ: *mut f32,
    ) {
        cocos2d_CCCamera_getCenterXYZ(self, pCenterX, pCenterY, pCenterZ)
    }
    #[inline]
    pub unsafe fn getUpXYZ(&mut self, pUpX: *mut f32, pUpY: *mut f32, pUpZ: *mut f32) {
        cocos2d_CCCamera_getUpXYZ(self, pUpX, pUpY, pUpZ)
    }
    #[inline]
    pub unsafe fn getZEye() -> f32 {
        cocos2d_CCCamera_getZEye()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCCamera_CCCamera(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCCamera@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCCamera_CCCamera_destructor(this: *mut cocos2d_CCCamera);
}
#[doc = " @brief CCLabelAtlas is a subclass of CCAtlasNode.\n\nIt can be as a replacement of CCLabel since it is MUCH faster.\n\nCCLabelAtlas versus CCLabel:\n- CCLabelAtlas is MUCH faster than CCLabel\n- CCLabelAtlas \"characters\" have a fixed height and width\n- CCLabelAtlas \"characters\" can be anything you want since they are taken from an image file\n\nA more flexible class is CCLabelBMFont. It supports variable width characters and it also has a nice editor."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelAtlas {
    pub _base: cocos2d_CCAtlasNode,
    pub _base_1: cocos2d_CCLabelProtocol,
    pub m_sString: std_string,
    pub m_uMapStartChar: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelAtlas() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLabelAtlas> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelAtlas>(),
        364usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelAtlas>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelAtlas))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sString) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelAtlas),
            "::",
            stringify!(m_sString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMapStartChar) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelAtlas),
            "::",
            stringify!(m_uMapStartChar)
        )
    );
}
extern "C" {
    #[doc = " creates the CCLabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?create@CCLabelAtlas@cocos2d@@SAPAV12@PBD0III@Z"]
    pub fn cocos2d_CCLabelAtlas_create(
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCLabelAtlas;
}
extern "C" {
    #[doc = " creates the CCLabelAtlas with a string and a configuration file\n@since v2.0\n@js _create"]
    #[link_name = "\u{1}?create@CCLabelAtlas@cocos2d@@SAPAV12@PBD0@Z"]
    pub fn cocos2d_CCLabelAtlas_create1(
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelAtlas;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QAE_NPBD0III@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelAtlas with a string and a configuration file\n@since v2.0"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QAE_NPBD0@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString1(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelAtlas with a string, a texture, the width and height in points of each element and the starting char of the atlas"]
    #[link_name = "\u{1}?initWithString@CCLabelAtlas@cocos2d@@QAE_NPBDPAVCCTexture2D@2@III@Z"]
    pub fn cocos2d_CCLabelAtlas_initWithString2(
        this: *mut cocos2d_CCLabelAtlas,
        string: *const ::std::os::raw::c_char,
        texture: *mut cocos2d_CCTexture2D,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool;
}
impl cocos2d_CCLabelAtlas {
    #[inline]
    pub unsafe fn create(
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCLabelAtlas {
        cocos2d_CCLabelAtlas_create(string, charMapFile, itemWidth, itemHeight, startCharMap)
    }
    #[inline]
    pub unsafe fn create1(
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelAtlas {
        cocos2d_CCLabelAtlas_create1(string, fntFile)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        string: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString(
            self,
            string,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
        )
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString1(self, string, fntFile)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        string: *const ::std::os::raw::c_char,
        texture: *mut cocos2d_CCTexture2D,
        itemWidth: ::std::os::raw::c_uint,
        itemHeight: ::std::os::raw::c_uint,
        startCharMap: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCLabelAtlas_initWithString2(
            self,
            string,
            texture,
            itemWidth,
            itemHeight,
            startCharMap,
        )
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?updateAtlasValues@CCLabelAtlas@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLabelAtlas_updateAtlasValues(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setString@CCLabelAtlas@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCLabelAtlas_setString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getString@CCLabelAtlas@cocos2d@@UAEPBDXZ"]
    pub fn cocos2d_CCLabelAtlas_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " sets a 2D projection (orthogonal projection)"]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjection2D: cocos2d_ccDirectorProjection = 0;
#[doc = " sets a 3D projection with a fovy=60, znear=0.5f and zfar=1500."]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjection3D: cocos2d_ccDirectorProjection = 1;
#[doc = " it calls \"updateProjection\" on the projection delegate."]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjectionCustom: cocos2d_ccDirectorProjection =
    2;
#[doc = " Default projection is 3D projection"]
pub const cocos2d_ccDirectorProjection_kCCDirectorProjectionDefault: cocos2d_ccDirectorProjection =
    1;
#[doc = " @typedef ccDirectorProjection\nPossible OpenGL projections used by director"]
pub type cocos2d_ccDirectorProjection = ::std::os::raw::c_int;
pub const cocos2d_TextureQuality_kTextureQualityLow: cocos2d_TextureQuality = 1;
pub const cocos2d_TextureQuality_kTextureQualityMedium: cocos2d_TextureQuality = 2;
pub const cocos2d_TextureQuality_kTextureQualityHigh: cocos2d_TextureQuality = 3;
pub type cocos2d_TextureQuality = ::std::os::raw::c_int;
pub const cocos2d_PopTransition_kPopTransitionFade: cocos2d_PopTransition = 0;
pub const cocos2d_PopTransition_kPopTransitionMoveInT: cocos2d_PopTransition = 1;
pub type cocos2d_PopTransition = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSceneDelegate {
    _unused: [u8; 0],
}
#[doc = "@brief Class that creates and handle the main Window and manages how\nand when to execute the Scenes.\n\nThe CCDirector is also responsible for:\n- initializing the OpenGL context\n- setting the OpenGL pixel format (default on is RGB565)\n- setting the OpenGL buffer depth (default one is 0-bit)\n- setting the projection (default one is 3D)\n- setting the orientation (default one is Portrait)\n\nSince the CCDirector is a singleton, the standard way to use it is by calling:\n_ CCDirector::sharedDirector()->methodName();\n\nThe CCDirector also sets the default OpenGL context:\n- GL_TEXTURE_2D is enabled\n- GL_VERTEX_ARRAY is enabled\n- GL_COLOR_ARRAY is enabled\n- GL_TEXTURE_COORD_ARRAY is enabled"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDirector {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_TypeInfo,
    pub m_fScreenScaleFactor: f32,
    pub m_fScreenScaleFactorMax: f32,
    pub m_fScreenScaleFactorW: f32,
    pub m_fScreenScaleFactorH: f32,
    pub m_fScreenTop: f32,
    pub m_fScreenBottom: f32,
    pub m_fScreenLeft: f32,
    pub m_fScreenRight: f32,
    pub m_pSceneReference: *mut cocos2d_CCScene,
    #[doc = " CCScheduler associated with this director\n@since v2.0"]
    pub m_pScheduler: *mut cocos2d_CCScheduler,
    #[doc = " CCActionManager associated with this director\n@since v2.0"]
    pub m_pActionManager: *mut cocos2d_CCActionManager,
    #[doc = " CCTouchDispatcher associated with this director\n@since v2.0"]
    pub m_pTouchDispatcher: *mut cocos2d_CCTouchDispatcher,
    #[doc = " CCKeypadDispatcher associated with this director\n@since v2.0"]
    pub m_pKeypadDispatcher: *mut cocos2d_CCKeypadDispatcher,
    pub m_pKeyboardDispatcher: *mut cocos2d_CCKeyboardDispatcher,
    pub m_pMouseDispatcher: *mut cocos2d_CCMouseDispatcher,
    #[doc = " CCAccelerometer associated with this director\n@since v2.0\n@js NA\n@lua NA"]
    pub m_pAccelerometer: *mut cocos2d_CCAccelerometer,
    pub m_fDeltaTime: f32,
    pub m_fActualDeltaTime: f32,
    pub m_bIsTransitioning: bool,
    pub m_bSmoothFix: bool,
    pub m_bSmoothFixCheck: bool,
    pub m_bForceSmoothFix: bool,
    pub m_nSmoothFixCounter: ::std::os::raw::c_int,
    pub m_bPurgeDirecotorInNextLoop: bool,
    pub m_pobOpenGLView: *mut cocos2d_CCEGLView,
    pub pad465: [::std::os::raw::c_char; 4usize],
    pub m_dAnimationInterval: f64,
    pub m_dOldAnimationInterval: f64,
    pub m_bLandscape: bool,
    pub m_bDisplayStats: bool,
    pub m_fAccumDt: f32,
    pub m_fFrameRate: f32,
    pub m_pFPSLabel: *mut cocos2d_CCLabelAtlas,
    pub m_pSPFLabel: *mut cocos2d_CCLabelAtlas,
    pub m_pDrawsLabel: *mut cocos2d_CCLabelAtlas,
    #[doc = " Whether or not the Director is paused"]
    pub m_bPaused: bool,
    pub m_uTotalFrames: ::std::os::raw::c_uint,
    pub m_uFrames: ::std::os::raw::c_uint,
    pub m_fSecondsPerFrame: f32,
    pub m_pRunningScene: *mut cocos2d_CCScene,
    pub m_pNextScene: *mut cocos2d_CCScene,
    pub m_bSendCleanupToScene: bool,
    pub m_pobScenesStack: *mut cocos2d_CCArray,
    pub m_pLastUpdate: *mut cocos2d_cc_timeval,
    pub m_bNextDeltaTimeZero: bool,
    pub m_eProjection: cocos2d_ccDirectorProjection,
    pub m_obWinSizeInPoints: cocos2d_CCSize,
    pub m_fContentScaleFactor: f32,
    pub m_pszFPS: *mut ::std::os::raw::c_char,
    pub m_pNotificationNode: *mut cocos2d_CCNode,
    pub m_pProjectionDelegate: *mut cocos2d_CCDirectorDelegate,
    pub m_pAppDelegate: *mut cocos2d_CCSceneDelegate,
    pub m_obScaleFactor: cocos2d_CCSize,
    pub m_obResolutionInPixels: cocos2d_CCSize,
    pub m_eTextureQuality: cocos2d_TextureQuality,
    pub m_bDontCallWillSwitch: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDirector() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDirector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDirector>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCDirector))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDirector>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDirector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenScaleFactor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenScaleFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenScaleFactorMax) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenScaleFactorMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenScaleFactorW) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenScaleFactorW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenScaleFactorH) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenScaleFactorH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenTop) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenTop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenBottom) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenBottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenLeft) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenLeft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScreenRight) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fScreenRight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSceneReference) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pSceneReference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScheduler) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pScheduler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pActionManager) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pActionManager)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTouchDispatcher) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pTouchDispatcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pKeypadDispatcher) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pKeypadDispatcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pKeyboardDispatcher) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pKeyboardDispatcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pMouseDispatcher) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pMouseDispatcher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAccelerometer) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pAccelerometer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDeltaTime) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fDeltaTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fActualDeltaTime) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fActualDeltaTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsTransitioning) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bIsTransitioning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSmoothFix) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bSmoothFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSmoothFixCheck) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bSmoothFixCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bForceSmoothFix) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bForceSmoothFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nSmoothFixCounter) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_nSmoothFixCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPurgeDirecotorInNextLoop) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bPurgeDirecotorInNextLoop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobOpenGLView) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pobOpenGLView)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad465) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(pad465)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dAnimationInterval) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_dAnimationInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dOldAnimationInterval) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_dOldAnimationInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLandscape) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bLandscape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDisplayStats) as usize - ptr as usize },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bDisplayStats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAccumDt) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fAccumDt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrameRate) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fFrameRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFPSLabel) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pFPSLabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSPFLabel) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pSPFLabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDrawsLabel) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pDrawsLabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPaused) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bPaused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTotalFrames) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_uTotalFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uFrames) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_uFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fSecondsPerFrame) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fSecondsPerFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pRunningScene) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pRunningScene)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pNextScene) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pNextScene)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSendCleanupToScene) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bSendCleanupToScene)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobScenesStack) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pobScenesStack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLastUpdate) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pLastUpdate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bNextDeltaTimeZero) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bNextDeltaTimeZero)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eProjection) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_eProjection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obWinSizeInPoints) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_obWinSizeInPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fContentScaleFactor) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_fContentScaleFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pszFPS) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pszFPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pNotificationNode) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pNotificationNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProjectionDelegate) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pProjectionDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAppDelegate) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_pAppDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obScaleFactor) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_obScaleFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obResolutionInPixels) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_obResolutionInPixels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eTextureQuality) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_eTextureQuality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDontCallWillSwitch) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDirector),
            "::",
            stringify!(m_bDontCallWillSwitch)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpenGLView@CCDirector@cocos2d@@QAEXPAVCCEGLView@2@@Z"]
    pub fn cocos2d_CCDirector_setOpenGLView(
        this: *mut cocos2d_CCDirector,
        pobOpenGLView: *mut cocos2d_CCEGLView,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setNextDeltaTimeZero@CCDirector@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCDirector_setNextDeltaTimeZero(
        this: *mut cocos2d_CCDirector,
        bNextDeltaTimeZero: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setProjection@CCDirector@cocos2d@@QAEXW4ccDirectorProjection@2@@Z"]
    pub fn cocos2d_CCDirector_setProjection(
        this: *mut cocos2d_CCDirector,
        kProjection: cocos2d_ccDirectorProjection,
    );
}
extern "thiscall" {
    #[doc = " reshape projection matrix when canvas has been change\""]
    #[link_name = "\u{1}?reshapeProjection@CCDirector@cocos2d@@QAEXABVCCSize@2@@Z"]
    pub fn cocos2d_CCDirector_reshapeProjection(
        this: *mut cocos2d_CCDirector,
        newWindowSize: *const cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[doc = " Sets the glViewport"]
    #[link_name = "\u{1}?setViewport@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_setViewport(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " This object will be visited after the main scene is visited.\nThis object MUST implement the \"visit\" selector.\nUseful to hook a notification object, like CCNotifications (http://github.com/manucorporat/CCNotifications)\n@since v0.99.5"]
    #[link_name = "\u{1}?getNotificationNode@CCDirector@cocos2d@@QAEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCDirector_getNotificationNode(
        this: *mut cocos2d_CCDirector,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[link_name = "\u{1}?setNotificationNode@CCDirector@cocos2d@@QAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCDirector_setNotificationNode(
        this: *mut cocos2d_CCDirector,
        node: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " CCDirector delegate. It shall implemente the CCDirectorDelegate protocol\n@since v0.99.5"]
    #[link_name = "\u{1}?getDelegate@CCDirector@cocos2d@@QBEPAVCCDirectorDelegate@2@XZ"]
    pub fn cocos2d_CCDirector_getDelegate(
        this: *const cocos2d_CCDirector,
    ) -> *mut cocos2d_CCDirectorDelegate;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCDirector@cocos2d@@QAEXPAVCCDirectorDelegate@2@@Z"]
    pub fn cocos2d_CCDirector_setDelegate(
        this: *mut cocos2d_CCDirector,
        pDelegate: *mut cocos2d_CCDirectorDelegate,
    );
}
extern "thiscall" {
    #[doc = " returns the size of the OpenGL view in points."]
    #[link_name = "\u{1}?getWinSize@CCDirector@cocos2d@@QAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getWinSize(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " returns the size of the OpenGL view in pixels."]
    #[link_name = "\u{1}?getWinSizeInPixels@CCDirector@cocos2d@@QAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getWinSizeInPixels(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " returns visible size of the OpenGL view in points.\n  the value is equal to getWinSize if don't invoke\n  CCEGLView::setDesignResolutionSize()"]
    #[link_name = "\u{1}?getVisibleSize@CCDirector@cocos2d@@QAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCDirector_getVisibleSize(this: *mut cocos2d_CCDirector) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " returns visible origin of the OpenGL view in points."]
    #[link_name = "\u{1}?getVisibleOrigin@CCDirector@cocos2d@@QAE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCDirector_getVisibleOrigin(this: *mut cocos2d_CCDirector) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " converts a UIKit coordinate to an OpenGL coordinate\nUseful to convert (multi) touch coordinates to the current layout (portrait or landscape)"]
    #[link_name = "\u{1}?convertToGL@CCDirector@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCDirector_convertToGL(
        this: *mut cocos2d_CCDirector,
        obPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " converts an OpenGL coordinate to a UIKit coordinate\nUseful to convert node points to window points for calls such as glScissor"]
    #[link_name = "\u{1}?convertToUI@CCDirector@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCDirector_convertToUI(
        this: *mut cocos2d_CCDirector,
        obPoint: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " XXX: missing description"]
    #[link_name = "\u{1}?getZEye@CCDirector@cocos2d@@QAEMXZ"]
    pub fn cocos2d_CCDirector_getZEye(this: *mut cocos2d_CCDirector) -> f32;
}
extern "thiscall" {
    #[doc = " Enters the Director's main loop with the given Scene.\n Call it to run only your FIRST scene.\n Don't call it if there is already a running scene.\n\n It will call pushScene: and then it will call startAnimation"]
    #[link_name = "\u{1}?runWithScene@CCDirector@cocos2d@@QAEXPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_runWithScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?pushScene@CCDirector@cocos2d@@QAE_NPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_pushScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Pops out a scene from the queue.\n This scene will replace the running one.\n The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.\n ONLY call it if there is a running scene."]
    #[link_name = "\u{1}?popScene@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_popScene(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Pops out all scenes from the queue until the root scene in the queue.\n This scene will replace the running one.\n Internally it will call `popToSceneStackLevel(1)`"]
    #[link_name = "\u{1}?popToRootScene@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_popToRootScene(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Pops out all scenes from the queue until it reaches `level`.\nIf level is 0, it will end the director.\nIf level is 1, it will pop all scenes until it reaches to root scene.\nIf level is <= than the current stack level, it won't do anything."]
    #[link_name = "\u{1}?popToSceneStackLevel@CCDirector@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCDirector_popToSceneStackLevel(
        this: *mut cocos2d_CCDirector,
        level: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?replaceScene@CCDirector@cocos2d@@QAE_NPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_replaceScene(
        this: *mut cocos2d_CCDirector,
        pScene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Ends the execution, releases the running scene.\nIt doesn't remove the OpenGL view from its parent. You have to do it manually."]
    #[link_name = "\u{1}?end@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_end(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Pauses the running scene.\nThe running scene will be _drawed_ but all scheduled timers will be paused\nWhile paused, the draw rate will be 4 FPS to reduce CPU consumption"]
    #[link_name = "\u{1}?pause@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_pause(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Resumes the paused scene\nThe scheduled timers will be activated again.\nThe \"delta time\" will be 0 (as if the game wasn't paused)"]
    #[link_name = "\u{1}?resume@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_resume(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Draw the scene.\nThis method is called every frame. Don't call it manually."]
    #[link_name = "\u{1}?drawScene@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_drawScene(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " Removes cached all cocos2d cached data.\nIt will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache\n@since v0.99.3"]
    #[link_name = "\u{1}?purgeCachedData@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_purgeCachedData(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " sets the default values based on the CCConfiguration info"]
    #[link_name = "\u{1}?setDefaultValues@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_setDefaultValues(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " sets the OpenGL default values"]
    #[link_name = "\u{1}?setGLDefaultValues@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_setGLDefaultValues(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = " enables/disables OpenGL alpha blending"]
    #[link_name = "\u{1}?setAlphaBlending@CCDirector@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCDirector_setAlphaBlending(this: *mut cocos2d_CCDirector, bOn: bool);
}
extern "thiscall" {
    #[doc = " enables/disables OpenGL depth test"]
    #[link_name = "\u{1}?setDepthTest@CCDirector@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCDirector_setDepthTest(this: *mut cocos2d_CCDirector, bOn: bool);
}
extern "thiscall" {
    #[doc = " The size in pixels of the surface. It could be different than the screen size.\nHigh-res devices might have a higher surface size than the screen size.\nOnly available when compiled using SDK >= 4.0.\n@since v0.99.4"]
    #[link_name = "\u{1}?setContentScaleFactor@CCDirector@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCDirector_setContentScaleFactor(
        this: *mut cocos2d_CCDirector,
        scaleFactor: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getContentScaleFactor@CCDirector@cocos2d@@QAEMXZ"]
    pub fn cocos2d_CCDirector_getContentScaleFactor(this: *mut cocos2d_CCDirector) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?checkSceneReference@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_checkSceneReference(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?getNextScene@CCDirector@cocos2d@@QAEPAVCCScene@2@XZ"]
    pub fn cocos2d_CCDirector_getNextScene(this: *mut cocos2d_CCDirector) -> *mut cocos2d_CCScene;
}
extern "thiscall" {
    #[link_name = "\u{1}?levelForSceneInStack@CCDirector@cocos2d@@QAEHPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_levelForSceneInStack(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?popSceneWithTransition@CCDirector@cocos2d@@QAE_NMW4PopTransition@2@@Z"]
    pub fn cocos2d_CCDirector_popSceneWithTransition(
        this: *mut cocos2d_CCDirector,
        arg1: f32,
        arg2: cocos2d_PopTransition,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?popToSceneInStack@CCDirector@cocos2d@@QAEXPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_popToSceneInStack(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneCount@CCDirector@cocos2d@@QAEHXZ"]
    pub fn cocos2d_CCDirector_sceneCount(this: *mut cocos2d_CCDirector) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?willSwitchToScene@CCDirector@cocos2d@@QAEXPAVCCScene@2@@Z"]
    pub fn cocos2d_CCDirector_willSwitchToScene(
        this: *mut cocos2d_CCDirector,
        arg1: *mut cocos2d_CCScene,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeStatsLabel@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_removeStatsLabel(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?resetSmoothFixCounter@CCDirector@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCDirector_resetSmoothFixCounter(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?setDeltaTime@CCDirector@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCDirector_setDeltaTime(this: *mut cocos2d_CCDirector, arg1: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setupScreenScale@CCDirector@cocos2d@@QAEXVCCSize@2@0W4TextureQuality@2@@Z"]
    pub fn cocos2d_CCDirector_setupScreenScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_CCSize,
        arg2: cocos2d_CCSize,
        arg3: cocos2d_TextureQuality,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateContentScale@CCDirector@cocos2d@@QAEXW4TextureQuality@2@@Z"]
    pub fn cocos2d_CCDirector_updateContentScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_TextureQuality,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateScreenScale@CCDirector@cocos2d@@QAEXVCCSize@2@@Z"]
    pub fn cocos2d_CCDirector_updateScreenScale(
        this: *mut cocos2d_CCDirector,
        arg1: cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getLoadedTextureQuality@CCDirector@cocos2d@@QBE?AW4TextureQuality@2@XZ"]
    pub fn cocos2d_CCDirector_getLoadedTextureQuality(
        this: *const cocos2d_CCDirector,
    ) -> cocos2d_TextureQuality;
}
extern "C" {
    #[doc = " returns a shared instance of the director\n  @js getInstance"]
    #[link_name = "\u{1}?sharedDirector@CCDirector@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCDirector_sharedDirector() -> *mut cocos2d_CCDirector;
}
extern "thiscall" {
    #[link_name = "\u{1}?purgeDirector@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_purgeDirector(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?setNextScene@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_setNextScene(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?showStats@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_showStats(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?createStatsLabel@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_createStatsLabel(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?calculateMPF@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_calculateMPF(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?getFPSImageData@CCDirector@cocos2d@@IAEXPAPAEPAI@Z"]
    pub fn cocos2d_CCDirector_getFPSImageData(
        this: *mut cocos2d_CCDirector,
        datapointer: *mut *mut ::std::os::raw::c_uchar,
        length: *mut ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " calculates delta time since last time it was called"]
    #[link_name = "\u{1}?calculateDeltaTime@CCDirector@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCDirector_calculateDeltaTime(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCDirector@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCDirector_CCDirector(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCDirector@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCDirector_CCDirector1(
        this: *mut cocos2d_CCDirector,
        arg1: *const cocos2d_CCDirector,
    );
}
impl cocos2d_CCDirector {
    #[inline]
    pub unsafe fn setOpenGLView(&mut self, pobOpenGLView: *mut cocos2d_CCEGLView) {
        cocos2d_CCDirector_setOpenGLView(self, pobOpenGLView)
    }
    #[inline]
    pub unsafe fn setNextDeltaTimeZero(&mut self, bNextDeltaTimeZero: bool) {
        cocos2d_CCDirector_setNextDeltaTimeZero(self, bNextDeltaTimeZero)
    }
    #[inline]
    pub unsafe fn setProjection(&mut self, kProjection: cocos2d_ccDirectorProjection) {
        cocos2d_CCDirector_setProjection(self, kProjection)
    }
    #[inline]
    pub unsafe fn reshapeProjection(&mut self, newWindowSize: *const cocos2d_CCSize) {
        cocos2d_CCDirector_reshapeProjection(self, newWindowSize)
    }
    #[inline]
    pub unsafe fn setViewport(&mut self) {
        cocos2d_CCDirector_setViewport(self)
    }
    #[inline]
    pub unsafe fn getNotificationNode(&mut self) -> *mut cocos2d_CCNode {
        cocos2d_CCDirector_getNotificationNode(self)
    }
    #[inline]
    pub unsafe fn setNotificationNode(&mut self, node: *mut cocos2d_CCNode) {
        cocos2d_CCDirector_setNotificationNode(self, node)
    }
    #[inline]
    pub unsafe fn getDelegate(&self) -> *mut cocos2d_CCDirectorDelegate {
        cocos2d_CCDirector_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCDirectorDelegate) {
        cocos2d_CCDirector_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn getWinSize(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getWinSize(self)
    }
    #[inline]
    pub unsafe fn getWinSizeInPixels(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getWinSizeInPixels(self)
    }
    #[inline]
    pub unsafe fn getVisibleSize(&mut self) -> cocos2d_CCSize {
        cocos2d_CCDirector_getVisibleSize(self)
    }
    #[inline]
    pub unsafe fn getVisibleOrigin(&mut self) -> cocos2d_CCPoint {
        cocos2d_CCDirector_getVisibleOrigin(self)
    }
    #[inline]
    pub unsafe fn convertToGL(&mut self, obPoint: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCDirector_convertToGL(self, obPoint)
    }
    #[inline]
    pub unsafe fn convertToUI(&mut self, obPoint: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCDirector_convertToUI(self, obPoint)
    }
    #[inline]
    pub unsafe fn getZEye(&mut self) -> f32 {
        cocos2d_CCDirector_getZEye(self)
    }
    #[inline]
    pub unsafe fn runWithScene(&mut self, pScene: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_runWithScene(self, pScene)
    }
    #[inline]
    pub unsafe fn pushScene(&mut self, pScene: *mut cocos2d_CCScene) -> bool {
        cocos2d_CCDirector_pushScene(self, pScene)
    }
    #[inline]
    pub unsafe fn popScene(&mut self) {
        cocos2d_CCDirector_popScene(self)
    }
    #[inline]
    pub unsafe fn popToRootScene(&mut self) {
        cocos2d_CCDirector_popToRootScene(self)
    }
    #[inline]
    pub unsafe fn popToSceneStackLevel(&mut self, level: ::std::os::raw::c_int) {
        cocos2d_CCDirector_popToSceneStackLevel(self, level)
    }
    #[inline]
    pub unsafe fn replaceScene(&mut self, pScene: *mut cocos2d_CCScene) -> bool {
        cocos2d_CCDirector_replaceScene(self, pScene)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        cocos2d_CCDirector_end(self)
    }
    #[inline]
    pub unsafe fn pause(&mut self) {
        cocos2d_CCDirector_pause(self)
    }
    #[inline]
    pub unsafe fn resume(&mut self) {
        cocos2d_CCDirector_resume(self)
    }
    #[inline]
    pub unsafe fn drawScene(&mut self) {
        cocos2d_CCDirector_drawScene(self)
    }
    #[inline]
    pub unsafe fn purgeCachedData(&mut self) {
        cocos2d_CCDirector_purgeCachedData(self)
    }
    #[inline]
    pub unsafe fn setDefaultValues(&mut self) {
        cocos2d_CCDirector_setDefaultValues(self)
    }
    #[inline]
    pub unsafe fn setGLDefaultValues(&mut self) {
        cocos2d_CCDirector_setGLDefaultValues(self)
    }
    #[inline]
    pub unsafe fn setAlphaBlending(&mut self, bOn: bool) {
        cocos2d_CCDirector_setAlphaBlending(self, bOn)
    }
    #[inline]
    pub unsafe fn setDepthTest(&mut self, bOn: bool) {
        cocos2d_CCDirector_setDepthTest(self, bOn)
    }
    #[inline]
    pub unsafe fn setContentScaleFactor(&mut self, scaleFactor: f32) {
        cocos2d_CCDirector_setContentScaleFactor(self, scaleFactor)
    }
    #[inline]
    pub unsafe fn getContentScaleFactor(&mut self) -> f32 {
        cocos2d_CCDirector_getContentScaleFactor(self)
    }
    #[inline]
    pub unsafe fn checkSceneReference(&mut self) {
        cocos2d_CCDirector_checkSceneReference(self)
    }
    #[inline]
    pub unsafe fn getNextScene(&mut self) -> *mut cocos2d_CCScene {
        cocos2d_CCDirector_getNextScene(self)
    }
    #[inline]
    pub unsafe fn levelForSceneInStack(
        &mut self,
        arg1: *mut cocos2d_CCScene,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCDirector_levelForSceneInStack(self, arg1)
    }
    #[inline]
    pub unsafe fn popSceneWithTransition(
        &mut self,
        arg1: f32,
        arg2: cocos2d_PopTransition,
    ) -> bool {
        cocos2d_CCDirector_popSceneWithTransition(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn popToSceneInStack(&mut self, arg1: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_popToSceneInStack(self, arg1)
    }
    #[inline]
    pub unsafe fn sceneCount(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCDirector_sceneCount(self)
    }
    #[inline]
    pub unsafe fn willSwitchToScene(&mut self, arg1: *mut cocos2d_CCScene) {
        cocos2d_CCDirector_willSwitchToScene(self, arg1)
    }
    #[inline]
    pub unsafe fn removeStatsLabel(&mut self) {
        cocos2d_CCDirector_removeStatsLabel(self)
    }
    #[inline]
    pub unsafe fn resetSmoothFixCounter(&mut self) {
        cocos2d_CCDirector_resetSmoothFixCounter(self)
    }
    #[inline]
    pub unsafe fn setDeltaTime(&mut self, arg1: f32) {
        cocos2d_CCDirector_setDeltaTime(self, arg1)
    }
    #[inline]
    pub unsafe fn setupScreenScale(
        &mut self,
        arg1: cocos2d_CCSize,
        arg2: cocos2d_CCSize,
        arg3: cocos2d_TextureQuality,
    ) {
        cocos2d_CCDirector_setupScreenScale(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn updateContentScale(&mut self, arg1: cocos2d_TextureQuality) {
        cocos2d_CCDirector_updateContentScale(self, arg1)
    }
    #[inline]
    pub unsafe fn updateScreenScale(&mut self, arg1: cocos2d_CCSize) {
        cocos2d_CCDirector_updateScreenScale(self, arg1)
    }
    #[inline]
    pub unsafe fn getLoadedTextureQuality(&self) -> cocos2d_TextureQuality {
        cocos2d_CCDirector_getLoadedTextureQuality(self)
    }
    #[inline]
    pub unsafe fn sharedDirector() -> *mut cocos2d_CCDirector {
        cocos2d_CCDirector_sharedDirector()
    }
    #[inline]
    pub unsafe fn purgeDirector(&mut self) {
        cocos2d_CCDirector_purgeDirector(self)
    }
    #[inline]
    pub unsafe fn setNextScene(&mut self) {
        cocos2d_CCDirector_setNextScene(self)
    }
    #[inline]
    pub unsafe fn showStats(&mut self) {
        cocos2d_CCDirector_showStats(self)
    }
    #[inline]
    pub unsafe fn createStatsLabel(&mut self) {
        cocos2d_CCDirector_createStatsLabel(self)
    }
    #[inline]
    pub unsafe fn calculateMPF(&mut self) {
        cocos2d_CCDirector_calculateMPF(self)
    }
    #[inline]
    pub unsafe fn getFPSImageData(
        &mut self,
        datapointer: *mut *mut ::std::os::raw::c_uchar,
        length: *mut ::std::os::raw::c_uint,
    ) {
        cocos2d_CCDirector_getFPSImageData(self, datapointer, length)
    }
    #[inline]
    pub unsafe fn calculateDeltaTime(&mut self) {
        cocos2d_CCDirector_calculateDeltaTime(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDirector_CCDirector(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCDirector) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCDirector_CCDirector1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCDirector@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCDirector_CCDirector_destructor(this: *mut cocos2d_CCDirector);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCDirector@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCDirector_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " CCScheduler associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?getScheduler@CCDirector@cocos2d@@UAEPAVCCScheduler@2@XZ"]
    pub fn cocos2d_CCDirector_getScheduler(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCScheduler;
}
extern "thiscall" {
    #[doc = " CCScheduler associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?setScheduler@CCDirector@cocos2d@@UAEXPAVCCScheduler@2@@Z"]
    pub fn cocos2d_CCDirector_setScheduler(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCScheduler,
    );
}
extern "thiscall" {
    #[doc = " CCActionManager associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?getActionManager@CCDirector@cocos2d@@UAEPAVCCActionManager@2@XZ"]
    pub fn cocos2d_CCDirector_getActionManager(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionManager;
}
extern "thiscall" {
    #[doc = " CCActionManager associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?setActionManager@CCDirector@cocos2d@@UAEXPAVCCActionManager@2@@Z"]
    pub fn cocos2d_CCDirector_setActionManager(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCActionManager,
    );
}
extern "thiscall" {
    #[doc = " CCTouchDispatcher associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?getTouchDispatcher@CCDirector@cocos2d@@UAEPAVCCTouchDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getTouchDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTouchDispatcher;
}
extern "thiscall" {
    #[doc = " CCTouchDispatcher associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?setTouchDispatcher@CCDirector@cocos2d@@UAEXPAVCCTouchDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setTouchDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTouchDispatcher,
    );
}
extern "thiscall" {
    #[doc = " CCKeypadDispatcher associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?getKeypadDispatcher@CCDirector@cocos2d@@UAEPAVCCKeypadDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getKeypadDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCKeypadDispatcher;
}
extern "thiscall" {
    #[doc = " CCKeypadDispatcher associated with this director\n@since v2.0"]
    #[link_name = "\u{1}?setKeypadDispatcher@CCDirector@cocos2d@@UAEXPAVCCKeypadDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setKeypadDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCKeypadDispatcher,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getKeyboardDispatcher@CCDirector@cocos2d@@UAEPAVCCKeyboardDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getKeyboardDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCKeyboardDispatcher;
}
extern "thiscall" {
    #[link_name = "\u{1}?setKeyboardDispatcher@CCDirector@cocos2d@@UAEXPAVCCKeyboardDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setKeyboardDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCKeyboardDispatcher,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getMouseDispatcher@CCDirector@cocos2d@@UAEPAVCCMouseDispatcher@2@XZ"]
    pub fn cocos2d_CCDirector_getMouseDispatcher(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCMouseDispatcher;
}
extern "thiscall" {
    #[link_name = "\u{1}?setMouseDispatcher@CCDirector@cocos2d@@UAEXPAVCCMouseDispatcher@2@@Z"]
    pub fn cocos2d_CCDirector_setMouseDispatcher(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCMouseDispatcher,
    );
}
extern "thiscall" {
    #[doc = " CCAccelerometer associated with this director\n@since v2.0\n@js NA\n@lua NA"]
    #[link_name = "\u{1}?getAccelerometer@CCDirector@cocos2d@@UAEPAVCCAccelerometer@2@XZ"]
    pub fn cocos2d_CCDirector_getAccelerometer(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCAccelerometer;
}
extern "thiscall" {
    #[doc = " CCAccelerometer associated with this director\n@since v2.0\n@js NA\n@lua NA"]
    #[link_name = "\u{1}?setAccelerometer@CCDirector@cocos2d@@UAEXPAVCCAccelerometer@2@@Z"]
    pub fn cocos2d_CCDirector_setAccelerometer(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCAccelerometer,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getDeltaTime@CCDirector@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCDirector_getDeltaTime(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?getSceneDelegate@CCDirector@cocos2d@@UAEPAVCCSceneDelegate@2@XZ"]
    pub fn cocos2d_CCDirector_getSceneDelegate(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSceneDelegate;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSceneDelegate@CCDirector@cocos2d@@UAEXPAVCCSceneDelegate@2@@Z"]
    pub fn cocos2d_CCDirector_setSceneDelegate(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCSceneDelegate,
    );
}
#[doc = "@brief DisplayLinkDirector is a Director that synchronizes timers with the refresh rate of the display.\n\nFeatures and Limitations:\n- Scheduled timers & drawing are synchronizes with the refresh rate of the display\n- Only supports animation intervals of 1/60 1/30 & 1/15\n\n@since v0.8.2\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCDisplayLinkDirector {
    pub _base: cocos2d_CCDirector,
    pub m_bInvalid: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDisplayLinkDirector() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCDisplayLinkDirector> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDisplayLinkDirector>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCDisplayLinkDirector))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDisplayLinkDirector>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDisplayLinkDirector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bInvalid) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCDisplayLinkDirector),
            "::",
            stringify!(m_bInvalid)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?mainLoop@CCDisplayLinkDirector@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_mainLoop(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAnimationInterval@CCDisplayLinkDirector@cocos2d@@UAEXN@Z"]
    pub fn cocos2d_CCDisplayLinkDirector_setAnimationInterval(
        this: *mut ::std::os::raw::c_void,
        dValue: f64,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?startAnimation@CCDisplayLinkDirector@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_startAnimation(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?stopAnimation@CCDisplayLinkDirector@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCDisplayLinkDirector_stopAnimation(this: *mut ::std::os::raw::c_void);
}
#[doc = " Base class for other"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGridBase {
    pub _base: cocos2d_CCObject,
    pub m_bActive: bool,
    pub m_nReuseGrid: ::std::os::raw::c_int,
    pub m_sGridSize: cocos2d_CCSize,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_obStep: cocos2d_CCPoint,
    pub m_pGrabber: *mut cocos2d_CCGrabber,
    pub m_bIsTextureFlipped: bool,
    pub m_pShaderProgram: *mut cocos2d_CCGLProgram,
    pub m_directorProjection: cocos2d_ccDirectorProjection,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGridBase() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCGridBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGridBase>(),
        96usize,
        concat!("Size of: ", stringify!(cocos2d_CCGridBase))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGridBase>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGridBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bActive) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_bActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nReuseGrid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_nReuseGrid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sGridSize) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_sGridSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexture) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obStep) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_obStep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pGrabber) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pGrabber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsTextureFlipped) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_bIsTextureFlipped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pShaderProgram) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_pShaderProgram)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_directorProjection) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGridBase),
            "::",
            stringify!(m_directorProjection)
        )
    );
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setActive@CCGridBase@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCGridBase_setActive(this: *mut cocos2d_CCGridBase, bActive: bool);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?setTextureFlipped@CCGridBase@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCGridBase_setTextureFlipped(this: *mut cocos2d_CCGridBase, bFlipped: bool);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithSize@CCGridBase@cocos2d@@QAE_NABVCCSize@2@PAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGridBase_initWithSize(
        this: *mut cocos2d_CCGridBase,
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?initWithSize@CCGridBase@cocos2d@@QAE_NABVCCSize@2@@Z"]
    pub fn cocos2d_CCGridBase_initWithSize1(
        this: *mut cocos2d_CCGridBase,
        gridSize: *const cocos2d_CCSize,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?beforeDraw@CCGridBase@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGridBase_beforeDraw(this: *mut cocos2d_CCGridBase);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?afterDraw@CCGridBase@cocos2d@@QAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCGridBase_afterDraw(
        this: *mut cocos2d_CCGridBase,
        pTarget: *mut cocos2d_CCNode,
    );
}
extern "C" {
    #[doc = " create one Grid\n @lua NA"]
    #[link_name = "\u{1}?create@CCGridBase@cocos2d@@SAPAV12@ABVCCSize@2@PAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGridBase_create(
        gridSize: *const cocos2d_CCSize,
        texture: *mut cocos2d_CCTexture2D,
        flipped: bool,
    ) -> *mut cocos2d_CCGridBase;
}
extern "C" {
    #[doc = " create one Grid\n @lua NA"]
    #[link_name = "\u{1}?create@CCGridBase@cocos2d@@SAPAV12@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCGridBase_create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGridBase;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?set2DProjection@CCGridBase@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCGridBase_set2DProjection(this: *mut cocos2d_CCGridBase);
}
impl cocos2d_CCGridBase {
    #[inline]
    pub unsafe fn setActive(&mut self, bActive: bool) {
        cocos2d_CCGridBase_setActive(self, bActive)
    }
    #[inline]
    pub unsafe fn setTextureFlipped(&mut self, bFlipped: bool) {
        cocos2d_CCGridBase_setTextureFlipped(self, bFlipped)
    }
    #[inline]
    pub unsafe fn initWithSize(
        &mut self,
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> bool {
        cocos2d_CCGridBase_initWithSize(self, gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn initWithSize1(&mut self, gridSize: *const cocos2d_CCSize) -> bool {
        cocos2d_CCGridBase_initWithSize1(self, gridSize)
    }
    #[inline]
    pub unsafe fn beforeDraw(&mut self) {
        cocos2d_CCGridBase_beforeDraw(self)
    }
    #[inline]
    pub unsafe fn afterDraw(&mut self, pTarget: *mut cocos2d_CCNode) {
        cocos2d_CCGridBase_afterDraw(self, pTarget)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        texture: *mut cocos2d_CCTexture2D,
        flipped: bool,
    ) -> *mut cocos2d_CCGridBase {
        cocos2d_CCGridBase_create(gridSize, texture, flipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGridBase {
        cocos2d_CCGridBase_create1(gridSize)
    }
    #[inline]
    pub unsafe fn set2DProjection(&mut self) {
        cocos2d_CCGridBase_set2DProjection(self)
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCGridBase@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCGridBase_CCGridBase_destructor(this: *mut cocos2d_CCGridBase);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?blit@CCGridBase@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGridBase_blit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?reuse@CCGridBase@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGridBase_reuse(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?calculateVertexPoints@CCGridBase@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGridBase_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[doc = "CCGrid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCGrid3D {
    pub _base: cocos2d_CCGridBase,
    pub m_pTexCoordinates: *mut GLvoid,
    pub m_pVertices: *mut GLvoid,
    pub m_pOriginalVertices: *mut GLvoid,
    pub m_pIndices: *mut GLushort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCGrid3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCGrid3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCGrid3D>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCGrid3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCGrid3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCGrid3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexCoordinates) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pTexCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pVertices) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOriginalVertices) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pOriginalVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIndices) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCGrid3D),
            "::",
            stringify!(m_pIndices)
        )
    );
}
extern "thiscall" {
    #[doc = " returns the vertex at a given position"]
    #[link_name = "\u{1}?vertex@CCGrid3D@cocos2d@@QAE?AU_ccVertex3F@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3D_vertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "thiscall" {
    #[doc = " returns the original (non-transformed) vertex at a given position"]
    #[link_name = "\u{1}?originalVertex@CCGrid3D@cocos2d@@QAE?AU_ccVertex3F@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCGrid3D_originalVertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccVertex3F;
}
extern "thiscall" {
    #[doc = " sets a new vertex at a given position"]
    #[link_name = "\u{1}?setVertex@CCGrid3D@cocos2d@@QAEXABVCCPoint@2@ABU_ccVertex3F@2@@Z"]
    pub fn cocos2d_CCGrid3D_setVertex(
        this: *mut cocos2d_CCGrid3D,
        pos: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    );
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCGrid3D@cocos2d@@SAPAV12@ABVCCSize@2@PAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCGrid3D_create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCGrid3D;
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCGrid3D@cocos2d@@SAPAV12@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCGrid3D_create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGrid3D;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCGrid3D@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCGrid3D_CCGrid3D(this: *mut cocos2d_CCGrid3D);
}
impl cocos2d_CCGrid3D {
    #[inline]
    pub unsafe fn vertex(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3D_vertex(self, pos)
    }
    #[inline]
    pub unsafe fn originalVertex(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccVertex3F {
        cocos2d_CCGrid3D_originalVertex(self, pos)
    }
    #[inline]
    pub unsafe fn setVertex(
        &mut self,
        pos: *const cocos2d_CCPoint,
        vertex: *const cocos2d_ccVertex3F,
    ) {
        cocos2d_CCGrid3D_setVertex(self, pos, vertex)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCGrid3D {
        cocos2d_CCGrid3D_create(gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCGrid3D {
        cocos2d_CCGrid3D_create1(gridSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCGrid3D_CCGrid3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCGrid3D@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCGrid3D_CCGrid3D_destructor(this: *mut cocos2d_CCGrid3D);
}
extern "thiscall" {
    #[link_name = "\u{1}?blit@CCGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGrid3D_blit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?reuse@CCGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGrid3D_reuse(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?calculateVertexPoints@CCGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCGrid3D_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[doc = "CCTiledGrid3D is a 3D grid implementation. It differs from Grid3D in that\nthe tiles can be separated from the grid.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTiledGrid3D {
    pub _base: cocos2d_CCGridBase,
    pub m_pTexCoordinates: *mut GLvoid,
    pub m_pVertices: *mut GLvoid,
    pub m_pOriginalVertices: *mut GLvoid,
    pub m_pIndices: *mut GLushort,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTiledGrid3D() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTiledGrid3D> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTiledGrid3D>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCTiledGrid3D))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTiledGrid3D>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTiledGrid3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexCoordinates) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pTexCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pVertices) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOriginalVertices) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pOriginalVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIndices) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTiledGrid3D),
            "::",
            stringify!(m_pIndices)
        )
    );
}
extern "thiscall" {
    #[doc = " returns the tile at the given position"]
    #[link_name = "\u{1}?tile@CCTiledGrid3D@cocos2d@@QAE?AU_ccQuad3@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_tile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "thiscall" {
    #[doc = " returns the original tile (untransformed) at the given position"]
    #[link_name = "\u{1}?originalTile@CCTiledGrid3D@cocos2d@@QAE?AU_ccQuad3@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_originalTile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
    ) -> cocos2d_ccQuad3;
}
extern "thiscall" {
    #[doc = " sets a new tile"]
    #[link_name = "\u{1}?setTile@CCTiledGrid3D@cocos2d@@QAEXABVCCPoint@2@ABU_ccQuad3@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_setTile(
        this: *mut cocos2d_CCTiledGrid3D,
        pos: *const cocos2d_CCPoint,
        coords: *const cocos2d_ccQuad3,
    );
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCTiledGrid3D@cocos2d@@SAPAV12@ABVCCSize@2@PAVCCTexture2D@2@_N@Z"]
    pub fn cocos2d_CCTiledGrid3D_create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCTiledGrid3D;
}
extern "C" {
    #[doc = " create one Grid"]
    #[link_name = "\u{1}?create@CCTiledGrid3D@cocos2d@@SAPAV12@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTiledGrid3D_create1(
        gridSize: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCTiledGrid3D;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCTiledGrid3D@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTiledGrid3D_CCTiledGrid3D(this: *mut cocos2d_CCTiledGrid3D);
}
impl cocos2d_CCTiledGrid3D {
    #[inline]
    pub unsafe fn tile(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3D_tile(self, pos)
    }
    #[inline]
    pub unsafe fn originalTile(&mut self, pos: *const cocos2d_CCPoint) -> cocos2d_ccQuad3 {
        cocos2d_CCTiledGrid3D_originalTile(self, pos)
    }
    #[inline]
    pub unsafe fn setTile(&mut self, pos: *const cocos2d_CCPoint, coords: *const cocos2d_ccQuad3) {
        cocos2d_CCTiledGrid3D_setTile(self, pos, coords)
    }
    #[inline]
    pub unsafe fn create(
        gridSize: *const cocos2d_CCSize,
        pTexture: *mut cocos2d_CCTexture2D,
        bFlipped: bool,
    ) -> *mut cocos2d_CCTiledGrid3D {
        cocos2d_CCTiledGrid3D_create(gridSize, pTexture, bFlipped)
    }
    #[inline]
    pub unsafe fn create1(gridSize: *const cocos2d_CCSize) -> *mut cocos2d_CCTiledGrid3D {
        cocos2d_CCTiledGrid3D_create1(gridSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTiledGrid3D_CCTiledGrid3D(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTiledGrid3D@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTiledGrid3D_CCTiledGrid3D_destructor(this: *mut cocos2d_CCTiledGrid3D);
}
extern "thiscall" {
    #[link_name = "\u{1}?blit@CCTiledGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTiledGrid3D_blit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?reuse@CCTiledGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTiledGrid3D_reuse(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?calculateVertexPoints@CCTiledGrid3D@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTiledGrid3D_calculateVertexPoints(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct cocos2d_CCKeypadDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCKeypadDelegate {
    pub vtable_: *const cocos2d_CCKeypadDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadDelegate))
    );
}
#[doc = " @brief\n CCKeypadHandler\n Object than contains the CCKeypadDelegate.\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeypadHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCKeypadDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadHandler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCKeypadHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "thiscall" {
    #[doc = " delegate"]
    #[link_name = "\u{1}?getDelegate@CCKeypadHandler@cocos2d@@QAEPAVCCKeypadDelegate@2@XZ"]
    pub fn cocos2d_CCKeypadHandler_getDelegate(
        this: *mut cocos2d_CCKeypadHandler,
    ) -> *mut cocos2d_CCKeypadDelegate;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCKeypadHandler@cocos2d@@QAEXPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_setDelegate(
        this: *mut cocos2d_CCKeypadHandler,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "C" {
    #[doc = " allocates a CCKeypadHandler with a delegate"]
    #[link_name = "\u{1}?handlerWithDelegate@CCKeypadHandler@cocos2d@@SAPAV12@PAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> *mut cocos2d_CCKeypadHandler;
}
impl cocos2d_CCKeypadHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCKeypadDelegate {
        cocos2d_CCKeypadHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> *mut cocos2d_CCKeypadHandler {
        cocos2d_CCKeypadHandler_handlerWithDelegate(pDelegate)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCKeypadHandler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCKeypadHandler_CCKeypadHandler_destructor(this: *mut cocos2d_CCKeypadHandler);
}
extern "thiscall" {
    #[doc = " initializes a CCKeypadHandler with a delegate"]
    #[link_name = "\u{1}?initWithDelegate@CCKeypadHandler@cocos2d@@UAE_NPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    ) -> bool;
}
pub const cocos2d_ccKeypadMSGType_kTypeBackClicked: cocos2d_ccKeypadMSGType = 1;
pub const cocos2d_ccKeypadMSGType_kTypeMenuClicked: cocos2d_ccKeypadMSGType = 2;
#[doc = " @addtogroup input\n @{"]
pub type cocos2d_ccKeypadMSGType = ::std::os::raw::c_int;
#[doc = "@class CCKeypadDispatcher\n@brief Dispatch the keypad message from the phone\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeypadDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
    pub m_bLocked: bool,
    pub m_bToAdd: bool,
    pub m_bToRemove: bool,
    pub m_pHandlersToAdd: *mut cocos2d__ccCArray,
    pub m_pHandlersToRemove: *mut cocos2d__ccCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeypadDispatcher() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCKeypadDispatcher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeypadDispatcher>(),
        68usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeypadDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeypadDispatcher>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeypadDispatcher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegates) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLocked) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bToAdd) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bToAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bToRemove) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_bToRemove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHandlersToAdd) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pHandlersToAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHandlersToRemove) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeypadDispatcher),
            "::",
            stringify!(m_pHandlersToRemove)
        )
    );
}
extern "thiscall" {
    #[doc = "@brief add delegate to concern keypad msg"]
    #[link_name = "\u{1}?addDelegate@CCKeypadDispatcher@cocos2d@@QAEXPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_addDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "thiscall" {
    #[doc = "@brief remove the delegate from the delegates who concern keypad msg"]
    #[link_name = "\u{1}?removeDelegate@CCKeypadDispatcher@cocos2d@@QAEXPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_removeDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "thiscall" {
    #[doc = "@brief force add the delegate"]
    #[link_name = "\u{1}?forceAddDelegate@CCKeypadDispatcher@cocos2d@@QAEXPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "thiscall" {
    #[doc = "@brief force remove the delegate"]
    #[link_name = "\u{1}?forceRemoveDelegate@CCKeypadDispatcher@cocos2d@@QAEXPAVCCKeypadDelegate@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCKeypadDispatcher,
        pDelegate: *mut cocos2d_CCKeypadDelegate,
    );
}
extern "thiscall" {
    #[doc = "@brief dispatch the key pad msg"]
    #[link_name = "\u{1}?dispatchKeypadMSG@CCKeypadDispatcher@cocos2d@@QAE_NW4ccKeypadMSGType@2@@Z"]
    pub fn cocos2d_CCKeypadDispatcher_dispatchKeypadMSG(
        this: *mut cocos2d_CCKeypadDispatcher,
        nMsgType: cocos2d_ccKeypadMSGType,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeypadDispatcher@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCKeypadDispatcher_CCKeypadDispatcher(this: *mut cocos2d_CCKeypadDispatcher);
}
impl cocos2d_CCKeypadDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCKeypadDelegate) {
        cocos2d_CCKeypadDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn dispatchKeypadMSG(&mut self, nMsgType: cocos2d_ccKeypadMSGType) -> bool {
        cocos2d_CCKeypadDispatcher_dispatchKeypadMSG(self, nMsgType)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeypadDispatcher_CCKeypadDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCKeypadDispatcher@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCKeypadDispatcher_CCKeypadDispatcher_destructor(
        this: *mut cocos2d_CCKeypadDispatcher,
    );
}
#[doc = " @addtogroup base_nodes\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextureAtlas {
    pub _base: cocos2d_CCObject,
    pub m_pIndices: *mut GLushort,
    pub m_pBuffersVBO: [GLuint; 2usize],
    pub m_bDirty: bool,
    #[doc = " quantity of quads that are going to be drawn"]
    pub m_uTotalQuads: ::std::os::raw::c_uint,
    #[doc = " quantity of quads that can be stored with the current texture atlas size"]
    pub m_uCapacity: ::std::os::raw::c_uint,
    #[doc = " Texture of the texture atlas"]
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    #[doc = " Quads that are going to be rendered"]
    pub m_pQuads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureAtlas() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTextureAtlas> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureAtlas>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureAtlas>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureAtlas))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIndices) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pIndices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pBuffersVBO) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pBuffersVBO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDirty) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_bDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTotalQuads) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_uTotalQuads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uCapacity) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_uCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexture) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pQuads) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureAtlas),
            "::",
            stringify!(m_pQuads)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?description@CCTextureAtlas@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCTextureAtlas_description(
        this: *mut cocos2d_CCTextureAtlas,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a TextureAtlas with an filename and with an initial capacity for Quads.\n The TextureAtlas capacity can be increased in runtime."]
    #[link_name = "\u{1}?create@CCTextureAtlas@cocos2d@@SAPAV12@PBDI@Z"]
    pub fn cocos2d_CCTextureAtlas_create(
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "thiscall" {
    #[doc = " initializes a TextureAtlas with a filename and with a certain capacity for Quads.\n The TextureAtlas capacity can be increased in runtime.\n\n WARNING: Do not reinitialize the TextureAtlas because it will leak memory (issue #706)"]
    #[link_name = "\u{1}?initWithFile@CCTextureAtlas@cocos2d@@QAE_NPBDI@Z"]
    pub fn cocos2d_CCTextureAtlas_initWithFile(
        this: *mut cocos2d_CCTextureAtlas,
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a TextureAtlas with a previously initialized Texture2D object, and\n with an initial capacity for n Quads.\n The TextureAtlas capacity can be increased in runtime."]
    #[link_name = "\u{1}?createWithTexture@CCTextureAtlas@cocos2d@@SAPAV12@PAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_createWithTexture(
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas;
}
extern "thiscall" {
    #[doc = " initializes a TextureAtlas with a previously initialized Texture2D object, and\n with an initial capacity for Quads.\n The TextureAtlas capacity can be increased in runtime.\n\n WARNING: Do not reinitialize the TextureAtlas because it will leak memory (issue #706)"]
    #[link_name = "\u{1}?initWithTexture@CCTextureAtlas@cocos2d@@QAE_NPAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_initWithTexture(
        this: *mut cocos2d_CCTextureAtlas,
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " updates a Quad (texture, vertex and color) at a certain index\n index must be between 0 and the atlas capacity - 1\n@since v0.8"]
    #[link_name = "\u{1}?updateQuad@CCTextureAtlas@cocos2d@@QAEXPAU_ccV3F_C4B_T2F_Quad@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_updateQuad(
        this: *mut cocos2d_CCTextureAtlas,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Inserts a Quad (texture, vertex and color) at a certain index\nindex must be between 0 and the atlas capacity - 1\n@since v0.8"]
    #[link_name = "\u{1}?insertQuad@CCTextureAtlas@cocos2d@@QAEXPAU_ccV3F_C4B_T2F_Quad@2@I@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuad(
        this: *mut cocos2d_CCTextureAtlas,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Inserts a c array of quads at a given index\nindex must be between 0 and the atlas capacity - 1\nthis method doesn't enlarge the array when amount + index > totalQuads\n@since v1.1"]
    #[link_name = "\u{1}?insertQuads@CCTextureAtlas@cocos2d@@QAEXPAU_ccV3F_C4B_T2F_Quad@2@II@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuads(
        this: *mut cocos2d_CCTextureAtlas,
        quads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Removes the quad that is located at a certain index and inserts it at a new index\nThis operation is faster than removing and inserting in a quad in 2 different steps\n@since v0.7.2"]
    #[link_name = "\u{1}?insertQuadFromIndex@CCTextureAtlas@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCTextureAtlas_insertQuadFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        fromIndex: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " removes a quad at a given index number.\nThe capacity remains the same, but the total number of quads to be drawn is reduced in 1\n@since v0.7.2"]
    #[link_name = "\u{1}?removeQuadAtIndex@CCTextureAtlas@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCTextureAtlas_removeQuadAtIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " removes a amount of quads starting from index\n@since 1.1"]
    #[link_name = "\u{1}?removeQuadsAtIndex@CCTextureAtlas@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCTextureAtlas_removeQuadsAtIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " removes all Quads.\nThe TextureAtlas capacity remains untouched. No memory is freed.\nThe total number of quads to be drawn will be 0\n@since v0.7.2"]
    #[link_name = "\u{1}?removeAllQuads@CCTextureAtlas@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTextureAtlas_removeAllQuads(this: *mut cocos2d_CCTextureAtlas);
}
extern "thiscall" {
    #[doc = " resize the capacity of the CCTextureAtlas.\n The new capacity can be lower or higher than the current one\n It returns YES if the resize was successful.\n If it fails to resize the capacity it will return NO with a new capacity of 0."]
    #[link_name = "\u{1}?resizeCapacity@CCTextureAtlas@cocos2d@@QAE_NI@Z"]
    pub fn cocos2d_CCTextureAtlas_resizeCapacity(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "Used internally by CCParticleBatchNode\ndon't use this unless you know what you're doing\n@since 1.1"]
    #[link_name = "\u{1}?increaseTotalQuadsWith@CCTextureAtlas@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCTextureAtlas_increaseTotalQuadsWith(
        this: *mut cocos2d_CCTextureAtlas,
        amount: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Moves an amount of quads from oldIndex at newIndex\n@since v1.1"]
    #[link_name = "\u{1}?moveQuadsFromIndex@CCTextureAtlas@cocos2d@@QAEXIII@Z"]
    pub fn cocos2d_CCTextureAtlas_moveQuadsFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        oldIndex: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = "Moves quads from index till totalQuads to the newIndex\nUsed internally by CCParticleBatchNode\nThis method doesn't enlarge the array if newIndex + quads to be moved > capacity\n@since 1.1"]
    #[link_name = "\u{1}?moveQuadsFromIndex@CCTextureAtlas@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCTextureAtlas_moveQuadsFromIndex1(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = "Ensures that after a realloc quads are still empty\nUsed internally by CCParticleBatchNode\n@since 1.1"]
    #[link_name = "\u{1}?fillWithEmptyQuadsFromIndex@CCTextureAtlas@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCTextureAtlas_fillWithEmptyQuadsFromIndex(
        this: *mut cocos2d_CCTextureAtlas,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " draws n quads\n n can't be greater than the capacity of the Atlas"]
    #[link_name = "\u{1}?drawNumberOfQuads@CCTextureAtlas@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCTextureAtlas_drawNumberOfQuads(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " draws n quads from an index (offset).\nn + start can't be greater than the capacity of the atlas\n\n@since v1.0"]
    #[link_name = "\u{1}?drawNumberOfQuads@CCTextureAtlas@cocos2d@@QAEXII@Z"]
    pub fn cocos2d_CCTextureAtlas_drawNumberOfQuads1(
        this: *mut cocos2d_CCTextureAtlas,
        n: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " draws all the Atlas's Quads"]
    #[link_name = "\u{1}?drawQuads@CCTextureAtlas@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTextureAtlas_drawQuads(this: *mut cocos2d_CCTextureAtlas);
}
extern "thiscall" {
    #[doc = " listen the event that coming to foreground on Android"]
    #[link_name = "\u{1}?listenBackToForeground@CCTextureAtlas@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_listenBackToForeground(
        this: *mut cocos2d_CCTextureAtlas,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTextureAtlas@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTextureAtlas_CCTextureAtlas(this: *mut cocos2d_CCTextureAtlas);
}
impl cocos2d_CCTextureAtlas {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTextureAtlas_description(self)
    }
    #[inline]
    pub unsafe fn create(
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas {
        cocos2d_CCTextureAtlas_create(file, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        file: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCTextureAtlas_initWithFile(self, file, capacity)
    }
    #[inline]
    pub unsafe fn createWithTexture(
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCTextureAtlas {
        cocos2d_CCTextureAtlas_createWithTexture(texture, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCTextureAtlas_initWithTexture(self, texture, capacity)
    }
    #[inline]
    pub unsafe fn updateQuad(
        &mut self,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_updateQuad(self, quad, index)
    }
    #[inline]
    pub unsafe fn insertQuad(
        &mut self,
        quad: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuad(self, quad, index)
    }
    #[inline]
    pub unsafe fn insertQuads(
        &mut self,
        quads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuads(self, quads, index, amount)
    }
    #[inline]
    pub unsafe fn insertQuadFromIndex(
        &mut self,
        fromIndex: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_insertQuadFromIndex(self, fromIndex, newIndex)
    }
    #[inline]
    pub unsafe fn removeQuadAtIndex(&mut self, index: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_removeQuadAtIndex(self, index)
    }
    #[inline]
    pub unsafe fn removeQuadsAtIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_removeQuadsAtIndex(self, index, amount)
    }
    #[inline]
    pub unsafe fn removeAllQuads(&mut self) {
        cocos2d_CCTextureAtlas_removeAllQuads(self)
    }
    #[inline]
    pub unsafe fn resizeCapacity(&mut self, n: ::std::os::raw::c_uint) -> bool {
        cocos2d_CCTextureAtlas_resizeCapacity(self, n)
    }
    #[inline]
    pub unsafe fn increaseTotalQuadsWith(&mut self, amount: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_increaseTotalQuadsWith(self, amount)
    }
    #[inline]
    pub unsafe fn moveQuadsFromIndex(
        &mut self,
        oldIndex: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_moveQuadsFromIndex(self, oldIndex, amount, newIndex)
    }
    #[inline]
    pub unsafe fn moveQuadsFromIndex1(
        &mut self,
        index: ::std::os::raw::c_uint,
        newIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_moveQuadsFromIndex1(self, index, newIndex)
    }
    #[inline]
    pub unsafe fn fillWithEmptyQuadsFromIndex(
        &mut self,
        index: ::std::os::raw::c_uint,
        amount: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_fillWithEmptyQuadsFromIndex(self, index, amount)
    }
    #[inline]
    pub unsafe fn drawNumberOfQuads(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCTextureAtlas_drawNumberOfQuads(self, n)
    }
    #[inline]
    pub unsafe fn drawNumberOfQuads1(
        &mut self,
        n: ::std::os::raw::c_uint,
        start: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTextureAtlas_drawNumberOfQuads1(self, n, start)
    }
    #[inline]
    pub unsafe fn drawQuads(&mut self) {
        cocos2d_CCTextureAtlas_drawQuads(self)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCTextureAtlas_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextureAtlas_CCTextureAtlas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " quantity of quads that are going to be drawn"]
    #[link_name = "\u{1}?getTotalQuads@CCTextureAtlas@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCTextureAtlas_getTotalQuads(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " quantity of quads that can be stored with the current texture atlas size"]
    #[link_name = "\u{1}?getCapacity@CCTextureAtlas@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCTextureAtlas_getCapacity(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Texture of the texture atlas"]
    #[link_name = "\u{1}?getTexture@CCTextureAtlas@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCTextureAtlas_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " Texture of the texture atlas"]
    #[link_name = "\u{1}?setTexture@CCTextureAtlas@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_setTexture(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " Quads that are going to be rendered"]
    #[link_name = "\u{1}?getQuads@CCTextureAtlas@cocos2d@@UAEPAU_ccV3F_C4B_T2F_Quad@2@XZ"]
    pub fn cocos2d_CCTextureAtlas_getQuads(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_ccV3F_C4B_T2F_Quad;
}
extern "thiscall" {
    #[doc = " Quads that are going to be rendered"]
    #[link_name = "\u{1}?setQuads@CCTextureAtlas@cocos2d@@UAEXPAU_ccV3F_C4B_T2F_Quad@2@@Z"]
    pub fn cocos2d_CCTextureAtlas_setQuads(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_ccV3F_C4B_T2F_Quad,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTextureAtlas@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTextureAtlas_CCTextureAtlas_destructor(this: *mut cocos2d_CCTextureAtlas);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_transformValues_ {
    _unused: [u8; 0],
}
#[doc = " CCSprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) )\n\n CCSprite can be created with an image, or with a sub-rectangle of an image.\n\n If the parent or any of its ancestors is a CCSpriteBatchNode then the following features/limitations are valid\n    - Features when the parent is a CCBatchNode:\n        - MUCH faster rendering, specially if the CCSpriteBatchNode has many children. All the children will be drawn in a single batch.\n\n    - Limitations\n        - Camera is not supported yet (eg: CCOrbitCamera action doesn't work)\n        - GridBase actions are not supported (eg: CCLens, CCRipple, CCTwirl)\n        - The Alias/Antialias property belongs to CCSpriteBatchNode, so you can't individually set the aliased property.\n        - The Blending function property belongs to CCSpriteBatchNode, so you can't individually set the blending function property.\n        - Parallax scroller is not supported, but can be simulated with a \"proxy\" sprite.\n\n  If the parent is an standard CCNode, then CCSprite behaves like any other CCNode:\n    - It supports blending functions\n    - It supports aliasing / antialiasing\n    - But the rendering will be slower: 1 draw per children.\n\n The default anchorPoint in CCSprite is (0.5, 0.5)."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSprite {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_pobTextureAtlas: *mut cocos2d_CCTextureAtlas,
    #[doc = " CCSpriteBatchNode texture atlas (weak reference)"]
    pub m_uAtlasIndex: ::std::os::raw::c_uint,
    #[doc = " Absolute (real) Index on the SpriteSheet"]
    pub m_pobBatchNode: *mut cocos2d_CCSpriteBatchNode,
    #[doc = " Used batch node (weak reference)"]
    pub m_bDirty: bool,
    #[doc = " Whether the sprite needs to be updated"]
    pub m_bRecursiveDirty: bool,
    #[doc = " Whether all of the sprite's children needs to be updated"]
    pub m_bHasChildren: bool,
    #[doc = " Whether the sprite contains children"]
    pub m_bShouldBeHidden: bool,
    #[doc = " should not be drawn because one of the ancestors is not visible"]
    pub m_transformToBatch: cocos2d_CCAffineTransform,
    pub m_sBlendFunc: cocos2d_ccBlendFunc,
    #[doc = " It's required for CCTextureProtocol inheritance"]
    pub m_pobTexture: *mut cocos2d_CCTexture2D,
    #[doc = " CCTexture2D object that is used to render the sprite"]
    pub m_obRect: cocos2d_CCRect,
    #[doc = " Retangle of CCTexture2D"]
    pub m_bRectRotated: bool,
    #[doc = " Whether the texture is rotated"]
    pub m_obOffsetPosition: cocos2d_CCPoint,
    pub m_obUnflippedOffsetPositionFromCenter: cocos2d_CCPoint,
    pub m_sQuad: cocos2d_ccV3F_C4B_T2F_Quad,
    pub m_bOpacityModifyRGB: bool,
    pub m_bFlipX: bool,
    #[doc = " Whether the sprite is flipped horizaontally or not."]
    pub m_bFlipY: bool,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_bDontDraw: bool,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_fTlVertexMod: f32,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_fTrVertexMod: f32,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_fBlVertexMod: f32,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_fBrVertexMod: f32,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub pad567: [::std::os::raw::c_char; 16usize],
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_bUnknown: bool,
    #[doc = " Whether the sprite is flipped vertically or not."]
    pub m_nUnknown: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSprite() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSprite> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSprite>(),
        512usize,
        concat!("Size of: ", stringify!(cocos2d_CCSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSprite>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSprite))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobTextureAtlas) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_pobTextureAtlas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAtlasIndex) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_uAtlasIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobBatchNode) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_pobBatchNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDirty) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRecursiveDirty) as usize - ptr as usize },
        297usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bRecursiveDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasChildren) as usize - ptr as usize },
        298usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bHasChildren)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShouldBeHidden) as usize - ptr as usize },
        299usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bShouldBeHidden)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_transformToBatch) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_transformToBatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sBlendFunc) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_sBlendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobTexture) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_pobTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obRect) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_obRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRectRotated) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bRectRotated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obOffsetPosition) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_obOffsetPosition)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_obUnflippedOffsetPositionFromCenter) as usize
                - ptr as usize
        },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_obUnflippedOffsetPositionFromCenter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sQuad) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_sQuad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOpacityModifyRGB) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bOpacityModifyRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFlipX) as usize - ptr as usize },
        469usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bFlipX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFlipY) as usize - ptr as usize },
        470usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bFlipY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDontDraw) as usize - ptr as usize },
        471usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bDontDraw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTlVertexMod) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_fTlVertexMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTrVertexMod) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_fTrVertexMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fBlVertexMod) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_fBlVertexMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fBrVertexMod) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_fBrVertexMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad567) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(pad567)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUnknown) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_bUnknown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nUnknown) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSprite),
            "::",
            stringify!(m_nUnknown)
        )
    );
}
extern "C" {
    #[doc = " Creates an empty sprite without texture. You can call setTexture method subsequently.\n\n @return An empty sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCSprite_create() -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an image filename.\n\n After creation, the rect of sprite will be the size of the image,\n and the offset will be (0,0).\n\n @param   pszFileName The string which indicates a path to image file, e.g., \"scene1/monster.png\".\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCSprite_create1(
        pszFileName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an image filename and a rect.\n\n @param   pszFileName The string wich indicates a path to image file, e.g., \"scene1/monster.png\"\n @param   rect        Only the contents inside rect of pszFileName's texture will be applied for this sprite.\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?create@CCSprite@cocos2d@@SAPAV12@PBDABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_create2(
        pszFileName: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an exsiting texture contained in a CCTexture2D object\n After creation, the rect will be the size of the texture, and the offset will be (0,0).\n\n @param   pTexture    A pointer to a CCTexture2D object.\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithTexture@CCSprite@cocos2d@@SAPAV12@PAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_createWithTexture(
        pTexture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with a texture and a rect.\n\n After creation, the offset will be (0,0).\n\n @param   pTexture    A pointer to an existing CCTexture2D object.\n                      You can use a CCTexture2D object for many sprites.\n @param   rect        Only the contents inside the rect of this texture will be applied for this sprite.\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithTexture@CCSprite@cocos2d@@SAPAV12@PAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_createWithTexture1(
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an sprite frame.\n\n @param   pSpriteFrame    A sprite frame which involves a texture and a rect\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithSpriteFrame@CCSprite@cocos2d@@SAPAV12@PAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_createWithSpriteFrame(
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCSprite;
}
extern "C" {
    #[doc = " Creates a sprite with an sprite frame name.\n\n A CCSpriteFrame will be fetched from the CCSpriteFrameCache by pszSpriteFrameName param.\n If the CCSpriteFrame doesn't exist it will raise an exception.\n\n @param   pszSpriteFrameName A null terminated string which indicates the sprite frame name.\n @return  A valid sprite object that is marked as autoreleased."]
    #[link_name = "\u{1}?createWithSpriteFrameName@CCSprite@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCSprite_createWithSpriteFrameName(
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite;
}
extern "thiscall" {
    #[doc = " Returns the flag which indicates whether the sprite is flipped horizontally or not.\n\n It only flips the texture of the sprite, and not the texture of the sprite's children.\n Also, flipping the texture doesn't alter the anchorPoint.\n If you want to flip the anchorPoint too, and/or to flip the children too use:\n sprite->setScaleX(sprite->getScaleX() * -1);\n\n @return true if the sprite is flipped horizaontally, false otherwise.\n @js isFlippedX"]
    #[link_name = "\u{1}?isFlipX@CCSprite@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCSprite_isFlipX(this: *mut cocos2d_CCSprite) -> bool;
}
extern "thiscall" {
    #[doc = " Sets whether the sprite should be flipped horizontally or not.\n\n @param bFlipX true if the sprite should be flipped horizaontally, false otherwise."]
    #[link_name = "\u{1}?setFlipX@CCSprite@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCSprite_setFlipX(this: *mut cocos2d_CCSprite, bFlipX: bool);
}
extern "thiscall" {
    #[doc = " Return the flag which indicates whether the sprite is flipped vertically or not.\n\n It only flips the texture of the sprite, and not the texture of the sprite's children.\n Also, flipping the texture doesn't alter the anchorPoint.\n If you want to flip the anchorPoint too, and/or to flip the children too use:\n sprite->setScaleY(sprite->getScaleY() * -1);\n\n @return true if the sprite is flipped vertically, flase otherwise.\n @js isFlippedY"]
    #[link_name = "\u{1}?isFlipY@CCSprite@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCSprite_isFlipY(this: *mut cocos2d_CCSprite) -> bool;
}
extern "thiscall" {
    #[doc = " Sets whether the sprite should be flipped vertically or not.\n\n @param bFlipY true if the sprite should be flipped vertically, flase otherwise."]
    #[link_name = "\u{1}?setFlipY@CCSprite@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCSprite_setFlipY(this: *mut cocos2d_CCSprite, bFlipY: bool);
}
extern "thiscall" {
    #[doc = " @} End of Sprite properties getter/setters"]
    #[link_name = "\u{1}?updateColor@CCSprite@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCSprite_updateColor(this: *mut cocos2d_CCSprite);
}
extern "thiscall" {
    #[doc = " Default constructor\n @js ctor"]
    #[link_name = "\u{1}??0CCSprite@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSprite_CCSprite(this: *mut cocos2d_CCSprite);
}
impl cocos2d_CCSprite {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create()
    }
    #[inline]
    pub unsafe fn create1(pszFileName: *const ::std::os::raw::c_char) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create1(pszFileName)
    }
    #[inline]
    pub unsafe fn create2(
        pszFileName: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_create2(pszFileName, rect)
    }
    #[inline]
    pub unsafe fn createWithTexture(pTexture: *mut cocos2d_CCTexture2D) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithTexture(pTexture)
    }
    #[inline]
    pub unsafe fn createWithTexture1(
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithTexture1(pTexture, rect)
    }
    #[inline]
    pub unsafe fn createWithSpriteFrame(
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithSpriteFrame(pSpriteFrame)
    }
    #[inline]
    pub unsafe fn createWithSpriteFrameName(
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCSprite_createWithSpriteFrameName(pszSpriteFrameName)
    }
    #[inline]
    pub unsafe fn isFlipX(&mut self) -> bool {
        cocos2d_CCSprite_isFlipX(self)
    }
    #[inline]
    pub unsafe fn setFlipX(&mut self, bFlipX: bool) {
        cocos2d_CCSprite_setFlipX(self, bFlipX)
    }
    #[inline]
    pub unsafe fn isFlipY(&mut self) -> bool {
        cocos2d_CCSprite_isFlipY(self)
    }
    #[inline]
    pub unsafe fn setFlipY(&mut self, bFlipY: bool) {
        cocos2d_CCSprite_setFlipY(self, bFlipY)
    }
    #[inline]
    pub unsafe fn updateColor(&mut self) {
        cocos2d_CCSprite_updateColor(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSprite_CCSprite(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " Default destructor\n @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSprite@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSprite_CCSprite_destructor(this: *mut cocos2d_CCSprite);
}
extern "thiscall" {
    #[doc = " Initializes an empty sprite with nothing init."]
    #[link_name = "\u{1}?init@CCSprite@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCSprite_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with a texture.\n\n After initialization, the rect used will be the size of the texture, and the offset will be (0,0).\n\n @param   pTexture    A pointer to an existing CCTexture2D object.\n                      You can use a CCTexture2D object for many sprites.\n @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UAE_NPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_initWithTexture(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with a texture and a rect.\n\n After initialization, the offset will be (0,0).\n\n @param   pTexture    A pointer to an exisiting CCTexture2D object.\n                      You can use a CCTexture2D object for many sprites.\n @param   rect        Only the contents inside rect of this texture will be applied for this sprite.\n @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UAE_NPAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_initWithTexture1(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with a texture and a rect in points, optionally rotated.\n\n After initialization, the offset will be (0,0).\n @note    This is the designated initializer.\n\n @param   pTexture    A CCTexture2D object whose texture will be applied to this sprite.\n @param   rect        A rectangle assigned the contents of texture.\n @param   rotated     Whether or not the texture rectangle is rotated.\n @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithTexture@CCSprite@cocos2d@@UAE_NPAVCCTexture2D@2@ABVCCRect@2@_N@Z"]
    pub fn cocos2d_CCSprite_initWithTexture2(
        this: *mut ::std::os::raw::c_void,
        pTexture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
        rotated: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with an SpriteFrame. The texture and rect in SpriteFrame will be applied on this sprite\n\n @param   pSpriteFrame  A CCSpriteFrame object. It should includes a valid texture and a rect\n @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithSpriteFrame@CCSprite@cocos2d@@UAE_NPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_initWithSpriteFrame(
        this: *mut ::std::os::raw::c_void,
        pSpriteFrame: *mut cocos2d_CCSpriteFrame,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with an sprite frame name.\n\n A CCSpriteFrame will be fetched from the CCSpriteFrameCache by name.\n If the CCSpriteFrame doesn't exist it will raise an exception.\n\n @param   pszSpriteFrameName  A key string that can fected a volid CCSpriteFrame from CCSpriteFrameCache\n @return  true if the sprite is initialized properly, false otherwise."]
    #[link_name = "\u{1}?initWithSpriteFrameName@CCSprite@cocos2d@@UAE_NPBD@Z"]
    pub fn cocos2d_CCSprite_initWithSpriteFrameName(
        this: *mut ::std::os::raw::c_void,
        pszSpriteFrameName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with an image filename.\n\n This method will find pszFilename from local file system, load its content to CCTexture2D,\n then use CCTexture2D to create a sprite.\n After initialization, the rect used will be the size of the image. The offset will be (0,0).\n\n @param   pszFilename The path to an image file in local file system\n @return  true if the sprite is initialized properly, false otherwise.\n @js init"]
    #[link_name = "\u{1}?initWithFile@CCSprite@cocos2d@@UAE_NPBD@Z"]
    pub fn cocos2d_CCSprite_initWithFile(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a sprite with an image filename, and a rect.\n\n This method will find pszFilename from local file system, load its content to CCTexture2D,\n then use CCTexture2D to create a sprite.\n After initialization, the offset will be (0,0).\n\n @param   pszFilename The path to an image file in local file system.\n @param   rect        The rectangle assigned the content area from texture.\n @return  true if the sprite is initialized properly, false otherwise.\n @js init"]
    #[link_name = "\u{1}?initWithFile@CCSprite@cocos2d@@UAE_NPBDABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_initWithFile1(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
        rect: *const cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @} end of initializers"]
    #[link_name = "\u{1}?setChildColor@CCSprite@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_setChildColor(
        this: *mut ::std::os::raw::c_void,
        arg1: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[doc = " @} end of initializers"]
    #[link_name = "\u{1}?setChildOpacity@CCSprite@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCSprite_setChildOpacity(this: *mut ::std::os::raw::c_void, arg1: GLubyte);
}
extern "thiscall" {
    #[doc = " @{\n @name Functions inherited from CCTextureProtocol"]
    #[link_name = "\u{1}?setTexture@CCSprite@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSprite_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getTexture@CCSprite@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSprite_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " @{\n @name Functions inherited from CCNode"]
    #[link_name = "\u{1}?setScaleX@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setScaleX(this: *mut ::std::os::raw::c_void, fScaleX: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setScaleY@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setScaleY(this: *mut ::std::os::raw::c_void, fScaleY: f32);
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setPosition@CCSprite@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCSprite_setPosition(
        this: *mut ::std::os::raw::c_void,
        pos: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotation@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setRotation(this: *mut ::std::os::raw::c_void, fRotation: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotationX@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setRotationX(this: *mut ::std::os::raw::c_void, fRotationX: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotationY@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setRotationY(this: *mut ::std::os::raw::c_void, fRotationY: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setSkewX@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setSkewX(this: *mut ::std::os::raw::c_void, sx: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setSkewY@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setSkewY(this: *mut ::std::os::raw::c_void, sy: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?removeChild@CCSprite@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCSprite_removeChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        bCleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCSprite@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCSprite_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        bCleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reorderChild@CCSprite@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSprite_reorderChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSprite_addChild(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSprite_addChild1(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSprite@cocos2d@@UAEXPAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCSprite_addChild2(
        this: *mut ::std::os::raw::c_void,
        pChild: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?sortAllChildren@CCSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSprite_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setScale@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setScale(this: *mut ::std::os::raw::c_void, fScale: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setVertexZ@CCSprite@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCSprite_setVertexZ(this: *mut ::std::os::raw::c_void, fVertexZ: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAnchorPoint@CCSprite@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCSprite_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        anchor: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ignoreAnchorPointForPosition@CCSprite@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCSprite_ignoreAnchorPointForPosition(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setVisible@CCSprite@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCSprite_setVisible(this: *mut ::std::os::raw::c_void, bVisible: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSprite_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @{\n @name Functions inherited from CCNodeRGBA"]
    #[link_name = "\u{1}?setColor@CCSprite@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_setColor(
        this: *mut ::std::os::raw::c_void,
        color3: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedColor@CCSprite@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCSprite_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCSprite@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCSprite_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCSprite@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCSprite_setOpacityModifyRGB(this: *mut ::std::os::raw::c_void, modify: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCSprite@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCSprite_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCSprite@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCSprite_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "thiscall" {
    #[doc = " Updates the quad according the rotation, position, scale values."]
    #[link_name = "\u{1}?updateTransform@CCSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSprite_updateTransform(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Returns the batch node object if this sprite is rendered by CCSpriteBatchNode\n\n @return The CCSpriteBatchNode object if this sprite is rendered by CCSpriteBatchNode,\n         NULL if the sprite isn't used batch node."]
    #[link_name = "\u{1}?getBatchNode@CCSprite@cocos2d@@UAEPAVCCSpriteBatchNode@2@XZ"]
    pub fn cocos2d_CCSprite_getBatchNode(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "thiscall" {
    #[doc = " Sets the batch node to sprite\n @warning This method is not recommended for game developers. Sample code for using batch node\n @code\n CCSpriteBatchNode *batch = CCSpriteBatchNode::create(\"Images/grossini_dance_atlas.png\", 15);\n CCSprite *sprite = CCSprite::createWithTexture(batch->getTexture(), CCRectMake(0, 0, 57, 57));\n batch->addChild(sprite);\n layer->addChild(batch);\n @endcode"]
    #[link_name = "\u{1}?setBatchNode@CCSprite@cocos2d@@UAEXPAVCCSpriteBatchNode@2@@Z"]
    pub fn cocos2d_CCSprite_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        pobSpriteBatchNode: *mut cocos2d_CCSpriteBatchNode,
    );
}
extern "thiscall" {
    #[doc = " @} end of BatchNode methods"]
    #[link_name = "\u{1}?refreshTextureRect@CCSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSprite_refreshTextureRect(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Updates the texture rect of the CCSprite in points.\n It will call setTextureRect:rotated:untrimmedSize with rotated = NO, and utrimmedSize = rect.size."]
    #[link_name = "\u{1}?setTextureRect@CCSprite@cocos2d@@UAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureRect(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " Sets the texture rect, rectRotated and untrimmed size of the CCSprite in points.\n It will update the texture coordinates and the vertex rectangle."]
    #[link_name = "\u{1}?setTextureRect@CCSprite@cocos2d@@UAEXABVCCRect@2@_NABVCCSize@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureRect1(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
        rotated: bool,
        untrimmedSize: *const cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[doc = " Sets the vertex rect.\n It will be called internally by setTextureRect.\n Useful if you want to create 2x images from SD images in Retina Display.\n Do not call it manually. Use setTextureRect instead."]
    #[link_name = "\u{1}?setVertexRect@CCSprite@cocos2d@@UAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setVertexRect(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " Sets a new display frame to the CCSprite."]
    #[link_name = "\u{1}?setDisplayFrame@CCSprite@cocos2d@@UAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_setDisplayFrame(
        this: *mut ::std::os::raw::c_void,
        pNewFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "thiscall" {
    #[doc = " Returns whether or not a CCSpriteFrame is being displayed"]
    #[link_name = "\u{1}?isFrameDisplayed@CCSprite@cocos2d@@UAE_NPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCSprite_isFrameDisplayed(
        this: *mut ::std::os::raw::c_void,
        pFrame: *mut cocos2d_CCSpriteFrame,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Returns the current displayed frame.\n @js NA"]
    #[link_name = "\u{1}?displayFrame@CCSprite@cocos2d@@UAEPAVCCSpriteFrame@2@XZ"]
    pub fn cocos2d_CCSprite_displayFrame(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "thiscall" {
    #[doc = " @{\n @name Animation methods\n**\n* Changes the display frame with animation name and index.\n* The animation name will be get from the CCAnimationCache\n*/"]
    #[link_name = "\u{1}?setDisplayFrameWithAnimationName@CCSprite@cocos2d@@UAEXPBDH@Z"]
    pub fn cocos2d_CCSprite_setDisplayFrameWithAnimationName(
        this: *mut ::std::os::raw::c_void,
        animationName: *const ::std::os::raw::c_char,
        frameIndex: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setTextureCoords@CCSprite@cocos2d@@MAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCSprite_setTextureCoords(
        this: *mut ::std::os::raw::c_void,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateBlendFunc@CCSprite@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCSprite_updateBlendFunc(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setReorderChildDirtyRecursively@CCSprite@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCSprite_setReorderChildDirtyRecursively(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setDirtyRecursively@CCSprite@cocos2d@@MAEX_N@Z"]
    pub fn cocos2d_CCSprite_setDirtyRecursively(this: *mut ::std::os::raw::c_void, bValue: bool);
}
#[doc = " @brief CCLabelTTF is a subclass of CCTextureNode that knows how to render text labels\n\n All features from CCTextureNode are valid in CCLabelTTF\n\n CCLabelTTF objects are slow. Consider using CCLabelAtlas or CCLabelBMFont instead.\n\n Custom ttf file can be put in assets/ or external storage that the Application can access.\n @code\n CCLabelTTF *label1 = CCLabelTTF::create(\"alignment left\", \"A Damn Mess\", fontSize, blockSize,\n                                          kCCTextAlignmentLeft, kCCVerticalTextAlignmentCenter);\n CCLabelTTF *label2 = CCLabelTTF::create(\"alignment right\", \"/mnt/sdcard/Scissor Cuts.ttf\", fontSize, blockSize,\n                                          kCCTextAlignmentLeft, kCCVerticalTextAlignmentCenter);\n @endcode\n"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelTTF {
    pub _base: cocos2d_CCSprite,
    pub _base_1: cocos2d_CCLabelProtocol,
    #[doc = " Dimensions of the label in Points"]
    pub m_tDimensions: cocos2d_CCSize,
    #[doc = " The alignment of the label"]
    pub m_hAlignment: cocos2d_CCTextAlignment,
    #[doc = " The vertical alignment of the label"]
    pub m_vAlignment: cocos2d_CCVerticalTextAlignment,
    #[doc = " Font name used in the label"]
    pub m_pFontName: *mut std_string,
    #[doc = " Font size of the label"]
    pub m_fFontSize: f32,
    #[doc = " label's string"]
    pub m_string: std_string,
    #[doc = " font shadow"]
    pub m_shadowEnabled: bool,
    pub m_shadowOffset: cocos2d_CCSize,
    pub m_shadowOpacity: f32,
    pub m_shadowBlur: f32,
    #[doc = " font stroke"]
    pub m_strokeEnabled: bool,
    pub m_strokeColor: cocos2d_ccColor3B,
    pub m_strokeSize: f32,
    #[doc = " font tint"]
    pub m_textFillColor: cocos2d_ccColor3B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelTTF() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLabelTTF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelTTF>(),
        596usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelTTF))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelTTF>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelTTF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tDimensions) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_tDimensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAlignment) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_hAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_vAlignment) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_vAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFontName) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_pFontName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFontSize) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_fFontSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_string) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowEnabled) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_shadowEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowOffset) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_shadowOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowOpacity) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_shadowOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_shadowBlur) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_shadowBlur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeEnabled) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_strokeEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeColor) as usize - ptr as usize },
        585usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_strokeColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strokeSize) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_strokeSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_textFillColor) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelTTF),
            "::",
            stringify!(m_textFillColor)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?description@CCLabelTTF@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCLabelTTF_description(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a CCLabelTTF with a font name and font size in points\n@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPAV12@PBD0M@Z"]
    pub fn cocos2d_CCLabelTTF_create(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " creates a CCLabelTTF from a fontname, horizontal alignment, dimension in points,  and font size in points.\n@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPAV12@PBD0MABVCCSize@2@W4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_create1(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " creates a CCLabel from a fontname, alignment, dimension in points and font size in points\n@since v2.0.1"]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPAV12@PBD0MABVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_create2(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "C" {
    #[doc = " Create a lable with string and a font definition"]
    #[link_name = "\u{1}?createWithFontDefinition@CCLabelTTF@cocos2d@@SAPAV12@PBDAAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_createWithFontDefinition(
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> *mut cocos2d_CCLabelTTF;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelTTF with a font name and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QAE_NPBD0M@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QAE_NPBD0MABVCCSize@2@W4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString1(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithString@CCLabelTTF@cocos2d@@QAE_NPBD0MABVCCSize@2@W4CCTextAlignment@2@W4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithString2(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCLabelTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithStringAndTextDefinition@CCLabelTTF@cocos2d@@QAE_NPBDAAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_initWithStringAndTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " set the text definition used by this label"]
    #[link_name = "\u{1}?setTextDefinition@CCLabelTTF@cocos2d@@QAEXPAU_ccFontDefinition@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        theDefinition: *mut cocos2d_ccFontDefinition,
    );
}
extern "thiscall" {
    #[doc = " get the text definition used by this label"]
    #[link_name = "\u{1}?getTextDefinition@CCLabelTTF@cocos2d@@QAEPAU_ccFontDefinition@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *mut cocos2d_ccFontDefinition;
}
extern "thiscall" {
    #[doc = " enable or disable shadow for the label"]
    #[link_name = "\u{1}?enableShadow@CCLabelTTF@cocos2d@@QAEXABVCCSize@2@MM_N@Z"]
    pub fn cocos2d_CCLabelTTF_enableShadow(
        this: *mut cocos2d_CCLabelTTF,
        shadowOffset: *const cocos2d_CCSize,
        shadowOpacity: f32,
        shadowBlur: f32,
        mustUpdateTexture: bool,
    );
}
extern "thiscall" {
    #[doc = " disable shadow rendering"]
    #[link_name = "\u{1}?disableShadow@CCLabelTTF@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCLabelTTF_disableShadow(this: *mut cocos2d_CCLabelTTF, mustUpdateTexture: bool);
}
extern "thiscall" {
    #[doc = " enable or disable stroke"]
    #[link_name = "\u{1}?enableStroke@CCLabelTTF@cocos2d@@QAEXABU_ccColor3B@2@M_N@Z"]
    pub fn cocos2d_CCLabelTTF_enableStroke(
        this: *mut cocos2d_CCLabelTTF,
        strokeColor: *const cocos2d_ccColor3B,
        strokeSize: f32,
        mustUpdateTexture: bool,
    );
}
extern "thiscall" {
    #[doc = " disable stroke"]
    #[link_name = "\u{1}?disableStroke@CCLabelTTF@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCLabelTTF_disableStroke(this: *mut cocos2d_CCLabelTTF, mustUpdateTexture: bool);
}
extern "thiscall" {
    #[doc = " set text tinting"]
    #[link_name = "\u{1}?setFontFillColor@CCLabelTTF@cocos2d@@QAEXABU_ccColor3B@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF_setFontFillColor(
        this: *mut cocos2d_CCLabelTTF,
        tintColor: *const cocos2d_ccColor3B,
        mustUpdateTexture: bool,
    );
}
extern "C" {
    #[doc = " Creates an label."]
    #[link_name = "\u{1}?create@CCLabelTTF@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLabelTTF_create3() -> *mut cocos2d_CCLabelTTF;
}
extern "thiscall" {
    #[link_name = "\u{1}?getHorizontalAlignment@CCLabelTTF@cocos2d@@QAE?AW4CCTextAlignment@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getHorizontalAlignment(
        this: *mut cocos2d_CCLabelTTF,
    ) -> cocos2d_CCTextAlignment;
}
extern "thiscall" {
    #[link_name = "\u{1}?setHorizontalAlignment@CCLabelTTF@cocos2d@@QAEXW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setHorizontalAlignment(
        this: *mut cocos2d_CCLabelTTF,
        alignment: cocos2d_CCTextAlignment,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getVerticalAlignment@CCLabelTTF@cocos2d@@QAE?AW4CCVerticalTextAlignment@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getVerticalAlignment(
        this: *mut cocos2d_CCLabelTTF,
    ) -> cocos2d_CCVerticalTextAlignment;
}
extern "thiscall" {
    #[link_name = "\u{1}?setVerticalAlignment@CCLabelTTF@cocos2d@@QAEXW4CCVerticalTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setVerticalAlignment(
        this: *mut cocos2d_CCLabelTTF,
        verticalAlignment: cocos2d_CCVerticalTextAlignment,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getDimensions@CCLabelTTF@cocos2d@@QAE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCLabelTTF_getDimensions(this: *mut cocos2d_CCLabelTTF) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDimensions@CCLabelTTF@cocos2d@@QAEXABVCCSize@2@@Z"]
    pub fn cocos2d_CCLabelTTF_setDimensions(
        this: *mut cocos2d_CCLabelTTF,
        dim: *const cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getFontSize@CCLabelTTF@cocos2d@@QAEMXZ"]
    pub fn cocos2d_CCLabelTTF_getFontSize(this: *mut cocos2d_CCLabelTTF) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setFontSize@CCLabelTTF@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCLabelTTF_setFontSize(this: *mut cocos2d_CCLabelTTF, fontSize: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getFontName@CCLabelTTF@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCLabelTTF_getFontName(
        this: *mut cocos2d_CCLabelTTF,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setFontName@CCLabelTTF@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCLabelTTF_setFontName(
        this: *mut cocos2d_CCLabelTTF,
        fontName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " set the text definition for this label"]
    #[link_name = "\u{1}?_updateWithTextDefinition@CCLabelTTF@cocos2d@@IAEXAAU_ccFontDefinition@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF__updateWithTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        textDefinition: *mut cocos2d_ccFontDefinition,
        mustUpdateTexture: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?_prepareTextDefinition@CCLabelTTF@cocos2d@@IAE?AU_ccFontDefinition@2@_N@Z"]
    pub fn cocos2d_CCLabelTTF__prepareTextDefinition(
        this: *mut cocos2d_CCLabelTTF,
        adjustForResolution: bool,
    ) -> cocos2d_ccFontDefinition;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLabelTTF@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLabelTTF_CCLabelTTF(this: *mut cocos2d_CCLabelTTF);
}
impl cocos2d_CCLabelTTF {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelTTF_description(self)
    }
    #[inline]
    pub unsafe fn create(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create(string, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn create1(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create1(string, fontName, fontSize, dimensions, hAlignment)
    }
    #[inline]
    pub unsafe fn create2(
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create2(
            string, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn createWithFontDefinition(
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_createWithFontDefinition(string, textDefinition)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString(self, string, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithString1(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString1(self, string, fontName, fontSize, dimensions, hAlignment)
    }
    #[inline]
    pub unsafe fn initWithString2(
        &mut self,
        string: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
        dimensions: *const cocos2d_CCSize,
        hAlignment: cocos2d_CCTextAlignment,
        vAlignment: cocos2d_CCVerticalTextAlignment,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithString2(
            self, string, fontName, fontSize, dimensions, hAlignment, vAlignment,
        )
    }
    #[inline]
    pub unsafe fn initWithStringAndTextDefinition(
        &mut self,
        string: *const ::std::os::raw::c_char,
        textDefinition: *mut cocos2d_ccFontDefinition,
    ) -> bool {
        cocos2d_CCLabelTTF_initWithStringAndTextDefinition(self, string, textDefinition)
    }
    #[inline]
    pub unsafe fn setTextDefinition(&mut self, theDefinition: *mut cocos2d_ccFontDefinition) {
        cocos2d_CCLabelTTF_setTextDefinition(self, theDefinition)
    }
    #[inline]
    pub unsafe fn getTextDefinition(&mut self) -> *mut cocos2d_ccFontDefinition {
        cocos2d_CCLabelTTF_getTextDefinition(self)
    }
    #[inline]
    pub unsafe fn enableShadow(
        &mut self,
        shadowOffset: *const cocos2d_CCSize,
        shadowOpacity: f32,
        shadowBlur: f32,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_enableShadow(
            self,
            shadowOffset,
            shadowOpacity,
            shadowBlur,
            mustUpdateTexture,
        )
    }
    #[inline]
    pub unsafe fn disableShadow(&mut self, mustUpdateTexture: bool) {
        cocos2d_CCLabelTTF_disableShadow(self, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn enableStroke(
        &mut self,
        strokeColor: *const cocos2d_ccColor3B,
        strokeSize: f32,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_enableStroke(self, strokeColor, strokeSize, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn disableStroke(&mut self, mustUpdateTexture: bool) {
        cocos2d_CCLabelTTF_disableStroke(self, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn setFontFillColor(
        &mut self,
        tintColor: *const cocos2d_ccColor3B,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF_setFontFillColor(self, tintColor, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn create3() -> *mut cocos2d_CCLabelTTF {
        cocos2d_CCLabelTTF_create3()
    }
    #[inline]
    pub unsafe fn getHorizontalAlignment(&mut self) -> cocos2d_CCTextAlignment {
        cocos2d_CCLabelTTF_getHorizontalAlignment(self)
    }
    #[inline]
    pub unsafe fn setHorizontalAlignment(&mut self, alignment: cocos2d_CCTextAlignment) {
        cocos2d_CCLabelTTF_setHorizontalAlignment(self, alignment)
    }
    #[inline]
    pub unsafe fn getVerticalAlignment(&mut self) -> cocos2d_CCVerticalTextAlignment {
        cocos2d_CCLabelTTF_getVerticalAlignment(self)
    }
    #[inline]
    pub unsafe fn setVerticalAlignment(
        &mut self,
        verticalAlignment: cocos2d_CCVerticalTextAlignment,
    ) {
        cocos2d_CCLabelTTF_setVerticalAlignment(self, verticalAlignment)
    }
    #[inline]
    pub unsafe fn getDimensions(&mut self) -> cocos2d_CCSize {
        cocos2d_CCLabelTTF_getDimensions(self)
    }
    #[inline]
    pub unsafe fn setDimensions(&mut self, dim: *const cocos2d_CCSize) {
        cocos2d_CCLabelTTF_setDimensions(self, dim)
    }
    #[inline]
    pub unsafe fn getFontSize(&mut self) -> f32 {
        cocos2d_CCLabelTTF_getFontSize(self)
    }
    #[inline]
    pub unsafe fn setFontSize(&mut self, fontSize: f32) {
        cocos2d_CCLabelTTF_setFontSize(self, fontSize)
    }
    #[inline]
    pub unsafe fn getFontName(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelTTF_getFontName(self)
    }
    #[inline]
    pub unsafe fn setFontName(&mut self, fontName: *const ::std::os::raw::c_char) {
        cocos2d_CCLabelTTF_setFontName(self, fontName)
    }
    #[inline]
    pub unsafe fn _updateWithTextDefinition(
        &mut self,
        textDefinition: *mut cocos2d_ccFontDefinition,
        mustUpdateTexture: bool,
    ) {
        cocos2d_CCLabelTTF__updateWithTextDefinition(self, textDefinition, mustUpdateTexture)
    }
    #[inline]
    pub unsafe fn _prepareTextDefinition(
        &mut self,
        adjustForResolution: bool,
    ) -> cocos2d_ccFontDefinition {
        cocos2d_CCLabelTTF__prepareTextDefinition(self, adjustForResolution)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLabelTTF_CCLabelTTF(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCLabelTTF@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLabelTTF_CCLabelTTF_destructor(this: *mut cocos2d_CCLabelTTF);
}
extern "thiscall" {
    #[doc = " initializes the CCLabelTTF"]
    #[link_name = "\u{1}?init@CCLabelTTF@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLabelTTF_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " changes the string to render\n @warning Changing the string is as expensive as creating a new CCLabelTTF. To obtain better performance use CCLabelAtlas"]
    #[link_name = "\u{1}?setString@CCLabelTTF@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCLabelTTF_setString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getString@CCLabelTTF@cocos2d@@UAEPBDXZ"]
    pub fn cocos2d_CCLabelTTF_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " CCSpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call\n (often known as \"batch draw\").\n\n A CCSpriteBatchNode can reference one and only one texture (one image file, one texture atlas).\n Only the CCSprites that are contained in that texture can be added to the CCSpriteBatchNode.\n All CCSprites added to a CCSpriteBatchNode are drawn in one OpenGL ES draw call.\n If the CCSprites are not added to a CCSpriteBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient.\n\n\n Limitations:\n  - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is CCSprite or any subclass of CCSprite. eg: particles, labels and layer can't be added to a CCSpriteBatchNode.\n  - Either all its children are Aliased or Antialiased. It can't be a mix. This is because \"alias\" is a property of the texture, and all the sprites share the same texture.\n\n @since v0.7.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteBatchNode {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_pobTextureAtlas: *mut cocos2d_CCTextureAtlas,
    pub m_blendFunc: cocos2d_ccBlendFunc,
    pub m_pobDescendants: *mut cocos2d_CCArray,
    pub m_bManualSortChildren: bool,
    pub m_bManualSortAllChildrenDirty: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteBatchNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSpriteBatchNode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteBatchNode>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteBatchNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteBatchNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteBatchNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobTextureAtlas) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteBatchNode),
            "::",
            stringify!(m_pobTextureAtlas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_blendFunc) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteBatchNode),
            "::",
            stringify!(m_blendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pobDescendants) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteBatchNode),
            "::",
            stringify!(m_pobDescendants)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bManualSortChildren) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteBatchNode),
            "::",
            stringify!(m_bManualSortChildren)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bManualSortAllChildrenDirty) as usize - ptr as usize
        },
        285usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteBatchNode),
            "::",
            stringify!(m_bManualSortAllChildrenDirty)
        )
    );
}
extern "C" {
    #[doc = " creates a CCSpriteBatchNode with a texture2d and capacity of children.\nThe capacity will be increased in 33% in runtime if it run out of space."]
    #[link_name = "\u{1}?createWithTexture@CCSpriteBatchNode@cocos2d@@SAPAV12@PAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "C" {
    #[doc = " creates a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and capacity of children.\nThe capacity will be increased in 33% in runtime if it run out of space.\nThe file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?create@CCSpriteBatchNode@cocos2d@@SAPAV12@PBDI@Z"]
    pub fn cocos2d_CCSpriteBatchNode_create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "thiscall" {
    #[doc = " initializes a CCSpriteBatchNode with a texture2d and capacity of children.\nThe capacity will be increased in 33% in runtime if it run out of space."]
    #[link_name = "\u{1}?initWithTexture@CCSpriteBatchNode@cocos2d@@QAE_NPAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_initWithTexture(
        this: *mut cocos2d_CCSpriteBatchNode,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.\nThe capacity will be increased in 33% in runtime if it run out of space.\nThe file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?initWithFile@CCSpriteBatchNode@cocos2d@@QAE_NPBDI@Z"]
    pub fn cocos2d_CCSpriteBatchNode_initWithFile(
        this: *mut cocos2d_CCSpriteBatchNode,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?increaseAtlasCapacity@CCSpriteBatchNode@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_increaseAtlasCapacity(this: *mut cocos2d_CCSpriteBatchNode);
}
extern "thiscall" {
    #[doc = " removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.\n@warning Removing a child from a CCSpriteBatchNode is very slow"]
    #[link_name = "\u{1}?removeChildAtIndex@CCSpriteBatchNode@cocos2d@@QAEXI_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeChildAtIndex(
        this: *mut cocos2d_CCSpriteBatchNode,
        index: ::std::os::raw::c_uint,
        doCleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?insertChild@CCSpriteBatchNode@cocos2d@@QAEXPAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_insertChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        child: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?appendChild@CCSpriteBatchNode@cocos2d@@QAEXPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_appendChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeSpriteFromAtlas@CCSpriteBatchNode@cocos2d@@QAEXPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeSpriteFromAtlas(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?rebuildIndexInOrder@CCSpriteBatchNode@cocos2d@@QAEIPAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_rebuildIndexInOrder(
        this: *mut cocos2d_CCSpriteBatchNode,
        parent: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?highestAtlasIndexInChild@CCSpriteBatchNode@cocos2d@@QAEIPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_highestAtlasIndexInChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?lowestAtlasIndexInChild@CCSpriteBatchNode@cocos2d@@QAEIPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_lowestAtlasIndexInChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?atlasIndexForChild@CCSpriteBatchNode@cocos2d@@QAEIPAVCCSprite@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_atlasIndexForChild(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?reorderBatch@CCSpriteBatchNode@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_reorderBatch(
        this: *mut cocos2d_CCSpriteBatchNode,
        reorder: bool,
    );
}
extern "thiscall" {
    #[doc = " Inserts a quad at a certain index into the texture atlas. The CCSprite won't be added into the children array.\nThis method should be called only when you are dealing with very big AtlasSrite and when most of the CCSprite won't be updated.\nFor example: a tile map (CCTMXMap) or a label with lots of characters (CCLabelBMFont)"]
    #[link_name = "\u{1}?insertQuadFromSprite@CCSpriteBatchNode@cocos2d@@IAEXPAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_insertQuadFromSprite(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Updates a quad at a certain index into the texture atlas. The CCSprite won't be added into the children array.\nThis method should be called only when you are dealing with very big AtlasSrite and when most of the CCSprite won't be updated.\nFor example: a tile map (CCTMXMap) or a label with lots of characters (CCLabelBMFont)"]
    #[link_name = "\u{1}?updateQuadFromSprite@CCSpriteBatchNode@cocos2d@@IAEXPAVCCSprite@2@I@Z"]
    pub fn cocos2d_CCSpriteBatchNode_updateQuadFromSprite(
        this: *mut cocos2d_CCSpriteBatchNode,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addSpriteWithoutQuad@CCSpriteBatchNode@cocos2d@@IAEPAV12@PAVCCSprite@2@IH@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addSpriteWithoutQuad(
        this: *mut cocos2d_CCSpriteBatchNode,
        child: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_uint,
        aTag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSpriteBatchNode;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCSpriteBatchNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_CCSpriteBatchNode(this: *mut cocos2d_CCSpriteBatchNode);
}
impl cocos2d_CCSpriteBatchNode {
    #[inline]
    pub unsafe fn createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_createWithTexture(tex, capacity)
    }
    #[inline]
    pub unsafe fn create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_create(fileImage, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSpriteBatchNode_initWithTexture(self, tex, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSpriteBatchNode_initWithFile(self, fileImage, capacity)
    }
    #[inline]
    pub unsafe fn increaseAtlasCapacity(&mut self) {
        cocos2d_CCSpriteBatchNode_increaseAtlasCapacity(self)
    }
    #[inline]
    pub unsafe fn removeChildAtIndex(&mut self, index: ::std::os::raw::c_uint, doCleanup: bool) {
        cocos2d_CCSpriteBatchNode_removeChildAtIndex(self, index, doCleanup)
    }
    #[inline]
    pub unsafe fn insertChild(
        &mut self,
        child: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_insertChild(self, child, index)
    }
    #[inline]
    pub unsafe fn appendChild(&mut self, sprite: *mut cocos2d_CCSprite) {
        cocos2d_CCSpriteBatchNode_appendChild(self, sprite)
    }
    #[inline]
    pub unsafe fn removeSpriteFromAtlas(&mut self, sprite: *mut cocos2d_CCSprite) {
        cocos2d_CCSpriteBatchNode_removeSpriteFromAtlas(self, sprite)
    }
    #[inline]
    pub unsafe fn rebuildIndexInOrder(
        &mut self,
        parent: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_rebuildIndexInOrder(self, parent, index)
    }
    #[inline]
    pub unsafe fn highestAtlasIndexInChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_highestAtlasIndexInChild(self, sprite)
    }
    #[inline]
    pub unsafe fn lowestAtlasIndexInChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_lowestAtlasIndexInChild(self, sprite)
    }
    #[inline]
    pub unsafe fn atlasIndexForChild(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCSpriteBatchNode_atlasIndexForChild(self, sprite, z)
    }
    #[inline]
    pub unsafe fn reorderBatch(&mut self, reorder: bool) {
        cocos2d_CCSpriteBatchNode_reorderBatch(self, reorder)
    }
    #[inline]
    pub unsafe fn insertQuadFromSprite(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_insertQuadFromSprite(self, sprite, index)
    }
    #[inline]
    pub unsafe fn updateQuadFromSprite(
        &mut self,
        sprite: *mut cocos2d_CCSprite,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCSpriteBatchNode_updateQuadFromSprite(self, sprite, index)
    }
    #[inline]
    pub unsafe fn addSpriteWithoutQuad(
        &mut self,
        child: *mut cocos2d_CCSprite,
        z: ::std::os::raw::c_uint,
        aTag: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSpriteBatchNode {
        cocos2d_CCSpriteBatchNode_addSpriteWithoutQuad(self, child, z, aTag)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSpriteBatchNode_CCSpriteBatchNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSpriteBatchNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_CCSpriteBatchNode_destructor(
        this: *mut cocos2d_CCSpriteBatchNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCSpriteBatchNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCSpriteBatchNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getTexture@CCSpriteBatchNode@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTexture@CCSpriteBatchNode@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setBlendFunc@CCSpriteBatchNode@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCSpriteBatchNode@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCSpriteBatchNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCSpriteBatchNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_visit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCSpriteBatchNode@cocos2d@@UAEXPAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCSpriteBatchNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reorderChild@CCSpriteBatchNode@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCSpriteBatchNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeChild@CCSpriteBatchNode@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCSpriteBatchNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCSpriteBatchNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?sortAllChildren@CCSpriteBatchNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_sortAllChildren(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCSpriteBatchNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCSpriteBatchNode_draw(this: *mut ::std::os::raw::c_void);
}
pub const kCCLabelAutomaticWidth: cocos2d__bindgen_ty_7 = -1;
#[doc = " @addtogroup GUI\n @{\n @addtogroup label\n @{"]
pub type cocos2d__bindgen_ty_7 = ::std::os::raw::c_int;
#[doc = "@struct ccBMFontDef\nBMFont definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__BMFontDef {
    #[doc = "! ID of the character"]
    pub charID: ::std::os::raw::c_uint,
    #[doc = "! origin and size of the font"]
    pub rect: cocos2d_CCRect,
    #[doc = "! The X amount the image should be offset when drawing the image (in pixels)"]
    pub xOffset: ::std::os::raw::c_short,
    #[doc = "! The Y amount the image should be offset when drawing the image (in pixels)"]
    pub yOffset: ::std::os::raw::c_short,
    #[doc = "! The amount to move the current position after drawing the character (in pixels)"]
    pub xAdvance: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_cocos2d__BMFontDef() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__BMFontDef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__BMFontDef>(),
        28usize,
        concat!("Size of: ", stringify!(cocos2d__BMFontDef))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__BMFontDef>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__BMFontDef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(charID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xOffset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(xOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yOffset) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(yOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xAdvance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontDef),
            "::",
            stringify!(xAdvance)
        )
    );
}
#[doc = "@struct ccBMFontDef\nBMFont definition"]
pub type cocos2d_ccBMFontDef = cocos2d__BMFontDef;
#[doc = " @struct ccBMFontPadding\nBMFont padding\n@since v0.8.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__BMFontPadding {
    #[doc = " padding left"]
    pub left: ::std::os::raw::c_int,
    #[doc = " padding top"]
    pub top: ::std::os::raw::c_int,
    #[doc = " padding right"]
    pub right: ::std::os::raw::c_int,
    #[doc = " padding bottom"]
    pub bottom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d__BMFontPadding() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__BMFontPadding> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__BMFontPadding>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d__BMFontPadding))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__BMFontPadding>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__BMFontPadding))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__BMFontPadding),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " @struct ccBMFontPadding\nBMFont padding\n@since v0.8.2"]
pub type cocos2d_ccBMFontPadding = cocos2d__BMFontPadding;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__FontDefHashElement {
    pub key: ::std::os::raw::c_uint,
    pub fontDef: cocos2d_ccBMFontDef,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d__FontDefHashElement() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__FontDefHashElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__FontDefHashElement>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d__FontDefHashElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__FontDefHashElement>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__FontDefHashElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fontDef) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(fontDef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__FontDefHashElement),
            "::",
            stringify!(hh)
        )
    );
}
pub type cocos2d_tCCFontDefHashElement = cocos2d__FontDefHashElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__KerningHashElement {
    pub key: ::std::os::raw::c_int,
    pub amount: ::std::os::raw::c_int,
    pub hh: UT_hash_handle,
}
#[test]
fn bindgen_test_layout_cocos2d__KerningHashElement() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__KerningHashElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__KerningHashElement>(),
        40usize,
        concat!("Size of: ", stringify!(cocos2d__KerningHashElement))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__KerningHashElement>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d__KerningHashElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(amount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__KerningHashElement),
            "::",
            stringify!(hh)
        )
    );
}
pub type cocos2d_tCCKerningHashElement = cocos2d__KerningHashElement;
#[doc = " @brief CCBMFontConfiguration has parsed configuration of the the .fnt file\n@since v0.8\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCBMFontConfiguration {
    pub _base: cocos2d_CCObject,
    pub m_pFontDefDictionary: *mut cocos2d_tCCFontDefHashElement,
    #[doc = "! FNTConfig: Common Height Should be signed (issue #1343)"]
    pub m_nCommonHeight: ::std::os::raw::c_int,
    #[doc = "! Padding"]
    pub m_tPadding: cocos2d_ccBMFontPadding,
    #[doc = "! atlas name"]
    pub m_sAtlasName: std_string,
    #[doc = "! values for kerning"]
    pub m_pKerningDictionary: *mut cocos2d_tCCKerningHashElement,
    pub m_pCharacterSet: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCBMFontConfiguration() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCBMFontConfiguration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCBMFontConfiguration>(),
        108usize,
        concat!("Size of: ", stringify!(cocos2d_CCBMFontConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCBMFontConfiguration>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCBMFontConfiguration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFontDefDictionary) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pFontDefDictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCommonHeight) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_nCommonHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tPadding) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_tPadding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sAtlasName) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_sAtlasName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pKerningDictionary) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pKerningDictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCharacterSet) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCBMFontConfiguration),
            "::",
            stringify!(m_pCharacterSet)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?description@CCBMFontConfiguration@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCBMFontConfiguration_description(
        this: *mut cocos2d_CCBMFontConfiguration,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " allocates a CCBMFontConfiguration with a FNT file"]
    #[link_name = "\u{1}?create@CCBMFontConfiguration@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCBMFontConfiguration_create(
        FNTfile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration;
}
extern "thiscall" {
    #[doc = " initializes a BitmapFontConfiguration with a FNT file"]
    #[link_name = "\u{1}?initWithFNTfile@CCBMFontConfiguration@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCBMFontConfiguration_initWithFNTfile(
        this: *mut cocos2d_CCBMFontConfiguration,
        FNTfile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getCharacterSet@CCBMFontConfiguration@cocos2d@@QBEPAV?$set@IU?$less@I@std@@V?$allocator@I@2@@std@@XZ"]
    pub fn cocos2d_CCBMFontConfiguration_getCharacterSet(
        this: *const cocos2d_CCBMFontConfiguration,
    ) -> *mut u8;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCBMFontConfiguration@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCBMFontConfiguration_CCBMFontConfiguration(
        this: *mut cocos2d_CCBMFontConfiguration,
    );
}
impl cocos2d_CCBMFontConfiguration {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCBMFontConfiguration_description(self)
    }
    #[inline]
    pub unsafe fn create(
        FNTfile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration {
        cocos2d_CCBMFontConfiguration_create(FNTfile)
    }
    #[inline]
    pub unsafe fn initWithFNTfile(&mut self, FNTfile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCBMFontConfiguration_initWithFNTfile(self, FNTfile)
    }
    #[inline]
    pub unsafe fn getCharacterSet(&self) -> *mut u8 {
        cocos2d_CCBMFontConfiguration_getCharacterSet(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCBMFontConfiguration_CCBMFontConfiguration(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCBMFontConfiguration@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCBMFontConfiguration_CCBMFontConfiguration_destructor(
        this: *mut cocos2d_CCBMFontConfiguration,
    );
}
#[doc = " @brief CCLabelBMFont is a subclass of CCSpriteBatchNode.\n\nFeatures:\n- Treats each character like a CCSprite. This means that each individual character can be:\n- rotated\n- scaled\n- translated\n- tinted\n- change the opacity\n- It can be used as part of a menu item.\n- anchorPoint can be used to align the \"label\"\n- Supports AngelCode text format\n\nLimitations:\n- All inner characters are using an anchorPoint of (0.5f, 0.5f) and it is not recommend to change it\nbecause it might affect the rendering\n\nCCLabelBMFont implements the protocol CCLabelProtocol, like CCLabel and CCLabelAtlas.\nCCLabelBMFont has the flexibility of CCLabel, the speed of CCLabelAtlas and all the features of CCSprite.\nIf in doubt, use CCLabelBMFont instead of CCLabelAtlas / CCLabel.\n\nSupported editors:\nhttp://glyphdesigner.71squared.com/ (Commercial, Mac OS X)\nhttp://www.n4te.com/hiero/hiero.jnlp (Free, Java)\nhttp://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)\nhttp://www.angelcode.com/products/bmfont/ (Free, Windows only)\n\n@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLabelBMFont {
    pub _base: cocos2d_CCSpriteBatchNode,
    pub _base_1: cocos2d_CCLabelProtocol,
    pub _base_2: cocos2d_CCRGBAProtocol,
    pub m_sString: *mut ::std::os::raw::c_ushort,
    pub m_sFntFile: std_string,
    pub m_sInitialString: *mut ::std::os::raw::c_ushort,
    pub m_sInitialStringUTF8: std_string,
    pub m_pAlignment: cocos2d_CCTextAlignment,
    pub m_fWidth: f32,
    pub m_pConfiguration: *mut cocos2d_CCBMFontConfiguration,
    pub m_bLineBreakWithoutSpaces: bool,
    pub m_tImageOffset: cocos2d_CCPoint,
    pub m_pReusedChar: *mut cocos2d_CCSprite,
    pub m_cDisplayedOpacity: GLubyte,
    pub m_cRealOpacity: GLubyte,
    pub m_tDisplayedColor: cocos2d_ccColor3B,
    pub m_tRealColor: cocos2d_ccColor3B,
    pub m_bCascadeColorEnabled: bool,
    pub m_bCascadeOpacityEnabled: bool,
    #[doc = " conforms to CCRGBAProtocol protocol"]
    pub m_bIsOpacityModifyRGB: bool,
    pub m_bIsBatched: bool,
    pub m_pTargetArray: *mut cocos2d_CCArray,
    pub m_pSomeTexture: *mut cocos2d_CCTexture2D,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLabelBMFont() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLabelBMFont> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLabelBMFont>(),
        400usize,
        concat!("Size of: ", stringify!(cocos2d_CCLabelBMFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLabelBMFont>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLabelBMFont))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sString) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_sString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sFntFile) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_sFntFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sInitialString) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_sInitialString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sInitialStringUTF8) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_sInitialStringUTF8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAlignment) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_pAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fWidth) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_fWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pConfiguration) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_pConfiguration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLineBreakWithoutSpaces) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_bLineBreakWithoutSpaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tImageOffset) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_tImageOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pReusedChar) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_pReusedChar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cDisplayedOpacity) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_cDisplayedOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cRealOpacity) as usize - ptr as usize },
        381usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_cRealOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tDisplayedColor) as usize - ptr as usize },
        382usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_tDisplayedColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tRealColor) as usize - ptr as usize },
        385usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_tRealColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCascadeColorEnabled) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_bCascadeColorEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCascadeOpacityEnabled) as usize - ptr as usize },
        389usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_bCascadeOpacityEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsOpacityModifyRGB) as usize - ptr as usize },
        390usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_bIsOpacityModifyRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsBatched) as usize - ptr as usize },
        391usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_bIsBatched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTargetArray) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_pTargetArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSomeTexture) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLabelBMFont),
            "::",
            stringify!(m_pSomeTexture)
        )
    );
}
extern "C" {
    #[doc = " Purges the cached data.\nRemoves from memory the cached configurations and the atlas name dictionary.\n@since v0.99.3"]
    #[link_name = "\u{1}?purgeCachedData@CCLabelBMFont@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCLabelBMFont_purgeCachedData();
}
extern "C" {
    #[doc = " creates a bitmap font atlas with an initial string and the FNT file"]
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPAV12@PBD0MW4CCTextAlignment@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_create(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPAV12@PBD0MW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_create1(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPAV12@PBD0M@Z"]
    pub fn cocos2d_CCLabelBMFont_create2(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPAV12@PBD0@Z"]
    pub fn cocos2d_CCLabelBMFont_create3(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "C" {
    #[doc = " Creates an label."]
    #[link_name = "\u{1}?create@CCLabelBMFont@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLabelBMFont_create4() -> *mut cocos2d_CCLabelBMFont;
}
extern "thiscall" {
    #[doc = " init a bitmap font atlas with an initial string and the FNT file"]
    #[link_name = "\u{1}?initWithString@CCLabelBMFont@cocos2d@@QAE_NPBD0MW4CCTextAlignment@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_initWithString(
        this: *mut cocos2d_CCLabelBMFont,
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " updates the font chars based on the string to render"]
    #[link_name = "\u{1}?createFontChars@CCLabelBMFont@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCLabelBMFont_createFontChars(this: *mut cocos2d_CCLabelBMFont);
}
extern "thiscall" {
    #[link_name = "\u{1}?setFntFile@CCLabelBMFont@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setFntFile(
        this: *mut cocos2d_CCLabelBMFont,
        fntFile: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getFntFile@CCLabelBMFont@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCLabelBMFont_getFntFile(
        this: *mut cocos2d_CCLabelBMFont,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?createBatched@CCLabelBMFont@cocos2d@@SAPAV12@PBD0PAVCCArray@2@H@Z"]
    pub fn cocos2d_CCLabelBMFont_createBatched(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        arg1: *mut cocos2d_CCArray,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCLabelBMFont;
}
extern "thiscall" {
    #[link_name = "\u{1}?limitLabelWidth@CCLabelBMFont@cocos2d@@QAEXMMM@Z"]
    pub fn cocos2d_CCLabelBMFont_limitLabelWidth(
        this: *mut cocos2d_CCLabelBMFont,
        width: f32,
        defaultScale: f32,
        minScale: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getExtraKerning@CCLabelBMFont@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCLabelBMFont_getExtraKerning(
        this: *const cocos2d_CCLabelBMFont,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setExtraKerning@CCLabelBMFont@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCLabelBMFont_setExtraKerning(
        this: *mut cocos2d_CCLabelBMFont,
        arg1: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getIsBatched@CCLabelBMFont@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCLabelBMFont_getIsBatched(this: *const cocos2d_CCLabelBMFont) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setIsBatched@CCLabelBMFont@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setIsBatched(this: *mut cocos2d_CCLabelBMFont, arg1: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?getTargetArray@CCLabelBMFont@cocos2d@@QBEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getTargetArray(
        this: *const cocos2d_CCLabelBMFont,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTargetArray@CCLabelBMFont@cocos2d@@QAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setTargetArray(
        this: *mut cocos2d_CCLabelBMFont,
        arg1: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLabelBMFont@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLabelBMFont_CCLabelBMFont(this: *mut cocos2d_CCLabelBMFont);
}
impl cocos2d_CCLabelBMFont {
    #[inline]
    pub unsafe fn purgeCachedData() {
        cocos2d_CCLabelBMFont_purgeCachedData()
    }
    #[inline]
    pub unsafe fn create(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create(str_, fntFile, width, alignment, imageOffset)
    }
    #[inline]
    pub unsafe fn create1(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create1(str_, fntFile, width, alignment)
    }
    #[inline]
    pub unsafe fn create2(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create2(str_, fntFile, width)
    }
    #[inline]
    pub unsafe fn create3(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create3(str_, fntFile)
    }
    #[inline]
    pub unsafe fn create4() -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_create4()
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        width: f32,
        alignment: cocos2d_CCTextAlignment,
        imageOffset: cocos2d_CCPoint,
    ) -> bool {
        cocos2d_CCLabelBMFont_initWithString(self, str_, fntFile, width, alignment, imageOffset)
    }
    #[inline]
    pub unsafe fn createFontChars(&mut self) {
        cocos2d_CCLabelBMFont_createFontChars(self)
    }
    #[inline]
    pub unsafe fn setFntFile(&mut self, fntFile: *const ::std::os::raw::c_char) {
        cocos2d_CCLabelBMFont_setFntFile(self, fntFile)
    }
    #[inline]
    pub unsafe fn getFntFile(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCLabelBMFont_getFntFile(self)
    }
    #[inline]
    pub unsafe fn createBatched(
        str_: *const ::std::os::raw::c_char,
        fntFile: *const ::std::os::raw::c_char,
        arg1: *mut cocos2d_CCArray,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCLabelBMFont {
        cocos2d_CCLabelBMFont_createBatched(str_, fntFile, arg1, arg2)
    }
    #[inline]
    pub unsafe fn limitLabelWidth(&mut self, width: f32, defaultScale: f32, minScale: f32) {
        cocos2d_CCLabelBMFont_limitLabelWidth(self, width, defaultScale, minScale)
    }
    #[inline]
    pub unsafe fn getExtraKerning(&self) -> ::std::os::raw::c_int {
        cocos2d_CCLabelBMFont_getExtraKerning(self)
    }
    #[inline]
    pub unsafe fn setExtraKerning(&mut self, arg1: ::std::os::raw::c_int) {
        cocos2d_CCLabelBMFont_setExtraKerning(self, arg1)
    }
    #[inline]
    pub unsafe fn getIsBatched(&self) -> bool {
        cocos2d_CCLabelBMFont_getIsBatched(self)
    }
    #[inline]
    pub unsafe fn setIsBatched(&mut self, arg1: bool) {
        cocos2d_CCLabelBMFont_setIsBatched(self, arg1)
    }
    #[inline]
    pub unsafe fn getTargetArray(&self) -> *mut cocos2d_CCArray {
        cocos2d_CCLabelBMFont_getTargetArray(self)
    }
    #[inline]
    pub unsafe fn setTargetArray(&mut self, arg1: *mut cocos2d_CCArray) {
        cocos2d_CCLabelBMFont_setTargetArray(self, arg1)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLabelBMFont_CCLabelBMFont(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCLabelBMFont@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLabelBMFont_CCLabelBMFont_destructor(this: *mut cocos2d_CCLabelBMFont);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCLabelBMFont@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLabelBMFont_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setString(
        this: *mut ::std::os::raw::c_void,
        newString: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@UAEXPBD_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setString1(
        this: *mut ::std::os::raw::c_void,
        newString: *const ::std::os::raw::c_char,
        needUpdateLabel: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getString@CCLabelBMFont@cocos2d@@UAEPBDXZ"]
    pub fn cocos2d_CCLabelBMFont_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCString@CCLabelBMFont@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCLabelBMFont_setCString(
        this: *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setAnchorPoint@CCLabelBMFont@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setAnchorPoint(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateLabel@CCLabelBMFont@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLabelBMFont_updateLabel(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAlignment@CCLabelBMFont@cocos2d@@UAEXW4CCTextAlignment@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setAlignment(
        this: *mut ::std::os::raw::c_void,
        alignment: cocos2d_CCTextAlignment,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setWidth@CCLabelBMFont@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setWidth(this: *mut ::std::os::raw::c_void, width: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setLineBreakWithoutSpace@CCLabelBMFont@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setLineBreakWithoutSpace(
        this: *mut ::std::os::raw::c_void,
        breakWithoutSpace: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setScale@CCLabelBMFont@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScale(this: *mut ::std::os::raw::c_void, scale: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setScaleX@CCLabelBMFont@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScaleX(this: *mut ::std::os::raw::c_void, scaleX: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setScaleY@CCLabelBMFont@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCLabelBMFont_setScaleY(this: *mut ::std::os::raw::c_void, scaleY: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCLabelBMFont@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCLabelBMFont@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        isOpacityModifyRGB: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getOpacity@CCLabelBMFont@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLabelBMFont_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCLabelBMFont@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLabelBMFont_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCLabelBMFont@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLabelBMFont_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCLabelBMFont@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLabelBMFont_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCLabelBMFont@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCLabelBMFont@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getColor@CCLabelBMFont@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedColor@CCLabelBMFont@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLabelBMFont_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setColor@CCLabelBMFont@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedColor@CCLabelBMFont@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLabelBMFont_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCLabelBMFont@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLabelBMFont_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCLabelBMFont@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setString@CCLabelBMFont@cocos2d@@MAEXPAG_N@Z"]
    pub fn cocos2d_CCLabelBMFont_setString2(
        this: *mut ::std::os::raw::c_void,
        newString: *mut ::std::os::raw::c_ushort,
        needUpdateLabel: bool,
    );
}
extern "C" {
    #[doc = " Free function that parses a FNT file a place it on the cache"]
    #[link_name = "\u{1}?FNTConfigLoadFile@cocos2d@@YAPAVCCBMFontConfiguration@1@PBD@Z"]
    pub fn cocos2d_FNTConfigLoadFile(
        file: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCBMFontConfiguration;
}
extern "C" {
    #[doc = " Purges the FNT config cache"]
    #[link_name = "\u{1}?FNTConfigRemoveCache@cocos2d@@YAXXZ"]
    pub fn cocos2d_FNTConfigRemoveCache();
}
#[repr(C)]
pub struct cocos2d_CCTouchDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchDelegate {
    pub vtable_: *const cocos2d_CCTouchDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchDelegate))
    );
}
#[doc = "@brief\nUsing this type of delegate results in two benefits:\n- 1. You don't need to deal with CCSets, the dispatcher does the job of splitting\nthem. You get exactly one UITouch per call.\n- 2. You can *claim* a UITouch by returning YES in ccTouchBegan. Updates of claimed\ntouches are sent only to the delegate(s) that claimed them. So if you get a move/\nended/canceled update you're sure it's your touch. This frees you from doing a\nlot of checks when doing multi-touch.\n\n(The name TargetedTouchDelegate relates to updates \"targeting\" their specific\nhandler, without bothering the other handlers.)\n@since v0.8\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedTouchDelegate {
    pub _base: cocos2d_CCTouchDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedTouchDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedTouchDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedTouchDelegate))
    );
}
#[doc = " @brief\nThis type of delegate is the same one used by CocoaTouch. You will receive all the events (Began,Moved,Ended,Canceled).\n@since v0.8\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStandardTouchDelegate {
    pub _base: cocos2d_CCTouchDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStandardTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStandardTouchDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCStandardTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStandardTouchDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStandardTouchDelegate))
    );
}
pub const cocos2d_enumKeyCodes_KEY_None: cocos2d_enumKeyCodes = 0;
pub const cocos2d_enumKeyCodes_KEY_Backspace: cocos2d_enumKeyCodes = 8;
pub const cocos2d_enumKeyCodes_KEY_Tab: cocos2d_enumKeyCodes = 9;
pub const cocos2d_enumKeyCodes_KEY_Clear: cocos2d_enumKeyCodes = 12;
pub const cocos2d_enumKeyCodes_KEY_Enter: cocos2d_enumKeyCodes = 13;
pub const cocos2d_enumKeyCodes_KEY_Shift: cocos2d_enumKeyCodes = 16;
pub const cocos2d_enumKeyCodes_KEY_Control: cocos2d_enumKeyCodes = 17;
pub const cocos2d_enumKeyCodes_KEY_Alt: cocos2d_enumKeyCodes = 18;
pub const cocos2d_enumKeyCodes_KEY_Pause: cocos2d_enumKeyCodes = 19;
pub const cocos2d_enumKeyCodes_KEY_CapsLock: cocos2d_enumKeyCodes = 20;
pub const cocos2d_enumKeyCodes_KEY_Escape: cocos2d_enumKeyCodes = 27;
pub const cocos2d_enumKeyCodes_KEY_Space: cocos2d_enumKeyCodes = 32;
pub const cocos2d_enumKeyCodes_KEY_PageUp: cocos2d_enumKeyCodes = 33;
pub const cocos2d_enumKeyCodes_KEY_PageDown: cocos2d_enumKeyCodes = 34;
pub const cocos2d_enumKeyCodes_KEY_End: cocos2d_enumKeyCodes = 35;
pub const cocos2d_enumKeyCodes_KEY_Home: cocos2d_enumKeyCodes = 36;
pub const cocos2d_enumKeyCodes_KEY_Left: cocos2d_enumKeyCodes = 37;
pub const cocos2d_enumKeyCodes_KEY_Up: cocos2d_enumKeyCodes = 38;
pub const cocos2d_enumKeyCodes_KEY_Right: cocos2d_enumKeyCodes = 39;
pub const cocos2d_enumKeyCodes_KEY_Down: cocos2d_enumKeyCodes = 40;
pub const cocos2d_enumKeyCodes_KEY_Select: cocos2d_enumKeyCodes = 41;
pub const cocos2d_enumKeyCodes_KEY_Print: cocos2d_enumKeyCodes = 42;
pub const cocos2d_enumKeyCodes_KEY_Execute: cocos2d_enumKeyCodes = 43;
pub const cocos2d_enumKeyCodes_KEY_PrintScreen: cocos2d_enumKeyCodes = 44;
pub const cocos2d_enumKeyCodes_KEY_Insert: cocos2d_enumKeyCodes = 45;
pub const cocos2d_enumKeyCodes_KEY_Delete: cocos2d_enumKeyCodes = 46;
pub const cocos2d_enumKeyCodes_KEY_Help: cocos2d_enumKeyCodes = 47;
pub const cocos2d_enumKeyCodes_KEY_Zero: cocos2d_enumKeyCodes = 48;
pub const cocos2d_enumKeyCodes_KEY_One: cocos2d_enumKeyCodes = 49;
pub const cocos2d_enumKeyCodes_KEY_Two: cocos2d_enumKeyCodes = 50;
pub const cocos2d_enumKeyCodes_KEY_Three: cocos2d_enumKeyCodes = 51;
pub const cocos2d_enumKeyCodes_KEY_Four: cocos2d_enumKeyCodes = 52;
pub const cocos2d_enumKeyCodes_KEY_Five: cocos2d_enumKeyCodes = 53;
pub const cocos2d_enumKeyCodes_KEY_Six: cocos2d_enumKeyCodes = 54;
pub const cocos2d_enumKeyCodes_KEY_Seven: cocos2d_enumKeyCodes = 55;
pub const cocos2d_enumKeyCodes_KEY_Eight: cocos2d_enumKeyCodes = 56;
pub const cocos2d_enumKeyCodes_KEY_Nine: cocos2d_enumKeyCodes = 57;
pub const cocos2d_enumKeyCodes_KEY_A: cocos2d_enumKeyCodes = 65;
pub const cocos2d_enumKeyCodes_KEY_B: cocos2d_enumKeyCodes = 66;
pub const cocos2d_enumKeyCodes_KEY_C: cocos2d_enumKeyCodes = 67;
pub const cocos2d_enumKeyCodes_KEY_D: cocos2d_enumKeyCodes = 68;
pub const cocos2d_enumKeyCodes_KEY_E: cocos2d_enumKeyCodes = 69;
pub const cocos2d_enumKeyCodes_KEY_F: cocos2d_enumKeyCodes = 70;
pub const cocos2d_enumKeyCodes_KEY_G: cocos2d_enumKeyCodes = 71;
pub const cocos2d_enumKeyCodes_KEY_H: cocos2d_enumKeyCodes = 72;
pub const cocos2d_enumKeyCodes_KEY_I: cocos2d_enumKeyCodes = 73;
pub const cocos2d_enumKeyCodes_KEY_J: cocos2d_enumKeyCodes = 74;
pub const cocos2d_enumKeyCodes_KEY_K: cocos2d_enumKeyCodes = 75;
pub const cocos2d_enumKeyCodes_KEY_L: cocos2d_enumKeyCodes = 76;
pub const cocos2d_enumKeyCodes_KEY_M: cocos2d_enumKeyCodes = 77;
pub const cocos2d_enumKeyCodes_KEY_N: cocos2d_enumKeyCodes = 78;
pub const cocos2d_enumKeyCodes_KEY_O: cocos2d_enumKeyCodes = 79;
pub const cocos2d_enumKeyCodes_KEY_P: cocos2d_enumKeyCodes = 80;
pub const cocos2d_enumKeyCodes_KEY_Q: cocos2d_enumKeyCodes = 81;
pub const cocos2d_enumKeyCodes_KEY_R: cocos2d_enumKeyCodes = 82;
pub const cocos2d_enumKeyCodes_KEY_S: cocos2d_enumKeyCodes = 83;
pub const cocos2d_enumKeyCodes_KEY_T: cocos2d_enumKeyCodes = 84;
pub const cocos2d_enumKeyCodes_KEY_U: cocos2d_enumKeyCodes = 85;
pub const cocos2d_enumKeyCodes_KEY_V: cocos2d_enumKeyCodes = 86;
pub const cocos2d_enumKeyCodes_KEY_W: cocos2d_enumKeyCodes = 87;
pub const cocos2d_enumKeyCodes_KEY_X: cocos2d_enumKeyCodes = 88;
pub const cocos2d_enumKeyCodes_KEY_Y: cocos2d_enumKeyCodes = 89;
pub const cocos2d_enumKeyCodes_KEY_Z: cocos2d_enumKeyCodes = 90;
pub const cocos2d_enumKeyCodes_KEY_LeftWindowsKey: cocos2d_enumKeyCodes = 91;
pub const cocos2d_enumKeyCodes_KEY_RightWindowsKey: cocos2d_enumKeyCodes = 92;
pub const cocos2d_enumKeyCodes_KEY_ApplicationsKey: cocos2d_enumKeyCodes = 93;
pub const cocos2d_enumKeyCodes_KEY_Sleep: cocos2d_enumKeyCodes = 95;
pub const cocos2d_enumKeyCodes_KEY_NumPad0: cocos2d_enumKeyCodes = 96;
pub const cocos2d_enumKeyCodes_KEY_NumPad1: cocos2d_enumKeyCodes = 97;
pub const cocos2d_enumKeyCodes_KEY_NumPad2: cocos2d_enumKeyCodes = 98;
pub const cocos2d_enumKeyCodes_KEY_NumPad3: cocos2d_enumKeyCodes = 99;
pub const cocos2d_enumKeyCodes_KEY_NumPad4: cocos2d_enumKeyCodes = 100;
pub const cocos2d_enumKeyCodes_KEY_NumPad5: cocos2d_enumKeyCodes = 101;
pub const cocos2d_enumKeyCodes_KEY_NumPad6: cocos2d_enumKeyCodes = 102;
pub const cocos2d_enumKeyCodes_KEY_NumPad7: cocos2d_enumKeyCodes = 103;
pub const cocos2d_enumKeyCodes_KEY_NumPad8: cocos2d_enumKeyCodes = 104;
pub const cocos2d_enumKeyCodes_KEY_NumPad9: cocos2d_enumKeyCodes = 105;
pub const cocos2d_enumKeyCodes_KEY_Multiply: cocos2d_enumKeyCodes = 106;
pub const cocos2d_enumKeyCodes_KEY_Add: cocos2d_enumKeyCodes = 107;
pub const cocos2d_enumKeyCodes_KEY_Seperator: cocos2d_enumKeyCodes = 108;
pub const cocos2d_enumKeyCodes_KEY_Subtract: cocos2d_enumKeyCodes = 109;
pub const cocos2d_enumKeyCodes_KEY_Decimal: cocos2d_enumKeyCodes = 110;
pub const cocos2d_enumKeyCodes_KEY_Divide: cocos2d_enumKeyCodes = 111;
pub const cocos2d_enumKeyCodes_KEY_F1: cocos2d_enumKeyCodes = 112;
pub const cocos2d_enumKeyCodes_KEY_F2: cocos2d_enumKeyCodes = 113;
pub const cocos2d_enumKeyCodes_KEY_F3: cocos2d_enumKeyCodes = 114;
pub const cocos2d_enumKeyCodes_KEY_F4: cocos2d_enumKeyCodes = 115;
pub const cocos2d_enumKeyCodes_KEY_F5: cocos2d_enumKeyCodes = 116;
pub const cocos2d_enumKeyCodes_KEY_F6: cocos2d_enumKeyCodes = 117;
pub const cocos2d_enumKeyCodes_KEY_F7: cocos2d_enumKeyCodes = 118;
pub const cocos2d_enumKeyCodes_KEY_F8: cocos2d_enumKeyCodes = 119;
pub const cocos2d_enumKeyCodes_KEY_F9: cocos2d_enumKeyCodes = 120;
pub const cocos2d_enumKeyCodes_KEY_F10: cocos2d_enumKeyCodes = 121;
pub const cocos2d_enumKeyCodes_KEY_F11: cocos2d_enumKeyCodes = 122;
pub const cocos2d_enumKeyCodes_KEY_F12: cocos2d_enumKeyCodes = 123;
pub const cocos2d_enumKeyCodes_KEY_F13: cocos2d_enumKeyCodes = 124;
pub const cocos2d_enumKeyCodes_KEY_F14: cocos2d_enumKeyCodes = 125;
pub const cocos2d_enumKeyCodes_KEY_F15: cocos2d_enumKeyCodes = 126;
pub const cocos2d_enumKeyCodes_KEY_F16: cocos2d_enumKeyCodes = 127;
pub const cocos2d_enumKeyCodes_KEY_F17: cocos2d_enumKeyCodes = 128;
pub const cocos2d_enumKeyCodes_KEY_F18: cocos2d_enumKeyCodes = 129;
pub const cocos2d_enumKeyCodes_KEY_F19: cocos2d_enumKeyCodes = 130;
pub const cocos2d_enumKeyCodes_KEY_F20: cocos2d_enumKeyCodes = 131;
pub const cocos2d_enumKeyCodes_KEY_F21: cocos2d_enumKeyCodes = 132;
pub const cocos2d_enumKeyCodes_KEY_F22: cocos2d_enumKeyCodes = 133;
pub const cocos2d_enumKeyCodes_KEY_F23: cocos2d_enumKeyCodes = 134;
pub const cocos2d_enumKeyCodes_KEY_F24: cocos2d_enumKeyCodes = 135;
pub const cocos2d_enumKeyCodes_KEY_Numlock: cocos2d_enumKeyCodes = 144;
pub const cocos2d_enumKeyCodes_KEY_ScrollLock: cocos2d_enumKeyCodes = 145;
pub const cocos2d_enumKeyCodes_KEY_LeftShift: cocos2d_enumKeyCodes = 160;
pub const cocos2d_enumKeyCodes_KEY_RightShift: cocos2d_enumKeyCodes = 161;
pub const cocos2d_enumKeyCodes_KEY_LeftControl: cocos2d_enumKeyCodes = 162;
pub const cocos2d_enumKeyCodes_KEY_RightContol: cocos2d_enumKeyCodes = 163;
pub const cocos2d_enumKeyCodes_KEY_LeftMenu: cocos2d_enumKeyCodes = 164;
pub const cocos2d_enumKeyCodes_KEY_RightMenu: cocos2d_enumKeyCodes = 165;
pub const cocos2d_enumKeyCodes_KEY_BrowserBack: cocos2d_enumKeyCodes = 166;
pub const cocos2d_enumKeyCodes_KEY_BrowserForward: cocos2d_enumKeyCodes = 167;
pub const cocos2d_enumKeyCodes_KEY_BrowserRefresh: cocos2d_enumKeyCodes = 168;
pub const cocos2d_enumKeyCodes_KEY_BrowserStop: cocos2d_enumKeyCodes = 169;
pub const cocos2d_enumKeyCodes_KEY_BrowserSearch: cocos2d_enumKeyCodes = 170;
pub const cocos2d_enumKeyCodes_KEY_BrowserFavorites: cocos2d_enumKeyCodes = 171;
pub const cocos2d_enumKeyCodes_KEY_BrowserHome: cocos2d_enumKeyCodes = 172;
pub const cocos2d_enumKeyCodes_KEY_VolumeMute: cocos2d_enumKeyCodes = 173;
pub const cocos2d_enumKeyCodes_KEY_VolumeDown: cocos2d_enumKeyCodes = 174;
pub const cocos2d_enumKeyCodes_KEY_VolumeUp: cocos2d_enumKeyCodes = 175;
pub const cocos2d_enumKeyCodes_KEY_NextTrack: cocos2d_enumKeyCodes = 176;
pub const cocos2d_enumKeyCodes_KEY_PreviousTrack: cocos2d_enumKeyCodes = 177;
pub const cocos2d_enumKeyCodes_KEY_StopMedia: cocos2d_enumKeyCodes = 178;
pub const cocos2d_enumKeyCodes_KEY_PlayPause: cocos2d_enumKeyCodes = 179;
pub const cocos2d_enumKeyCodes_KEY_LaunchMail: cocos2d_enumKeyCodes = 180;
pub const cocos2d_enumKeyCodes_KEY_SelectMedia: cocos2d_enumKeyCodes = 181;
pub const cocos2d_enumKeyCodes_KEY_LaunchApp1: cocos2d_enumKeyCodes = 182;
pub const cocos2d_enumKeyCodes_KEY_LaunchApp2: cocos2d_enumKeyCodes = 183;
pub const cocos2d_enumKeyCodes_KEY_OEM1: cocos2d_enumKeyCodes = 186;
pub const cocos2d_enumKeyCodes_KEY_OEMPlus: cocos2d_enumKeyCodes = 184;
pub const cocos2d_enumKeyCodes_KEY_OEMComma: cocos2d_enumKeyCodes = 188;
pub const cocos2d_enumKeyCodes_KEY_OEMMinus: cocos2d_enumKeyCodes = 189;
pub const cocos2d_enumKeyCodes_KEY_OEMPeriod: cocos2d_enumKeyCodes = 190;
pub const cocos2d_enumKeyCodes_KEY_OEM2: cocos2d_enumKeyCodes = 191;
pub const cocos2d_enumKeyCodes_KEY_OEM3: cocos2d_enumKeyCodes = 192;
pub const cocos2d_enumKeyCodes_KEY_OEM4: cocos2d_enumKeyCodes = 219;
pub const cocos2d_enumKeyCodes_KEY_OEM5: cocos2d_enumKeyCodes = 220;
pub const cocos2d_enumKeyCodes_KEY_OEM6: cocos2d_enumKeyCodes = 221;
pub const cocos2d_enumKeyCodes_KEY_OEM7: cocos2d_enumKeyCodes = 222;
pub const cocos2d_enumKeyCodes_KEY_OEM8: cocos2d_enumKeyCodes = 223;
pub const cocos2d_enumKeyCodes_KEY_OEM102: cocos2d_enumKeyCodes = 226;
pub const cocos2d_enumKeyCodes_KEY_Process: cocos2d_enumKeyCodes = 229;
pub const cocos2d_enumKeyCodes_KEY_Packet: cocos2d_enumKeyCodes = 231;
pub const cocos2d_enumKeyCodes_KEY_Attn: cocos2d_enumKeyCodes = 246;
pub const cocos2d_enumKeyCodes_KEY_CrSel: cocos2d_enumKeyCodes = 247;
pub const cocos2d_enumKeyCodes_KEY_ExSel: cocos2d_enumKeyCodes = 248;
pub const cocos2d_enumKeyCodes_KEY_EraseEOF: cocos2d_enumKeyCodes = 249;
pub const cocos2d_enumKeyCodes_KEY_Play: cocos2d_enumKeyCodes = 250;
pub const cocos2d_enumKeyCodes_KEY_Zoom: cocos2d_enumKeyCodes = 251;
pub const cocos2d_enumKeyCodes_KEY_PA1: cocos2d_enumKeyCodes = 253;
pub const cocos2d_enumKeyCodes_KEY_OEMClear: cocos2d_enumKeyCodes = 254;
pub const cocos2d_enumKeyCodes_KEY_ArrowUp: cocos2d_enumKeyCodes = 283;
pub const cocos2d_enumKeyCodes_KEY_ArrowDown: cocos2d_enumKeyCodes = 284;
pub const cocos2d_enumKeyCodes_KEY_ArrowLeft: cocos2d_enumKeyCodes = 285;
pub const cocos2d_enumKeyCodes_KEY_ArrowRight: cocos2d_enumKeyCodes = 286;
pub const cocos2d_enumKeyCodes_CONTROLLER_A: cocos2d_enumKeyCodes = 1001;
pub const cocos2d_enumKeyCodes_CONTROLLER_B: cocos2d_enumKeyCodes = 1002;
pub const cocos2d_enumKeyCodes_CONTROLLER_Y: cocos2d_enumKeyCodes = 1003;
pub const cocos2d_enumKeyCodes_CONTROLLER_X: cocos2d_enumKeyCodes = 1004;
pub const cocos2d_enumKeyCodes_CONTROLLER_Start: cocos2d_enumKeyCodes = 1005;
pub const cocos2d_enumKeyCodes_CONTROLLER_Back: cocos2d_enumKeyCodes = 1006;
pub const cocos2d_enumKeyCodes_CONTROLLER_RB: cocos2d_enumKeyCodes = 1007;
pub const cocos2d_enumKeyCodes_CONTROLLER_LB: cocos2d_enumKeyCodes = 1008;
pub const cocos2d_enumKeyCodes_CONTROLLER_RT: cocos2d_enumKeyCodes = 1009;
pub const cocos2d_enumKeyCodes_CONTROLLER_LT: cocos2d_enumKeyCodes = 1010;
pub const cocos2d_enumKeyCodes_CONTROLLER_Up: cocos2d_enumKeyCodes = 1011;
pub const cocos2d_enumKeyCodes_CONTROLLER_Down: cocos2d_enumKeyCodes = 1012;
pub const cocos2d_enumKeyCodes_CONTROLLER_Left: cocos2d_enumKeyCodes = 1013;
pub const cocos2d_enumKeyCodes_CONTROLLER_Right: cocos2d_enumKeyCodes = 1014;
pub type cocos2d_enumKeyCodes = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCKeyboardDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCKeyboardDelegate {
    pub vtable_: *const cocos2d_CCKeyboardDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardDelegate))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardDelegate@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_CCKeyboardDelegate(
        this: *mut cocos2d_CCKeyboardDelegate,
        arg1: *const cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardDelegate@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCKeyboardDelegate_CCKeyboardDelegate1(this: *mut cocos2d_CCKeyboardDelegate);
}
impl cocos2d_CCKeyboardDelegate {
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCKeyboardDelegate) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDelegate_CCKeyboardDelegate(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDelegate_CCKeyboardDelegate1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?keyDown@CCKeyboardDelegate@cocos2d@@UAEXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_keyDown(
        this: *mut ::std::os::raw::c_void,
        key: cocos2d_enumKeyCodes,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?keyUp@CCKeyboardDelegate@cocos2d@@UAEXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDelegate_keyUp(
        this: *mut ::std::os::raw::c_void,
        key: cocos2d_enumKeyCodes,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeyboardHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCKeyboardDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardHandler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCKeyboardHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getDelegate@CCKeyboardHandler@cocos2d@@QAEPAVCCKeyboardDelegate@2@XZ"]
    pub fn cocos2d_CCKeyboardHandler_getDelegate(
        this: *mut cocos2d_CCKeyboardHandler,
    ) -> *mut cocos2d_CCKeyboardDelegate;
}
extern "C" {
    #[link_name = "\u{1}?handlerWithDelegate@CCKeyboardHandler@cocos2d@@SAPAV12@PAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> *mut cocos2d_CCKeyboardHandler;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCKeyboardHandler@cocos2d@@QAEXPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_setDelegate(
        this: *mut cocos2d_CCKeyboardHandler,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardHandler@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler(
        this: *mut cocos2d_CCKeyboardHandler,
        arg1: *const cocos2d_CCKeyboardHandler,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardHandler@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler1(this: *mut cocos2d_CCKeyboardHandler);
}
impl cocos2d_CCKeyboardHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCKeyboardDelegate {
        cocos2d_CCKeyboardHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> *mut cocos2d_CCKeyboardHandler {
        cocos2d_CCKeyboardHandler_handlerWithDelegate(pDelegate)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCKeyboardHandler) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardHandler_CCKeyboardHandler(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardHandler_CCKeyboardHandler1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCKeyboardHandler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCKeyboardHandler_CCKeyboardHandler_destructor(
        this: *mut cocos2d_CCKeyboardHandler,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDelegate@CCKeyboardHandler@cocos2d@@UAE_NPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    ) -> bool;
}
#[repr(C)]
pub struct cocos2d_CCMouseDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCMouseDelegate {
    pub vtable_: *const cocos2d_CCMouseDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseDelegate))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseDelegate@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCMouseDelegate_CCMouseDelegate(
        this: *mut cocos2d_CCMouseDelegate,
        arg1: *const cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseDelegate@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCMouseDelegate_CCMouseDelegate1(this: *mut cocos2d_CCMouseDelegate);
}
impl cocos2d_CCMouseDelegate {
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCMouseDelegate) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDelegate_CCMouseDelegate(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDelegate_CCMouseDelegate1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?rightKeyDown@CCMouseDelegate@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMouseDelegate_rightKeyDown(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?rightKeyUp@CCMouseDelegate@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMouseDelegate_rightKeyUp(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?scrollWheel@CCMouseDelegate@cocos2d@@UAEXMM@Z"]
    pub fn cocos2d_CCMouseDelegate_scrollWheel(this: *mut ::std::os::raw::c_void, x: f32, y: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMouseHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCMouseDelegate,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseHandler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMouseHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMouseHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getDelegate@CCMouseHandler@cocos2d@@QAEPAVCCMouseDelegate@2@XZ"]
    pub fn cocos2d_CCMouseHandler_getDelegate(
        this: *mut cocos2d_CCMouseHandler,
    ) -> *mut cocos2d_CCMouseDelegate;
}
extern "C" {
    #[link_name = "\u{1}?handlerWithDelegate@CCMouseHandler@cocos2d@@SAPAV12@PAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> *mut cocos2d_CCMouseHandler;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCMouseHandler@cocos2d@@QAEXPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_setDelegate(
        this: *mut cocos2d_CCMouseHandler,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseHandler@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler(
        this: *mut cocos2d_CCMouseHandler,
        arg1: *const cocos2d_CCMouseHandler,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseHandler@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler1(this: *mut cocos2d_CCMouseHandler);
}
impl cocos2d_CCMouseHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCMouseDelegate {
        cocos2d_CCMouseHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> *mut cocos2d_CCMouseHandler {
        cocos2d_CCMouseHandler_handlerWithDelegate(pDelegate)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn new(arg1: *const cocos2d_CCMouseHandler) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseHandler_CCMouseHandler(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseHandler_CCMouseHandler1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCMouseHandler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMouseHandler_CCMouseHandler_destructor(this: *mut cocos2d_CCMouseHandler);
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDelegate@CCMouseHandler@cocos2d@@UAE_NPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    ) -> bool;
}
pub const cocos2d_ccTouchesMode_kCCTouchesAllAtOnce: cocos2d_ccTouchesMode = 0;
pub const cocos2d_ccTouchesMode_kCCTouchesOneByOne: cocos2d_ccTouchesMode = 1;
pub type cocos2d_ccTouchesMode = ::std::os::raw::c_int;
#[doc = " @brief CCLayer is a subclass of CCNode that implements the TouchEventsDelegate protocol.\n\nAll features from CCNode are valid, plus the following new features:\n- It can receive iPhone Touches\n- It can receive Accelerometer input"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayer {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTouchDelegate,
    pub _base_2: cocos2d_CCAccelerometerDelegate,
    pub _base_3: cocos2d_CCKeypadDelegate,
    pub _base_4: cocos2d_CCKeyboardDelegate,
    pub _base_5: cocos2d_CCMouseDelegate,
    pub m_bTouchEnabled: bool,
    pub m_bAccelerometerEnabled: bool,
    pub m_bKeypadEnabled: bool,
    pub m_bKeyboardEnabled: bool,
    pub m_bMouseEnabled: bool,
    pub m_pScriptTouchHandlerEntry: *mut cocos2d_CCTouchScriptHandlerEntry,
    pub m_pScriptKeypadHandlerEntry: *mut cocos2d_CCScriptHandlerEntry,
    pub m_pScriptAccelerateHandlerEntry: *mut cocos2d_CCScriptHandlerEntry,
    pub m_nTouchPriority: ::std::os::raw::c_int,
    pub m_eTouchMode: cocos2d_ccTouchesMode,
    pub m_uPreviousPriority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLayer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayer>(),
        316usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayer>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTouchEnabled) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_bTouchEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAccelerometerEnabled) as usize - ptr as usize },
        285usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_bAccelerometerEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKeypadEnabled) as usize - ptr as usize },
        286usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_bKeypadEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bKeyboardEnabled) as usize - ptr as usize },
        287usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_bKeyboardEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bMouseEnabled) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_bMouseEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScriptTouchHandlerEntry) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_pScriptTouchHandlerEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScriptKeypadHandlerEntry) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_pScriptKeypadHandlerEntry)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_pScriptAccelerateHandlerEntry) as usize - ptr as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_pScriptAccelerateHandlerEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTouchPriority) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_nTouchPriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eTouchMode) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_eTouchMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uPreviousPriority) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayer),
            "::",
            stringify!(m_uPreviousPriority)
        )
    );
}
extern "C" {
    #[doc = " create one layer"]
    #[link_name = "\u{1}?create@CCLayer@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLayer_create() -> *mut cocos2d_CCLayer;
}
extern "thiscall" {
    #[link_name = "\u{1}?registerScriptAccelerateHandler@CCLayer@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCLayer_registerScriptAccelerateHandler(
        this: *mut cocos2d_CCLayer,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?unregisterScriptAccelerateHandler@CCLayer@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptAccelerateHandler(this: *mut cocos2d_CCLayer);
}
extern "thiscall" {
    #[doc = " Register keypad events handler"]
    #[link_name = "\u{1}?registerScriptKeypadHandler@CCLayer@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCLayer_registerScriptKeypadHandler(
        this: *mut cocos2d_CCLayer,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Unregister keypad events handler"]
    #[link_name = "\u{1}?unregisterScriptKeypadHandler@CCLayer@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptKeypadHandler(this: *mut cocos2d_CCLayer);
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLayer_CCLayer(this: *mut cocos2d_CCLayer);
}
impl cocos2d_CCLayer {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayer {
        cocos2d_CCLayer_create()
    }
    #[inline]
    pub unsafe fn registerScriptAccelerateHandler(&mut self, nHandler: ::std::os::raw::c_int) {
        cocos2d_CCLayer_registerScriptAccelerateHandler(self, nHandler)
    }
    #[inline]
    pub unsafe fn unregisterScriptAccelerateHandler(&mut self) {
        cocos2d_CCLayer_unregisterScriptAccelerateHandler(self)
    }
    #[inline]
    pub unsafe fn registerScriptKeypadHandler(&mut self, nHandler: ::std::os::raw::c_int) {
        cocos2d_CCLayer_registerScriptKeypadHandler(self, nHandler)
    }
    #[inline]
    pub unsafe fn unregisterScriptKeypadHandler(&mut self) {
        cocos2d_CCLayer_unregisterScriptKeypadHandler(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayer_CCLayer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCLayer@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLayer_CCLayer_destructor(this: *mut cocos2d_CCLayer);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchBegan@CCLayer@cocos2d@@UAE_NPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchBegan(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchMoved@CCLayer@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchMoved(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchEnded@CCLayer@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchEnded(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchCancelled@CCLayer@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchCancelled(
        this: *mut ::std::os::raw::c_void,
        pTouch: *mut cocos2d_CCTouch,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchesBegan@CCLayer@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesBegan(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchesMoved@CCLayer@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesMoved(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchesEnded@CCLayer@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesEnded(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchesCancelled@CCLayer@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCLayer_ccTouchesCancelled(
        this: *mut ::std::os::raw::c_void,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?didAccelerate@CCLayer@cocos2d@@UAEXPAVCCAcceleration@2@@Z"]
    pub fn cocos2d_CCLayer_didAccelerate(
        this: *mut ::std::os::raw::c_void,
        pAccelerationValue: *mut cocos2d_CCAcceleration,
    );
}
extern "thiscall" {
    #[doc = " If isTouchEnabled, this method is called onEnter. Override it to change the\nway CCLayer receives touch events.\n( Default: CCTouchDispatcher::sharedDispatcher()->addStandardDelegate(this,0); )\nExample:\nvoid CCLayer::registerWithTouchDispatcher()\n{\nCCTouchDispatcher::sharedDispatcher()->addTargetedDelegate(this,INT_MIN+1,true);\n}\n@since v0.8.0"]
    #[link_name = "\u{1}?registerWithTouchDispatcher@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_registerWithTouchDispatcher(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Register script touch events handler"]
    #[link_name = "\u{1}?registerScriptTouchHandler@CCLayer@cocos2d@@UAEXH_NH0@Z"]
    pub fn cocos2d_CCLayer_registerScriptTouchHandler(
        this: *mut ::std::os::raw::c_void,
        nHandler: ::std::os::raw::c_int,
        bIsMultiTouches: bool,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    );
}
extern "thiscall" {
    #[doc = " Unregister script touch events handler"]
    #[link_name = "\u{1}?unregisterScriptTouchHandler@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_unregisterScriptTouchHandler(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " whether or not it will receive Touch events.\nYou can enable / disable touch events with this property.\nOnly the touches of this node will be affected. This \"method\" is not propagated to it's children.\n@since v0.8.1"]
    #[link_name = "\u{1}?isTouchEnabled@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_isTouchEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTouchEnabled@CCLayer@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayer_setTouchEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?setTouchMode@CCLayer@cocos2d@@UAEXW4ccTouchesMode@2@@Z"]
    pub fn cocos2d_CCLayer_setTouchMode(
        this: *mut ::std::os::raw::c_void,
        mode: cocos2d_ccTouchesMode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getTouchMode@CCLayer@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCLayer_getTouchMode(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " priority of the touch events. Default is 0"]
    #[link_name = "\u{1}?setTouchPriority@CCLayer@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCLayer_setTouchPriority(
        this: *mut ::std::os::raw::c_void,
        priority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getTouchPriority@CCLayer@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCLayer_getTouchPriority(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " whether or not it will receive Accelerometer events\nYou can enable / disable accelerometer events with this property.\n@since v0.8.1"]
    #[link_name = "\u{1}?isAccelerometerEnabled@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_isAccelerometerEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setAccelerometerEnabled@CCLayer@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayer_setAccelerometerEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAccelerometerInterval@CCLayer@cocos2d@@UAEXN@Z"]
    pub fn cocos2d_CCLayer_setAccelerometerInterval(
        this: *mut ::std::os::raw::c_void,
        interval: f64,
    );
}
extern "thiscall" {
    #[doc = " whether or not it will receive keypad events\nYou can enable / disable accelerometer events with this property.\nit's new in cocos2d-x"]
    #[link_name = "\u{1}?isKeypadEnabled@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_isKeypadEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setKeypadEnabled@CCLayer@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayer_setKeypadEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?isKeyboardEnabled@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_isKeyboardEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setKeyboardEnabled@CCLayer@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayer_setKeyboardEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?isMouseEnabled@CCLayer@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayer_isMouseEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setMouseEnabled@CCLayer@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayer_setMouseEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?keyBackClicked@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_keyBackClicked(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?keyMenuClicked@CCLayer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayer_keyMenuClicked(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?keyDown@CCLayer@cocos2d@@UAEXW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCLayer_keyDown(this: *mut ::std::os::raw::c_void, arg1: cocos2d_enumKeyCodes);
}
#[doc = " CCLayerRGBA is a subclass of CCLayer that implements the CCRGBAProtocol protocol using a solid color as the background.\n\nAll features from CCLayer are valid, plus the following new features that propagate into children that conform to the CCRGBAProtocol:\n- opacity\n- RGB colors\n@since 2.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerRGBA {
    pub _base: cocos2d_CCLayer,
    pub _base_1: cocos2d_CCRGBAProtocol,
    pub _displayedOpacity: GLubyte,
    pub _realOpacity: GLubyte,
    pub _displayedColor: cocos2d_ccColor3B,
    pub _realColor: cocos2d_ccColor3B,
    pub _cascadeOpacityEnabled: bool,
    pub _cascadeColorEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerRGBA() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLayerRGBA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerRGBA>(),
        332usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerRGBA))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerRGBA>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerRGBA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._displayedOpacity) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_displayedOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._realOpacity) as usize - ptr as usize },
        321usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_realOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._displayedColor) as usize - ptr as usize },
        322usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_displayedColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._realColor) as usize - ptr as usize },
        325usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_realColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cascadeOpacityEnabled) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_cascadeOpacityEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cascadeColorEnabled) as usize - ptr as usize },
        329usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerRGBA),
            "::",
            stringify!(_cascadeColorEnabled)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayerRGBA@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLayerRGBA_CCLayerRGBA(this: *mut cocos2d_CCLayerRGBA);
}
impl cocos2d_CCLayerRGBA {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerRGBA_CCLayerRGBA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCLayerRGBA@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLayerRGBA_CCLayerRGBA_destructor(this: *mut cocos2d_CCLayerRGBA);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCLayerRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerRGBA_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getOpacity@CCLayerRGBA@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLayerRGBA_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedOpacity@CCLayerRGBA@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLayerRGBA_getDisplayedOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCLayerRGBA@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLayerRGBA_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedOpacity@CCLayerRGBA@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLayerRGBA_updateDisplayedOpacity(
        this: *mut ::std::os::raw::c_void,
        parentOpacity: GLubyte,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeOpacityEnabled@CCLayerRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerRGBA_isCascadeOpacityEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeOpacityEnabled@CCLayerRGBA@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayerRGBA_setCascadeOpacityEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeOpacityEnabled: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getColor@CCLayerRGBA@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerRGBA_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDisplayedColor@CCLayerRGBA@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerRGBA_getDisplayedColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setColor@CCLayerRGBA@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerRGBA_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?updateDisplayedColor@CCLayerRGBA@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerRGBA_updateDisplayedColor(
        this: *mut ::std::os::raw::c_void,
        parentColor: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCascadeColorEnabled@CCLayerRGBA@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerRGBA_isCascadeColorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setCascadeColorEnabled@CCLayerRGBA@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayerRGBA_setCascadeColorEnabled(
        this: *mut ::std::os::raw::c_void,
        cascadeColorEnabled: bool,
    );
}
#[doc = " @brief CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol.\n\nAll features from CCLayer are valid, plus the following new features:\n- opacity\n- RGB colors"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerColor {
    pub _base: cocos2d_CCLayerRGBA,
    pub _base_1: cocos2d_CCBlendProtocol,
    pub m_pSquareVertices: [cocos2d_ccVertex2F; 4usize],
    pub m_pSquareColors: [cocos2d_ccColor4F; 4usize],
    #[doc = " BlendFunction. Conforms to CCBlendProtocol protocol"]
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerColor() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLayerColor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerColor>(),
        440usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerColor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerColor>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerColor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSquareVertices) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerColor),
            "::",
            stringify!(m_pSquareVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSquareColors) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerColor),
            "::",
            stringify!(m_pSquareColors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBlendFunc) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerColor),
            "::",
            stringify!(m_tBlendFunc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLayerColor_create() -> *mut cocos2d_CCLayerColor;
}
extern "C" {
    #[doc = " creates a CCLayer with color, width and height in Points"]
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPAV12@ABU_ccColor4B@2@MM@Z"]
    pub fn cocos2d_CCLayerColor_create1(
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> *mut cocos2d_CCLayerColor;
}
extern "C" {
    #[doc = " creates a CCLayer with color. Width and height are the window size."]
    #[link_name = "\u{1}?create@CCLayerColor@cocos2d@@SAPAV12@ABU_ccColor4B@2@@Z"]
    pub fn cocos2d_CCLayerColor_create2(
        color: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerColor;
}
extern "thiscall" {
    #[doc = " change width in Points"]
    #[link_name = "\u{1}?changeWidth@CCLayerColor@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCLayerColor_changeWidth(this: *mut cocos2d_CCLayerColor, w: GLfloat);
}
extern "thiscall" {
    #[doc = " change height in Points"]
    #[link_name = "\u{1}?changeHeight@CCLayerColor@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCLayerColor_changeHeight(this: *mut cocos2d_CCLayerColor, h: GLfloat);
}
extern "thiscall" {
    #[doc = " change width and height in Points\n@since v0.8"]
    #[link_name = "\u{1}?changeWidthAndHeight@CCLayerColor@cocos2d@@QAEXMM@Z"]
    pub fn cocos2d_CCLayerColor_changeWidthAndHeight(
        this: *mut cocos2d_CCLayerColor,
        w: GLfloat,
        h: GLfloat,
    );
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCLayerColor@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLayerColor_CCLayerColor(this: *mut cocos2d_CCLayerColor);
}
impl cocos2d_CCLayerColor {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create()
    }
    #[inline]
    pub unsafe fn create1(
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create1(color, width, height)
    }
    #[inline]
    pub unsafe fn create2(color: *const cocos2d_ccColor4B) -> *mut cocos2d_CCLayerColor {
        cocos2d_CCLayerColor_create2(color)
    }
    #[inline]
    pub unsafe fn changeWidth(&mut self, w: GLfloat) {
        cocos2d_CCLayerColor_changeWidth(self, w)
    }
    #[inline]
    pub unsafe fn changeHeight(&mut self, h: GLfloat) {
        cocos2d_CCLayerColor_changeHeight(self, h)
    }
    #[inline]
    pub unsafe fn changeWidthAndHeight(&mut self, w: GLfloat, h: GLfloat) {
        cocos2d_CCLayerColor_changeWidthAndHeight(self, w, h)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerColor_CCLayerColor(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCLayerColor@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLayerColor_CCLayerColor_destructor(this: *mut cocos2d_CCLayerColor);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCLayerColor@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayerColor_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setContentSize@CCLayerColor@cocos2d@@UAEXABVCCSize@2@@Z"]
    pub fn cocos2d_CCLayerColor_setContentSize(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCSize,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCLayerColor@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerColor_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a CCLayer with color, width and height in Points"]
    #[link_name = "\u{1}?initWithColor@CCLayerColor@cocos2d@@UAE_NABU_ccColor4B@2@MM@Z"]
    pub fn cocos2d_CCLayerColor_initWithColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor4B,
        width: GLfloat,
        height: GLfloat,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a CCLayer with color. Width and height are the window size."]
    #[link_name = "\u{1}?initWithColor@CCLayerColor@cocos2d@@UAE_NABU_ccColor4B@2@@Z"]
    pub fn cocos2d_CCLayerColor_initWithColor1(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor4B,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " BlendFunction. Conforms to CCBlendProtocol protocol"]
    #[link_name = "\u{1}?getBlendFunc@CCLayerColor@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCLayerColor_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[doc = " BlendFunction. Conforms to CCBlendProtocol protocol"]
    #[link_name = "\u{1}?setBlendFunc@CCLayerColor@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCLayerColor_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " BlendFunction. Conforms to CCBlendProtocol protocol"]
    #[link_name = "\u{1}?setColor@CCLayerColor@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerColor_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCLayerColor@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLayerColor_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateColor@CCLayerColor@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCLayerColor_updateColor(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCLayerGradient is a subclass of CCLayerColor that draws gradients across the background.\n\nAll features from CCLayerColor are valid, plus the following new features:\n- direction\n- final color\n- interpolation mode\n\nColor is interpolated between the startColor and endColor along the given\nvector (starting at the origin, ending at the terminus).  If no vector is\nsupplied, it defaults to (0, -1) -- a fade from top to bottom.\n\nIf 'compressedInterpolation' is disabled, you will not see either the start or end color for\nnon-cardinal vectors; a smooth gradient implying both end points will be still\nbe drawn, however.\n\nIf ' compressedInterpolation' is enabled (default mode) you will see both the start and end colors of the gradient.\n\n@since v0.99.5"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerGradient {
    pub _base: cocos2d_CCLayerColor,
    pub m_startColor: cocos2d_ccColor3B,
    pub m_endColor: cocos2d_ccColor3B,
    pub m_cStartOpacity: GLubyte,
    pub m_cEndOpacity: GLubyte,
    pub m_AlongVector: cocos2d_CCPoint,
    #[doc = " Whether or not the interpolation will be compressed in order to display all the colors of the gradient both in canonical and non canonical vectors\nDefault: YES"]
    pub m_bCompressedInterpolation: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerGradient() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLayerGradient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerGradient>(),
        460usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerGradient))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerGradient>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerGradient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startColor) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_startColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_endColor) as usize - ptr as usize },
        443usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_endColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cStartOpacity) as usize - ptr as usize },
        446usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_cStartOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cEndOpacity) as usize - ptr as usize },
        447usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_cEndOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_AlongVector) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_AlongVector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCompressedInterpolation) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerGradient),
            "::",
            stringify!(m_bCompressedInterpolation)
        )
    );
}
extern "C" {
    #[doc = " Creates a full-screen CCLayer with a gradient between start and end."]
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPAV12@ABU_ccColor4B@2@0@Z"]
    pub fn cocos2d_CCLayerGradient_create(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerGradient;
}
extern "C" {
    #[doc = " Creates a full-screen CCLayer with a gradient between start and end in the direction of v."]
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPAV12@ABU_ccColor4B@2@0ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_create1(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLayerGradient;
}
extern "C" {
    #[link_name = "\u{1}?create@CCLayerGradient@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLayerGradient_create2() -> *mut cocos2d_CCLayerGradient;
}
impl cocos2d_CCLayerGradient {
    #[inline]
    pub unsafe fn create(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create(start, end)
    }
    #[inline]
    pub unsafe fn create1(
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create1(start, end, v)
    }
    #[inline]
    pub unsafe fn create2() -> *mut cocos2d_CCLayerGradient {
        cocos2d_CCLayerGradient_create2()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCLayerGradient@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerGradient_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes the CCLayer with a gradient between start and end.\n  @js init"]
    #[link_name = "\u{1}?initWithColor@CCLayerGradient@cocos2d@@UAE_NABU_ccColor4B@2@0@Z"]
    pub fn cocos2d_CCLayerGradient_initWithColor(
        this: *mut ::std::os::raw::c_void,
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes the CCLayer with a gradient between start and end in the direction of v.\n  @js init"]
    #[link_name = "\u{1}?initWithColor@CCLayerGradient@cocos2d@@UAE_NABU_ccColor4B@2@0ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_initWithColor1(
        this: *mut ::std::os::raw::c_void,
        start: *const cocos2d_ccColor4B,
        end: *const cocos2d_ccColor4B,
        v: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getStartColor@CCLayerGradient@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getStartColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStartColor@CCLayerGradient@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setStartColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getEndColor@CCLayerGradient@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getEndColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEndColor@CCLayerGradient@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setEndColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getStartOpacity@CCLayerGradient@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLayerGradient_getStartOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStartOpacity@CCLayerGradient@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLayerGradient_setStartOpacity(this: *mut ::std::os::raw::c_void, var: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?getEndOpacity@CCLayerGradient@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCLayerGradient_getEndOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEndOpacity@CCLayerGradient@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCLayerGradient_setEndOpacity(this: *mut ::std::os::raw::c_void, var: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?getVector@CCLayerGradient@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCLayerGradient_getVector(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[link_name = "\u{1}?setVector@CCLayerGradient@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCLayerGradient_setVector(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setCompressedInterpolation@CCLayerGradient@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCLayerGradient_setCompressedInterpolation(
        this: *mut ::std::os::raw::c_void,
        bCompressedInterpolation: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isCompressedInterpolation@CCLayerGradient@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCLayerGradient_isCompressedInterpolation(
        this: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?updateColor@CCLayerGradient@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCLayerGradient_updateColor(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCMultipleLayer is a CCLayer with the ability to multiplex it's children.\nFeatures:\n- It supports one or more children\n- Only one children will be active a time"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCLayerMultiplex {
    pub _base: cocos2d_CCLayer,
    pub m_nEnabledLayer: ::std::os::raw::c_uint,
    pub m_pLayers: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCLayerMultiplex() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCLayerMultiplex> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCLayerMultiplex>(),
        324usize,
        concat!("Size of: ", stringify!(cocos2d_CCLayerMultiplex))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCLayerMultiplex>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCLayerMultiplex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nEnabledLayer) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerMultiplex),
            "::",
            stringify!(m_nEnabledLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLayers) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCLayerMultiplex),
            "::",
            stringify!(m_pLayers)
        )
    );
}
extern "C" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?create@CCLayerMultiplex@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCLayerMultiplex_create() -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " creates a CCMultiplexLayer with an array of layers.\n @since v2.1\n @js NA"]
    #[link_name = "\u{1}?createWithArray@CCLayerMultiplex@cocos2d@@SAPAV12@PAVCCArray@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_createWithArray(
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " creates a CCLayerMultiplex with one or more layers using a variable argument list.\n @lua NA"]
    #[link_name = "\u{1}?create@CCLayerMultiplex@cocos2d@@SAPAV12@PAVCCLayer@2@ZZ"]
    pub fn cocos2d_CCLayerMultiplex_create1(
        layer: *mut cocos2d_CCLayer,
        ...
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "C" {
    #[doc = " lua script can not init with undetermined number of variables\n so add these functions to be used with lua."]
    #[link_name = "\u{1}?createWithLayer@CCLayerMultiplex@cocos2d@@SAPAV12@PAVCCLayer@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_createWithLayer(
        layer: *mut cocos2d_CCLayer,
    ) -> *mut cocos2d_CCLayerMultiplex;
}
extern "thiscall" {
    #[link_name = "\u{1}?addLayer@CCLayerMultiplex@cocos2d@@QAEXPAVCCLayer@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_addLayer(
        this: *mut cocos2d_CCLayerMultiplex,
        layer: *mut cocos2d_CCLayer,
    );
}
extern "thiscall" {
    #[doc = " initializes a MultiplexLayer with one or more layers using a variable argument list.\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?initWithLayers@CCLayerMultiplex@cocos2d@@QAE_NPAVCCLayer@2@PAD@Z"]
    pub fn cocos2d_CCLayerMultiplex_initWithLayers(
        this: *mut cocos2d_CCLayerMultiplex,
        layer: *mut cocos2d_CCLayer,
        params: va_list,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a CCMultiplexLayer with an array of layers\n  @since v2.1\n  @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCLayerMultiplex@cocos2d@@QAE_NPAVCCArray@2@@Z"]
    pub fn cocos2d_CCLayerMultiplex_initWithArray(
        this: *mut cocos2d_CCLayerMultiplex,
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?switchTo@CCLayerMultiplex@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCLayerMultiplex_switchTo(
        this: *mut cocos2d_CCLayerMultiplex,
        n: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " release the current layer and switches to another layer indexed by n.\nThe current (old) layer will be removed from it's parent with 'cleanup:YES'."]
    #[link_name = "\u{1}?switchToAndReleaseMe@CCLayerMultiplex@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCLayerMultiplex_switchToAndReleaseMe(
        this: *mut cocos2d_CCLayerMultiplex,
        n: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " @js ctor\n @lua NA"]
    #[link_name = "\u{1}??0CCLayerMultiplex@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCLayerMultiplex_CCLayerMultiplex(this: *mut cocos2d_CCLayerMultiplex);
}
impl cocos2d_CCLayerMultiplex {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_create()
    }
    #[inline]
    pub unsafe fn createWithArray(
        arrayOfLayers: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_createWithArray(arrayOfLayers)
    }
    #[inline]
    pub unsafe fn createWithLayer(layer: *mut cocos2d_CCLayer) -> *mut cocos2d_CCLayerMultiplex {
        cocos2d_CCLayerMultiplex_createWithLayer(layer)
    }
    #[inline]
    pub unsafe fn addLayer(&mut self, layer: *mut cocos2d_CCLayer) {
        cocos2d_CCLayerMultiplex_addLayer(self, layer)
    }
    #[inline]
    pub unsafe fn initWithLayers(&mut self, layer: *mut cocos2d_CCLayer, params: va_list) -> bool {
        cocos2d_CCLayerMultiplex_initWithLayers(self, layer, params)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, arrayOfLayers: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCLayerMultiplex_initWithArray(self, arrayOfLayers)
    }
    #[inline]
    pub unsafe fn switchTo(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCLayerMultiplex_switchTo(self, n)
    }
    #[inline]
    pub unsafe fn switchToAndReleaseMe(&mut self, n: ::std::os::raw::c_uint) {
        cocos2d_CCLayerMultiplex_switchToAndReleaseMe(self, n)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCLayerMultiplex_CCLayerMultiplex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCLayerMultiplex@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCLayerMultiplex_CCLayerMultiplex_destructor(
        this: *mut cocos2d_CCLayerMultiplex,
    );
}
#[doc = " @brief CCScene is a subclass of CCNode that is used only as an abstract concept.\n\nCCScene an CCNode are almost identical with the difference that CCScene has it's\nanchor point (by default) at the center of the screen.\n\nFor the moment CCScene has no other logic than that, but in future releases it might have\nadditional logic.\n\nIt is a good practice to use and CCScene as the parent of all your nodes."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScene {
    pub _base: cocos2d_CCNode,
    pub m_pIDK: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScene() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCScene> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScene>(),
        268usize,
        concat!("Size of: ", stringify!(cocos2d_CCScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScene>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScene))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIDK) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScene),
            "::",
            stringify!(m_pIDK)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCScene@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCScene_create() -> *mut cocos2d_CCScene;
}
extern "thiscall" {
    #[link_name = "\u{1}?getHighestChildZ@CCScene@cocos2d@@QAEHXZ"]
    pub fn cocos2d_CCScene_getHighestChildZ(this: *mut cocos2d_CCScene) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCScene@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCScene_CCScene(this: *mut cocos2d_CCScene);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCScene@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCScene_CCScene1(this: *mut cocos2d_CCScene, arg1: *const cocos2d_CCScene);
}
impl cocos2d_CCScene {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCScene {
        cocos2d_CCScene_create()
    }
    #[inline]
    pub unsafe fn getHighestChildZ(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCScene_getHighestChildZ(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScene_CCScene(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCScene) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScene_CCScene1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCScene@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCScene_CCScene_destructor(this: *mut cocos2d_CCScene);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCScene@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCScene_init(this: *mut ::std::os::raw::c_void) -> bool;
}
#[repr(C)]
pub struct cocos2d_CCTransitionEaseScene__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @brief CCTransitionEaseScene can ease the actions of the scene protocol.\n@since v0.8.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTransitionEaseScene {
    pub vtable_: *const cocos2d_CCTransitionEaseScene__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionEaseScene() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionEaseScene>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionEaseScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionEaseScene>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionEaseScene))
    );
}
#[doc = " An horizontal orientation where the Left is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationLeftOver: cocos2d_tOrientation = 0;
#[doc = " An horizontal orientation where the Right is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationRightOver: cocos2d_tOrientation = 1;
#[doc = " A vertical orientation where the Up is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationUpOver: cocos2d_tOrientation = 0;
#[doc = " A vertical orientation where the Bottom is nearer"]
pub const cocos2d_tOrientation_kCCTransitionOrientationDownOver: cocos2d_tOrientation = 1;
#[doc = " Orientation Type used by some transitions"]
pub type cocos2d_tOrientation = ::std::os::raw::c_int;
#[doc = " @brief Base class for CCTransition scenes"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionScene {
    pub _base: cocos2d_CCScene,
    pub m_pInScene: *mut cocos2d_CCScene,
    pub m_pOutScene: *mut cocos2d_CCScene,
    pub m_fDuration: f32,
    pub m_bIsInSceneOnTop: bool,
    pub m_bIsSendCleanupToScene: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionScene() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTransitionScene> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionScene>(),
        284usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionScene))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionScene>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionScene))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInScene) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_pInScene)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOutScene) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_pOutScene)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDuration) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_fDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsInSceneOnTop) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_bIsInSceneOnTop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsSendCleanupToScene) as usize - ptr as usize },
        281usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionScene),
            "::",
            stringify!(m_bIsSendCleanupToScene)
        )
    );
}
extern "C" {
    #[doc = " creates a base transition with duration and incoming scene"]
    #[link_name = "\u{1}?create@CCTransitionScene@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionScene_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionScene;
}
extern "thiscall" {
    #[doc = " called after the transition finishes"]
    #[link_name = "\u{1}?finish@CCTransitionScene@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTransitionScene_finish(this: *mut cocos2d_CCTransitionScene);
}
extern "thiscall" {
    #[doc = " used by some transitions to hide the outer scene"]
    #[link_name = "\u{1}?hideOutShowIn@CCTransitionScene@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTransitionScene_hideOutShowIn(this: *mut cocos2d_CCTransitionScene);
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionScene@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionScene_CCTransitionScene(this: *mut cocos2d_CCTransitionScene);
}
impl cocos2d_CCTransitionScene {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionScene {
        cocos2d_CCTransitionScene_create(t, scene)
    }
    #[inline]
    pub unsafe fn finish(&mut self) {
        cocos2d_CCTransitionScene_finish(self)
    }
    #[inline]
    pub unsafe fn hideOutShowIn(&mut self) {
        cocos2d_CCTransitionScene_hideOutShowIn(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionScene_CCTransitionScene(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionScene@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionScene_CCTransitionScene_destructor(
        this: *mut cocos2d_CCTransitionScene,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCTransitionScene@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionScene_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionScene@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionScene_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionScene@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionScene_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?cleanup@CCTransitionScene@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionScene_cleanup(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " initializes a transition with duration and incoming scene"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionScene@cocos2d@@UAE_NMPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionScene_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionScene@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionScene_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief A CCTransition that supports orientation like.\n Possible orientation: LeftOver, RightOver, UpOver, DownOver"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSceneOriented {
    pub _base: cocos2d_CCTransitionScene,
    pub m_eOrientation: cocos2d_tOrientation,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSceneOriented() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTransitionSceneOriented> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSceneOriented>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSceneOriented))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSceneOriented>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionSceneOriented)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eOrientation) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionSceneOriented),
            "::",
            stringify!(m_eOrientation)
        )
    );
}
extern "C" {
    #[doc = " creates a base transition with duration and incoming scene"]
    #[link_name = "\u{1}?create@CCTransitionSceneOriented@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionSceneOriented_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionSceneOriented;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSceneOriented@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented(
        this: *mut cocos2d_CCTransitionSceneOriented,
    );
}
impl cocos2d_CCTransitionSceneOriented {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionSceneOriented {
        cocos2d_CCTransitionSceneOriented_create(t, scene, orientation)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSceneOriented@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSceneOriented_CCTransitionSceneOriented_destructor(
        this: *mut cocos2d_CCTransitionSceneOriented,
    );
}
extern "thiscall" {
    #[doc = " initializes a transition with duration and incoming scene"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionSceneOriented@cocos2d@@UAE_NMPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionSceneOriented_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        orientation: cocos2d_tOrientation,
    ) -> bool;
}
#[doc = " @brief CCTransitionRotoZoom:\nRotate and zoom out the outgoing scene, and then rotate and zoom in the incoming"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionRotoZoom {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionRotoZoom() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionRotoZoom>(),
        284usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionRotoZoom))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionRotoZoom>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionRotoZoom))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionRotoZoom@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionRotoZoom_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionRotoZoom;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionRotoZoom@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom(
        this: *mut cocos2d_CCTransitionRotoZoom,
    );
}
impl cocos2d_CCTransitionRotoZoom {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionRotoZoom {
        cocos2d_CCTransitionRotoZoom_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionRotoZoom@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionRotoZoom_CCTransitionRotoZoom_destructor(
        this: *mut cocos2d_CCTransitionRotoZoom,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionRotoZoom@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionRotoZoom_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionJumpZoom:\nZoom out and jump the outgoing scene, and then jump and zoom in the incoming"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionJumpZoom {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionJumpZoom() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionJumpZoom>(),
        284usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionJumpZoom))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionJumpZoom>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionJumpZoom))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionJumpZoom@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionJumpZoom_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionJumpZoom;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionJumpZoom@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom(
        this: *mut cocos2d_CCTransitionJumpZoom,
    );
}
impl cocos2d_CCTransitionJumpZoom {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionJumpZoom {
        cocos2d_CCTransitionJumpZoom_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionJumpZoom@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionJumpZoom_CCTransitionJumpZoom_destructor(
        this: *mut cocos2d_CCTransitionJumpZoom,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionJumpZoom@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionJumpZoom_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInL:\nMove in from to the left the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInL {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInL>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInL>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInL@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInL;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInL@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInL_CCTransitionMoveInL(this: *mut cocos2d_CCTransitionMoveInL);
}
impl cocos2d_CCTransitionMoveInL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInL {
        cocos2d_CCTransitionMoveInL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInL_CCTransitionMoveInL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionMoveInL@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInL_CCTransitionMoveInL_destructor(
        this: *mut cocos2d_CCTransitionMoveInL,
    );
}
extern "thiscall" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInL@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionMoveInL_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the action that will be performed"]
    #[link_name = "\u{1}?action@CCTransitionMoveInL@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionMoveInL_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionMoveInL@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionMoveInL_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionMoveInL@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionMoveInL_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInR:\nMove in from to the right the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInR {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInR>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInR>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInR@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInR;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInR@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInR_CCTransitionMoveInR(this: *mut cocos2d_CCTransitionMoveInR);
}
impl cocos2d_CCTransitionMoveInR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInR {
        cocos2d_CCTransitionMoveInR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInR_CCTransitionMoveInR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionMoveInR@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInR_CCTransitionMoveInR_destructor(
        this: *mut cocos2d_CCTransitionMoveInR,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInR@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionMoveInR_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInT:\nMove in from to the top the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInT {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInT() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInT>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInT))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInT>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInT))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInT@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInT_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInT;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInT@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInT_CCTransitionMoveInT(this: *mut cocos2d_CCTransitionMoveInT);
}
impl cocos2d_CCTransitionMoveInT {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInT {
        cocos2d_CCTransitionMoveInT_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInT_CCTransitionMoveInT(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionMoveInT@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInT_CCTransitionMoveInT_destructor(
        this: *mut cocos2d_CCTransitionMoveInT,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInT@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionMoveInT_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionMoveInB:\nMove in from to the bottom the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionMoveInB {
    pub _base: cocos2d_CCTransitionMoveInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionMoveInB() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionMoveInB>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionMoveInB))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionMoveInB>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionMoveInB))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionMoveInB@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionMoveInB_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionMoveInB;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionMoveInB@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInB_CCTransitionMoveInB(this: *mut cocos2d_CCTransitionMoveInB);
}
impl cocos2d_CCTransitionMoveInB {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionMoveInB {
        cocos2d_CCTransitionMoveInB_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionMoveInB_CCTransitionMoveInB(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionMoveInB@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionMoveInB_CCTransitionMoveInB_destructor(
        this: *mut cocos2d_CCTransitionMoveInB,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initScenes@CCTransitionMoveInB@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionMoveInB_initScenes(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInL:\nSlide in the incoming scene from the left border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInL {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInL>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInL>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInL@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInL;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInL@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInL_CCTransitionSlideInL(
        this: *mut cocos2d_CCTransitionSlideInL,
    );
}
impl cocos2d_CCTransitionSlideInL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInL {
        cocos2d_CCTransitionSlideInL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInL_CCTransitionSlideInL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSlideInL@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInL_CCTransitionSlideInL_destructor(
        this: *mut cocos2d_CCTransitionSlideInL,
    );
}
extern "thiscall" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInL@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInL@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInL_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionSlideInL@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionSlideInL@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionSlideInL_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInL@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInL_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInR:\nSlide in the incoming scene from the right border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInR {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInR>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInR>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInR@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInR;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInR@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInR_CCTransitionSlideInR(
        this: *mut cocos2d_CCTransitionSlideInR,
    );
}
impl cocos2d_CCTransitionSlideInR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInR {
        cocos2d_CCTransitionSlideInR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInR_CCTransitionSlideInR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSlideInR@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInR_CCTransitionSlideInR_destructor(
        this: *mut cocos2d_CCTransitionSlideInR,
    );
}
extern "thiscall" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInR@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInR_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInR@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInR_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInR@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInR_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInB:\nSlide in the incoming scene from the bottom border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInB {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInB() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInB>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInB))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInB>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInB))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInB@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInB_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInB;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInB@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInB_CCTransitionSlideInB(
        this: *mut cocos2d_CCTransitionSlideInB,
    );
}
impl cocos2d_CCTransitionSlideInB {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInB {
        cocos2d_CCTransitionSlideInB_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInB_CCTransitionSlideInB(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSlideInB@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInB_CCTransitionSlideInB_destructor(
        this: *mut cocos2d_CCTransitionSlideInB,
    );
}
extern "thiscall" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInB@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInB_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInB@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInB_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInB@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInB_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSlideInT:\nSlide in the incoming scene from the top border."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSlideInT {
    pub _base: cocos2d_CCTransitionSlideInL,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSlideInT() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSlideInT>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSlideInT))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSlideInT>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSlideInT))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSlideInT@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSlideInT_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSlideInT;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSlideInT@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInT_CCTransitionSlideInT(
        this: *mut cocos2d_CCTransitionSlideInT,
    );
}
impl cocos2d_CCTransitionSlideInT {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionSlideInT {
        cocos2d_CCTransitionSlideInT_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSlideInT_CCTransitionSlideInT(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSlideInT@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSlideInT_CCTransitionSlideInT_destructor(
        this: *mut cocos2d_CCTransitionSlideInT,
    );
}
extern "thiscall" {
    #[doc = " initializes the scenes"]
    #[link_name = "\u{1}?initScenes@CCTransitionSlideInT@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInT_initScenes(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " returns the action that will be performed by the incoming and outgoing scene"]
    #[link_name = "\u{1}?action@CCTransitionSlideInT@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSlideInT_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionSlideInT@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionSlideInT_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief Shrink the outgoing scene while grow the incoming scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionShrinkGrow {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionShrinkGrow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionShrinkGrow>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionShrinkGrow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionShrinkGrow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionShrinkGrow))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionShrinkGrow@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionShrinkGrow_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionShrinkGrow;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionShrinkGrow@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow(
        this: *mut cocos2d_CCTransitionShrinkGrow,
    );
}
impl cocos2d_CCTransitionShrinkGrow {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionShrinkGrow {
        cocos2d_CCTransitionShrinkGrow_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionShrinkGrow@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_CCTransitionShrinkGrow_destructor(
        this: *mut cocos2d_CCTransitionShrinkGrow,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionShrinkGrow@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionShrinkGrow_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionShrinkGrow@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionShrinkGrow_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFlipX:\nFlips the screen horizontally.\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipX {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipX() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipX>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipX>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipX))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipX@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipX_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipX;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipX@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipX_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipX;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipX@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFlipX_CCTransitionFlipX(this: *mut cocos2d_CCTransitionFlipX);
}
impl cocos2d_CCTransitionFlipX {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipX {
        cocos2d_CCTransitionFlipX_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipX {
        cocos2d_CCTransitionFlipX_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipX_CCTransitionFlipX(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFlipX@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFlipX_CCTransitionFlipX_destructor(
        this: *mut cocos2d_CCTransitionFlipX,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipX@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFlipX_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFlipY:\nFlips the screen vertically.\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipY {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipY() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipY>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipY>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipY))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipY@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipY_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipY;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipY@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipY_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipY;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipY@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFlipY_CCTransitionFlipY(this: *mut cocos2d_CCTransitionFlipY);
}
impl cocos2d_CCTransitionFlipY {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipY {
        cocos2d_CCTransitionFlipY_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipY {
        cocos2d_CCTransitionFlipY_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipY_CCTransitionFlipY(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFlipY@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFlipY_CCTransitionFlipY_destructor(
        this: *mut cocos2d_CCTransitionFlipY,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipY@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFlipY_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFlipAngular:\nFlips the screen half horizontally and half vertically.\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFlipAngular {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFlipAngular() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFlipAngular>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFlipAngular))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFlipAngular>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFlipAngular))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipAngular@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionFlipAngular_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipAngular;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFlipAngular@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFlipAngular_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFlipAngular;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFlipAngular@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular(
        this: *mut cocos2d_CCTransitionFlipAngular,
    );
}
impl cocos2d_CCTransitionFlipAngular {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionFlipAngular {
        cocos2d_CCTransitionFlipAngular_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFlipAngular {
        cocos2d_CCTransitionFlipAngular_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFlipAngular@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFlipAngular_CCTransitionFlipAngular_destructor(
        this: *mut cocos2d_CCTransitionFlipAngular,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFlipAngular@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFlipAngular_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipX:\nFlips the screen horizontally doing a zoom out/in\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipX {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipX() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipX>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipX))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipX>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionZoomFlipX))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipX@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipX_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipX;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipX@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipX_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipX;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipX@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX(
        this: *mut cocos2d_CCTransitionZoomFlipX,
    );
}
impl cocos2d_CCTransitionZoomFlipX {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipX {
        cocos2d_CCTransitionZoomFlipX_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionZoomFlipX {
        cocos2d_CCTransitionZoomFlipX_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionZoomFlipX@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_CCTransitionZoomFlipX_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipX,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipX@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipX_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipY:\nFlips the screen vertically doing a little zooming out/in\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipY {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipY() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipY>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipY))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipY>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionZoomFlipY))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipY@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipY_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipY;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipY@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipY_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipY;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipY@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY(
        this: *mut cocos2d_CCTransitionZoomFlipY,
    );
}
impl cocos2d_CCTransitionZoomFlipY {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipY {
        cocos2d_CCTransitionZoomFlipY_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(t: f32, s: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionZoomFlipY {
        cocos2d_CCTransitionZoomFlipY_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionZoomFlipY@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_CCTransitionZoomFlipY_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipY,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipY@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipY_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionZoomFlipAngular:\nFlips the screen half horizontally and half vertically doing a little zooming out/in.\nThe front face is the outgoing scene and the back face is the incoming scene."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionZoomFlipAngular {
    pub _base: cocos2d_CCTransitionSceneOriented,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionZoomFlipAngular() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionZoomFlipAngular>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionZoomFlipAngular))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionZoomFlipAngular>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionZoomFlipAngular)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipAngular@cocos2d@@SAPAV12@MPAVCCScene@2@W4tOrientation@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionZoomFlipAngular@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionZoomFlipAngular@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular(
        this: *mut cocos2d_CCTransitionZoomFlipAngular,
    );
}
impl cocos2d_CCTransitionZoomFlipAngular {
    #[inline]
    pub unsafe fn create(
        t: f32,
        s: *mut cocos2d_CCScene,
        o: cocos2d_tOrientation,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular {
        cocos2d_CCTransitionZoomFlipAngular_create(t, s, o)
    }
    #[inline]
    pub unsafe fn create1(
        t: f32,
        s: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionZoomFlipAngular {
        cocos2d_CCTransitionZoomFlipAngular_create1(t, s)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionZoomFlipAngular@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_CCTransitionZoomFlipAngular_destructor(
        this: *mut cocos2d_CCTransitionZoomFlipAngular,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionZoomFlipAngular@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionZoomFlipAngular_onEnter(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFade:\nFade out the outgoing scene and then fade in the incoming scene.'''"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFade {
    pub _base: cocos2d_CCTransitionScene,
    pub m_tColor: cocos2d_ccColor4B,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFade() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTransitionFade> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFade>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFade))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFade>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFade))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tColor) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionFade),
            "::",
            stringify!(m_tColor)
        )
    );
}
extern "C" {
    #[doc = " creates the transition with a duration and with an RGB color\n Example: FadeTransition::create(2, scene, ccc3(255,0,0); // red color"]
    #[link_name = "\u{1}?create@CCTransitionFade@cocos2d@@SAPAV12@MPAVCCScene@2@ABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTransitionFade_create(
        duration: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> *mut cocos2d_CCTransitionFade;
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFade@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFade_create1(
        duration: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFade;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFade@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFade_CCTransitionFade(this: *mut cocos2d_CCTransitionFade);
}
impl cocos2d_CCTransitionFade {
    #[inline]
    pub unsafe fn create(
        duration: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> *mut cocos2d_CCTransitionFade {
        cocos2d_CCTransitionFade_create(duration, scene, color)
    }
    #[inline]
    pub unsafe fn create1(
        duration: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFade {
        cocos2d_CCTransitionFade_create1(duration, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFade_CCTransitionFade(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFade@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFade_CCTransitionFade_destructor(
        this: *mut cocos2d_CCTransitionFade,
    );
}
extern "thiscall" {
    #[doc = " initializes the transition with a duration and with an RGB color"]
    #[link_name = "\u{1}?initWithDuration@CCTransitionFade@cocos2d@@UAE_NMPAVCCScene@2@ABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTransitionFade_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        color: *const cocos2d_ccColor3B,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithDuration@CCTransitionFade@cocos2d@@UAE_NMPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFade_initWithDuration1(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFade@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFade_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionFade@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFade_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = "@brief CCTransitionCrossFade:\nCross fades two scenes using the CCRenderTexture object."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionCrossFade {
    pub _base: cocos2d_CCTransitionScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionCrossFade() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionCrossFade>(),
        284usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionCrossFade))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionCrossFade>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionCrossFade))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionCrossFade@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionCrossFade_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionCrossFade;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionCrossFade@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionCrossFade_CCTransitionCrossFade(
        this: *mut cocos2d_CCTransitionCrossFade,
    );
}
impl cocos2d_CCTransitionCrossFade {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionCrossFade {
        cocos2d_CCTransitionCrossFade_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionCrossFade_CCTransitionCrossFade(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionCrossFade@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionCrossFade_CCTransitionCrossFade_destructor(
        this: *mut cocos2d_CCTransitionCrossFade,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCTransitionCrossFade@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionCrossFade@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionCrossFade@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionCrossFade_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionTurnOffTiles:\nTurn off the tiles of the outgoing scene in random order"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionTurnOffTiles {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionTurnOffTiles() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionTurnOffTiles>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionTurnOffTiles))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionTurnOffTiles>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionTurnOffTiles)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionTurnOffTiles@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionTurnOffTiles_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionTurnOffTiles;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionTurnOffTiles@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles(
        this: *mut cocos2d_CCTransitionTurnOffTiles,
    );
}
impl cocos2d_CCTransitionTurnOffTiles {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionTurnOffTiles {
        cocos2d_CCTransitionTurnOffTiles_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionTurnOffTiles@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_CCTransitionTurnOffTiles_destructor(
        this: *mut cocos2d_CCTransitionTurnOffTiles,
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionTurnOffTiles@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionTurnOffTiles@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionTurnOffTiles_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionTurnOffTiles@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionTurnOffTiles_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionSplitCols:\nThe odd columns goes upwards while the even columns goes downwards."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSplitCols {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSplitCols() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSplitCols>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSplitCols))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSplitCols>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSplitCols))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSplitCols@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSplitCols_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitCols;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSplitCols@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSplitCols_CCTransitionSplitCols(
        this: *mut cocos2d_CCTransitionSplitCols,
    );
}
impl cocos2d_CCTransitionSplitCols {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitCols {
        cocos2d_CCTransitionSplitCols_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSplitCols_CCTransitionSplitCols(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSplitCols@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSplitCols_CCTransitionSplitCols_destructor(
        this: *mut cocos2d_CCTransitionSplitCols,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?action@CCTransitionSplitCols@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSplitCols_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionSplitCols@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionSplitCols_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionSplitCols@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionSplitCols_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionSplitRows:\nThe odd rows goes to the left while the even rows goes to the right."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionSplitRows {
    pub _base: cocos2d_CCTransitionSplitCols,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionSplitRows() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionSplitRows>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionSplitRows))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionSplitRows>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionSplitRows))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionSplitRows@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionSplitRows_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitRows;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionSplitRows@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionSplitRows_CCTransitionSplitRows(
        this: *mut cocos2d_CCTransitionSplitRows,
    );
}
impl cocos2d_CCTransitionSplitRows {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionSplitRows {
        cocos2d_CCTransitionSplitRows_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionSplitRows_CCTransitionSplitRows(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionSplitRows@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionSplitRows_CCTransitionSplitRows_destructor(
        this: *mut cocos2d_CCTransitionSplitRows,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?action@CCTransitionSplitRows@cocos2d@@UAEPAVCCActionInterval@2@XZ"]
    pub fn cocos2d_CCTransitionSplitRows_action(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeTR:\nFade the tiles of the outgoing scene from the left-bottom corner the to top-right corner."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeTR {
    pub _base: cocos2d_CCTransitionScene,
    pub _base_1: cocos2d_CCTransitionEaseScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeTR() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeTR>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeTR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeTR>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeTR))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeTR@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeTR;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeTR@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFadeTR_CCTransitionFadeTR(this: *mut cocos2d_CCTransitionFadeTR);
}
impl cocos2d_CCTransitionFadeTR {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeTR {
        cocos2d_CCTransitionFadeTR_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeTR_CCTransitionFadeTR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFadeTR@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFadeTR_CCTransitionFadeTR_destructor(
        this: *mut cocos2d_CCTransitionFadeTR,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeTR@cocos2d@@UAEPAVCCActionInterval@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionFadeTR@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionFadeTR_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?easeActionWithAction@CCTransitionFadeTR@cocos2d@@UAEPAVCCActionInterval@2@PAV32@@Z"]
    pub fn cocos2d_CCTransitionFadeTR_easeActionWithAction(
        this: *mut ::std::os::raw::c_void,
        action: *mut cocos2d_CCActionInterval,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionFadeTR@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionFadeTR_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTransitionFadeBL:\nFade the tiles of the outgoing scene from the top-right corner to the bottom-left corner."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeBL {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeBL() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeBL>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeBL))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeBL>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeBL))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeBL@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeBL_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeBL;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeBL@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFadeBL_CCTransitionFadeBL(this: *mut cocos2d_CCTransitionFadeBL);
}
impl cocos2d_CCTransitionFadeBL {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeBL {
        cocos2d_CCTransitionFadeBL_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeBL_CCTransitionFadeBL(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFadeBL@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFadeBL_CCTransitionFadeBL_destructor(
        this: *mut cocos2d_CCTransitionFadeBL,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeBL@cocos2d@@UAEPAVCCActionInterval@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeBL_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeUp:\n Fade the tiles of the outgoing scene from the bottom to the top."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeUp {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeUp() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeUp>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeUp))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeUp>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeUp))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeUp@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeUp_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeUp;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeUp@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFadeUp_CCTransitionFadeUp(this: *mut cocos2d_CCTransitionFadeUp);
}
impl cocos2d_CCTransitionFadeUp {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeUp {
        cocos2d_CCTransitionFadeUp_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeUp_CCTransitionFadeUp(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFadeUp@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFadeUp_CCTransitionFadeUp_destructor(
        this: *mut cocos2d_CCTransitionFadeUp,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeUp@cocos2d@@UAEPAVCCActionInterval@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeUp_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = " @brief CCTransitionFadeDown:\n Fade the tiles of the outgoing scene from the top to the bottom."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionFadeDown {
    pub _base: cocos2d_CCTransitionFadeTR,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionFadeDown() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionFadeDown>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionFadeDown))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionFadeDown>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionFadeDown))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionFadeDown@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionFadeDown_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionFadeDown;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionFadeDown@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionFadeDown_CCTransitionFadeDown(
        this: *mut cocos2d_CCTransitionFadeDown,
    );
}
impl cocos2d_CCTransitionFadeDown {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionFadeDown {
        cocos2d_CCTransitionFadeDown_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionFadeDown_CCTransitionFadeDown(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionFadeDown@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionFadeDown_CCTransitionFadeDown_destructor(
        this: *mut cocos2d_CCTransitionFadeDown,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionFadeDown@cocos2d@@UAEPAVCCActionInterval@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionFadeDown_actionWithSize(
        this: *mut ::std::os::raw::c_void,
        size: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
#[doc = "@brief A transition which peels back the bottom right hand corner of a scene\nto transition to the scene beneath it simulating a page turn.\n\nThis uses a 3DAction so it's strongly recommended that depth buffering\nis turned on in CCDirector using:\n\nCCDirector::sharedDirector()->setDepthBufferFormat(kDepthBuffer16);\n\n@since v0.8.2"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionPageTurn {
    pub _base: cocos2d_CCTransitionScene,
    pub m_bBack: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionPageTurn() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTransitionPageTurn> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionPageTurn>(),
        288usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionPageTurn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionPageTurn>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionPageTurn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bBack) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionPageTurn),
            "::",
            stringify!(m_bBack)
        )
    );
}
extern "C" {
    #[doc = " Creates a base transition with duration and incoming scene.\n If back is true then the effect is reversed to appear as if the incoming\n scene is being turned from left over the outgoing scene."]
    #[link_name = "\u{1}?create@CCTransitionPageTurn@cocos2d@@SAPAV12@MPAVCCScene@2@_N@Z"]
    pub fn cocos2d_CCTransitionPageTurn_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> *mut cocos2d_CCTransitionPageTurn;
}
extern "thiscall" {
    #[link_name = "\u{1}?actionWithSize@CCTransitionPageTurn@cocos2d@@QAEPAVCCActionInterval@2@ABVCCSize@2@@Z"]
    pub fn cocos2d_CCTransitionPageTurn_actionWithSize(
        this: *mut cocos2d_CCTransitionPageTurn,
        vector: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionPageTurn@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionPageTurn_CCTransitionPageTurn(
        this: *mut cocos2d_CCTransitionPageTurn,
    );
}
impl cocos2d_CCTransitionPageTurn {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> *mut cocos2d_CCTransitionPageTurn {
        cocos2d_CCTransitionPageTurn_create(t, scene, backwards)
    }
    #[inline]
    pub unsafe fn actionWithSize(
        &mut self,
        vector: *const cocos2d_CCSize,
    ) -> *mut cocos2d_CCActionInterval {
        cocos2d_CCTransitionPageTurn_actionWithSize(self, vector)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionPageTurn_CCTransitionPageTurn(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTransitionPageTurn@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTransitionPageTurn_CCTransitionPageTurn_destructor(
        this: *mut cocos2d_CCTransitionPageTurn,
    );
}
extern "thiscall" {
    #[doc = " Creates a base transition with duration and incoming scene.\n If back is true then the effect is reversed to appear as if the incoming\n scene is being turned from left over the outgoing scene."]
    #[link_name = "\u{1}?initWithDuration@CCTransitionPageTurn@cocos2d@@UAE_NMPAVCCScene@2@_N@Z"]
    pub fn cocos2d_CCTransitionPageTurn_initWithDuration(
        this: *mut ::std::os::raw::c_void,
        t: f32,
        scene: *mut cocos2d_CCScene,
        backwards: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionPageTurn@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionPageTurn_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionPageTurn@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionPageTurn_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " @addtogroup transition\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgress {
    pub _base: cocos2d_CCTransitionScene,
    pub m_fTo: f32,
    pub m_fFrom: f32,
    pub m_pSceneToBeModified: *mut cocos2d_CCScene,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgress() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTransitionProgress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgress>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgress))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgress>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTransitionProgress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTo) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_fTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrom) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_fFrom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSceneToBeModified) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTransitionProgress),
            "::",
            stringify!(m_pSceneToBeModified)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgress@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgress_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgress;
}
extern "thiscall" {
    #[doc = "  @js ctor"]
    #[link_name = "\u{1}??0CCTransitionProgress@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTransitionProgress_CCTransitionProgress(
        this: *mut cocos2d_CCTransitionProgress,
    );
}
impl cocos2d_CCTransitionProgress {
    #[inline]
    pub unsafe fn create(t: f32, scene: *mut cocos2d_CCScene) -> *mut cocos2d_CCTransitionProgress {
        cocos2d_CCTransitionProgress_create(t, scene)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTransitionProgress_CCTransitionProgress(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCTransitionProgress@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionProgress_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCTransitionProgress@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCTransitionProgress_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgress@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgress_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "thiscall" {
    #[link_name = "\u{1}?setupTransition@CCTransitionProgress@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionProgress_setupTransition(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionProgress@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionProgress_sceneOrder(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCTransitionRadialCCW transition.\nA counter clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressRadialCCW {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressRadialCCW() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressRadialCCW>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressRadialCCW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressRadialCCW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressRadialCCW)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressRadialCCW@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCCW_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCCW;
}
impl cocos2d_CCTransitionProgressRadialCCW {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCCW {
        cocos2d_CCTransitionProgressRadialCCW_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressRadialCCW@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " CCTransitionRadialCW transition.\nA counter clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressRadialCW {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressRadialCW() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressRadialCW>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressRadialCW)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressRadialCW>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressRadialCW)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressRadialCW@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCW_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCW;
}
impl cocos2d_CCTransitionProgressRadialCW {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressRadialCW {
        cocos2d_CCTransitionProgressRadialCW_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressRadialCW@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " CCTransitionProgressHorizontal transition.\nA  clock-wise radial transition to the next scene"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressHorizontal {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressHorizontal() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressHorizontal>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressHorizontal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressHorizontal>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressHorizontal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressHorizontal@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressHorizontal_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressHorizontal;
}
impl cocos2d_CCTransitionProgressHorizontal {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressHorizontal {
        cocos2d_CCTransitionProgressHorizontal_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressHorizontal@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressVertical {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressVertical() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressVertical>(),
        296usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCTransitionProgressVertical)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressVertical>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressVertical)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressVertical@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressVertical_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressVertical;
}
impl cocos2d_CCTransitionProgressVertical {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressVertical {
        cocos2d_CCTransitionProgressVertical_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressVertical@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressInOut {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressInOut() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressInOut>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgressInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressInOut>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressInOut)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressInOut@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressInOut_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressInOut;
}
impl cocos2d_CCTransitionProgressInOut {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressInOut {
        cocos2d_CCTransitionProgressInOut_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressInOut@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "thiscall" {
    #[link_name = "\u{1}?sceneOrder@CCTransitionProgressInOut@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionProgressInOut_sceneOrder(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setupTransition@CCTransitionProgressInOut@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTransitionProgressInOut_setupTransition(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTransitionProgressOutIn {
    pub _base: cocos2d_CCTransitionProgress,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTransitionProgressOutIn() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTransitionProgressOutIn>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCTransitionProgressOutIn))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTransitionProgressOutIn>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCTransitionProgressOutIn)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCTransitionProgressOutIn@cocos2d@@SAPAV12@MPAVCCScene@2@@Z"]
    pub fn cocos2d_CCTransitionProgressOutIn_create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressOutIn;
}
impl cocos2d_CCTransitionProgressOutIn {
    #[inline]
    pub unsafe fn create(
        t: f32,
        scene: *mut cocos2d_CCScene,
    ) -> *mut cocos2d_CCTransitionProgressOutIn {
        cocos2d_CCTransitionProgressOutIn_create(t, scene)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?progressTimerNodeWithRenderTexture@CCTransitionProgressOutIn@cocos2d@@MAEPAVCCProgressTimer@2@PAVCCRenderTexture@2@@Z"]
    pub fn cocos2d_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCRenderTexture,
    ) -> *mut cocos2d_CCProgressTimer;
}
#[doc = " @brief CCMenuItem base class\n\n  Subclass CCMenuItem (or any subclass) to create your custom CCMenuItem objects."]
#[repr(C)]
pub struct cocos2d_CCMenuItem {
    pub _base: cocos2d_CCNodeRGBA,
    #[doc = " whether or not the item is selected\n@since v0.8.2"]
    pub m_bSelected: bool,
    pub m_bEnabled: bool,
    pub m_pListener: *mut cocos2d_CCObject,
    pub m_pfnSelector: cocos2d_SEL_MenuHandler,
    pub m_nScriptTapHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItem() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenuItem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItem>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItem))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItem>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSelected) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_bSelected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bEnabled) as usize - ptr as usize },
        281usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_bEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pListener) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_pListener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnSelector) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_pfnSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScriptTapHandler) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItem),
            "::",
            stringify!(m_nScriptTapHandler)
        )
    );
}
extern "C" {
    #[doc = " Creates a CCMenuItem with no target/selector\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItem@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCMenuItem_create() -> *mut cocos2d_CCMenuItem;
}
extern "C" {
    #[doc = " Creates a CCMenuItem with a target/selector"]
    #[link_name = "\u{1}?create@CCMenuItem@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_create1(
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItem;
}
extern "thiscall" {
    #[doc = " Initializes a CCMenuItem with a target/selector\n @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCMenuItem@cocos2d@@QAE_NPAVCCObject@2@P832@AEX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_initWithTarget(
        this: *mut cocos2d_CCMenuItem,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Returns the outside box"]
    #[link_name = "\u{1}?rect@CCMenuItem@cocos2d@@QAE?AVCCRect@2@XZ"]
    pub fn cocos2d_CCMenuItem_rect(this: *mut cocos2d_CCMenuItem) -> cocos2d_CCRect;
}
extern "thiscall" {
    #[doc = " set the target/selector of the menu item"]
    #[link_name = "\u{1}?setTarget@CCMenuItem@cocos2d@@QAEXPAVCCObject@2@P832@AEX0@Z@Z"]
    pub fn cocos2d_CCMenuItem_setTarget(
        this: *mut cocos2d_CCMenuItem,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    );
}
impl cocos2d_CCMenuItem {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItem_create()
    }
    #[inline]
    pub unsafe fn create1(
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItem_create1(rec, selector)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItem_initWithTarget(self, rec, selector)
    }
    #[inline]
    pub unsafe fn rect(&mut self) -> cocos2d_CCRect {
        cocos2d_CCMenuItem_rect(self)
    }
    #[inline]
    pub unsafe fn setTarget(
        &mut self,
        rec: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) {
        cocos2d_CCMenuItem_setTarget(self, rec, selector)
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCMenuItem@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMenuItem_CCMenuItem_destructor(this: *mut cocos2d_CCMenuItem);
}
extern "thiscall" {
    #[doc = " Activate the item"]
    #[link_name = "\u{1}?activate@CCMenuItem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItem_activate(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " The item was selected (not activated), similar to \"mouse-over\""]
    #[link_name = "\u{1}?selected@CCMenuItem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItem_selected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " The item was unselected"]
    #[link_name = "\u{1}?unselected@CCMenuItem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItem_unselected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Register menu handler script function"]
    #[link_name = "\u{1}?registerScriptTapHandler@CCMenuItem@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCMenuItem_registerScriptTapHandler(
        this: *mut ::std::os::raw::c_void,
        nHandler: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?unregisterScriptTapHandler@CCMenuItem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItem_unregisterScriptTapHandler(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?isEnabled@CCMenuItem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCMenuItem_isEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEnabled@CCMenuItem@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCMenuItem_setEnabled(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?isSelected@CCMenuItem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCMenuItem_isSelected(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " @brief An abstract class for \"label\" CCMenuItemLabel items\nAny CCNode that supports the CCLabelProtocol protocol can be added.\nSupported nodes:\n- CCBitmapFontAtlas\n- CCLabelAtlas\n- CCLabelTTF"]
#[repr(C)]
pub struct cocos2d_CCMenuItemLabel {
    pub _base: cocos2d_CCMenuItem,
    #[doc = " the color that will be used to disable the item"]
    pub m_tDisabledColor: cocos2d_ccColor3B,
    #[doc = " Label that is rendered. It can be any CCNode that implements the CCLabelProtocol"]
    pub m_pLabel: *mut cocos2d_CCNode,
    pub m_tColorBackup: cocos2d_ccColor3B,
    pub m_fOriginalScale: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemLabel() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenuItemLabel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemLabel>(),
        312usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemLabel))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemLabel>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemLabel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tDisabledColor) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_tDisabledColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLabel) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_pLabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tColorBackup) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_tColorBackup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fOriginalScale) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemLabel),
            "::",
            stringify!(m_fOriginalScale)
        )
    );
}
extern "C" {
    #[doc = " creates a CCMenuItemLabel with a Label, target and selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemLabel@cocos2d@@SAPAV12@PAVCCNode@2@PAVCCObject@2@P842@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemLabel_create(
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemLabel;
}
extern "C" {
    #[doc = " creates a CCMenuItemLabel with a Label. Target and selector will be nil"]
    #[link_name = "\u{1}?create@CCMenuItemLabel@cocos2d@@SAPAV12@PAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_create1(
        label: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemLabel;
}
extern "thiscall" {
    #[doc = " initializes a CCMenuItemLabel with a Label, target and selector"]
    #[link_name = "\u{1}?initWithLabel@CCMenuItemLabel@cocos2d@@QAE_NPAVCCNode@2@PAVCCObject@2@P842@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemLabel_initWithLabel(
        this: *mut cocos2d_CCMenuItemLabel,
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " sets a new string to the inner label"]
    #[link_name = "\u{1}?setString@CCMenuItemLabel@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCMenuItemLabel_setString(
        this: *mut cocos2d_CCMenuItemLabel,
        label: *const ::std::os::raw::c_char,
    );
}
impl cocos2d_CCMenuItemLabel {
    #[inline]
    pub unsafe fn create(
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemLabel {
        cocos2d_CCMenuItemLabel_create(label, target, selector)
    }
    #[inline]
    pub unsafe fn create1(label: *mut cocos2d_CCNode) -> *mut cocos2d_CCMenuItemLabel {
        cocos2d_CCMenuItemLabel_create1(label)
    }
    #[inline]
    pub unsafe fn initWithLabel(
        &mut self,
        label: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemLabel_initWithLabel(self, label, target, selector)
    }
    #[inline]
    pub unsafe fn setString(&mut self, label: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemLabel_setString(self, label)
    }
}
extern "thiscall" {
    #[doc = " the color that will be used to disable the item"]
    #[link_name = "\u{1}?getDisabledColor@CCMenuItemLabel@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCMenuItemLabel_getDisabledColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[doc = " the color that will be used to disable the item"]
    #[link_name = "\u{1}?setDisabledColor@CCMenuItemLabel@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_setDisabledColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[doc = " Label that is rendered. It can be any CCNode that implements the CCLabelProtocol"]
    #[link_name = "\u{1}?getLabel@CCMenuItemLabel@cocos2d@@UAEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemLabel_getLabel(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " Label that is rendered. It can be any CCNode that implements the CCLabelProtocol"]
    #[link_name = "\u{1}?setLabel@CCMenuItemLabel@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemLabel_setLabel(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCMenuItemLabel@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMenuItemLabel_CCMenuItemLabel_destructor(this: *mut cocos2d_CCMenuItemLabel);
}
extern "thiscall" {
    #[link_name = "\u{1}?activate@CCMenuItemLabel@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemLabel_activate(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?selected@CCMenuItemLabel@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemLabel_selected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?unselected@CCMenuItemLabel@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemLabel_unselected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " Enable or disabled the CCMenuItemFont\n@warning setEnabled changes the RGB color of the font"]
    #[link_name = "\u{1}?setEnabled@CCMenuItemLabel@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCMenuItemLabel_setEnabled(this: *mut ::std::os::raw::c_void, enabled: bool);
}
#[doc = " @brief A CCMenuItemAtlasFont\nHelper class that creates a MenuItemLabel class with a LabelAtlas"]
#[repr(C)]
pub struct cocos2d_CCMenuItemAtlasFont {
    pub _base: cocos2d_CCMenuItemLabel,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemAtlasFont() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemAtlasFont>(),
        312usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemAtlasFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemAtlasFont>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemAtlasFont))
    );
}
extern "C" {
    #[doc = " creates a menu item from a string and atlas with a target/selector"]
    #[link_name = "\u{1}?create@CCMenuItemAtlasFont@cocos2d@@SAPAV12@PBD0HHD@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_create(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemAtlasFont;
}
extern "C" {
    #[doc = " creates a menu item from a string and atlas. Use it with MenuItemToggle\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemAtlasFont@cocos2d@@SAPAV12@PBD0HHDPAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_create1(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemAtlasFont;
}
extern "thiscall" {
    #[doc = " initializes a menu item from a string and atlas with a target/selector"]
    #[link_name = "\u{1}?initWithString@CCMenuItemAtlasFont@cocos2d@@QAE_NPBD0HHDPAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemAtlasFont_initWithString(
        this: *mut cocos2d_CCMenuItemAtlasFont,
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
impl cocos2d_CCMenuItemAtlasFont {
    #[inline]
    pub unsafe fn create(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemAtlasFont {
        cocos2d_CCMenuItemAtlasFont_create(value, charMapFile, itemWidth, itemHeight, startCharMap)
    }
    #[inline]
    pub unsafe fn create1(
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemAtlasFont {
        cocos2d_CCMenuItemAtlasFont_create1(
            value,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        value: *const ::std::os::raw::c_char,
        charMapFile: *const ::std::os::raw::c_char,
        itemWidth: ::std::os::raw::c_int,
        itemHeight: ::std::os::raw::c_int,
        startCharMap: ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemAtlasFont_initWithString(
            self,
            value,
            charMapFile,
            itemWidth,
            itemHeight,
            startCharMap,
            target,
            selector,
        )
    }
}
#[doc = " @brief A CCMenuItemFont\nHelper class that creates a CCMenuItemLabel class with a Label"]
#[repr(C)]
pub struct cocos2d_CCMenuItemFont {
    pub _base: cocos2d_CCMenuItemLabel,
    pub m_uFontSize: ::std::os::raw::c_uint,
    pub m_strFontName: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemFont() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenuItemFont> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemFont>(),
        340usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemFont))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemFont>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemFont))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uFontSize) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemFont),
            "::",
            stringify!(m_uFontSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strFontName) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemFont),
            "::",
            stringify!(m_strFontName)
        )
    );
}
extern "C" {
    #[doc = " set default font size"]
    #[link_name = "\u{1}?setFontSize@CCMenuItemFont@cocos2d@@SAXI@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontSize(s: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " get default font size"]
    #[link_name = "\u{1}?fontSize@CCMenuItemFont@cocos2d@@SAIXZ"]
    pub fn cocos2d_CCMenuItemFont_fontSize() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " set the default font name"]
    #[link_name = "\u{1}?setFontName@CCMenuItemFont@cocos2d@@SAXPBD@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontName(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " get the default font name"]
    #[link_name = "\u{1}?fontName@CCMenuItemFont@cocos2d@@SAPBDXZ"]
    pub fn cocos2d_CCMenuItemFont_fontName() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " creates a menu item from a string without target/selector. To be used with CCMenuItemToggle"]
    #[link_name = "\u{1}?create@CCMenuItemFont@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCMenuItemFont_create(
        value: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemFont;
}
extern "C" {
    #[doc = " creates a menu item from a string with a target/selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemFont@cocos2d@@SAPAV12@PBDPAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemFont_create1(
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemFont;
}
extern "thiscall" {
    #[doc = " initializes a menu item from a string with a target/selector"]
    #[link_name = "\u{1}?initWithString@CCMenuItemFont@cocos2d@@QAE_NPBDPAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemFont_initWithString(
        this: *mut cocos2d_CCMenuItemFont,
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " set font size\n c++ can not overload static and non-static member functions with the same parameter types\n so change the name to setFontSizeObj\n @js setFontSize"]
    #[link_name = "\u{1}?setFontSizeObj@CCMenuItemFont@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontSizeObj(
        this: *mut cocos2d_CCMenuItemFont,
        s: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " get font size\n  @js fontSize"]
    #[link_name = "\u{1}?fontSizeObj@CCMenuItemFont@cocos2d@@QAEIXZ"]
    pub fn cocos2d_CCMenuItemFont_fontSizeObj(
        this: *mut cocos2d_CCMenuItemFont,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " set the font name\n c++ can not overload static and non-static member functions with the same parameter types\n so change the name to setFontNameObj\n @js setFontName"]
    #[link_name = "\u{1}?setFontNameObj@CCMenuItemFont@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCMenuItemFont_setFontNameObj(
        this: *mut cocos2d_CCMenuItemFont,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = "  @js fontName"]
    #[link_name = "\u{1}?fontNameObj@CCMenuItemFont@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCMenuItemFont_fontNameObj(
        this: *mut cocos2d_CCMenuItemFont,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?recreateLabel@CCMenuItemFont@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCMenuItemFont_recreateLabel(this: *mut cocos2d_CCMenuItemFont);
}
impl cocos2d_CCMenuItemFont {
    #[inline]
    pub unsafe fn setFontSize(s: ::std::os::raw::c_uint) {
        cocos2d_CCMenuItemFont_setFontSize(s)
    }
    #[inline]
    pub unsafe fn fontSize() -> ::std::os::raw::c_uint {
        cocos2d_CCMenuItemFont_fontSize()
    }
    #[inline]
    pub unsafe fn setFontName(name: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemFont_setFontName(name)
    }
    #[inline]
    pub unsafe fn fontName() -> *const ::std::os::raw::c_char {
        cocos2d_CCMenuItemFont_fontName()
    }
    #[inline]
    pub unsafe fn create(value: *const ::std::os::raw::c_char) -> *mut cocos2d_CCMenuItemFont {
        cocos2d_CCMenuItemFont_create(value)
    }
    #[inline]
    pub unsafe fn create1(
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemFont {
        cocos2d_CCMenuItemFont_create1(value, target, selector)
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        value: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemFont_initWithString(self, value, target, selector)
    }
    #[inline]
    pub unsafe fn setFontSizeObj(&mut self, s: ::std::os::raw::c_uint) {
        cocos2d_CCMenuItemFont_setFontSizeObj(self, s)
    }
    #[inline]
    pub unsafe fn fontSizeObj(&mut self) -> ::std::os::raw::c_uint {
        cocos2d_CCMenuItemFont_fontSizeObj(self)
    }
    #[inline]
    pub unsafe fn setFontNameObj(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCMenuItemFont_setFontNameObj(self, name)
    }
    #[inline]
    pub unsafe fn fontNameObj(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCMenuItemFont_fontNameObj(self)
    }
    #[inline]
    pub unsafe fn recreateLabel(&mut self) {
        cocos2d_CCMenuItemFont_recreateLabel(self)
    }
}
#[doc = " @brief CCMenuItemSprite accepts CCNode<CCRGBAProtocol> objects as items.\nThe images has 3 different states:\n- unselected image\n- selected image\n- disabled image\n\n@since v0.8.0"]
#[repr(C)]
pub struct cocos2d_CCMenuItemSprite {
    pub _base: cocos2d_CCMenuItem,
    #[doc = " the image used when the item is not selected"]
    pub m_pNormalImage: *mut cocos2d_CCNode,
    #[doc = " the image used when the item is selected"]
    pub m_pSelectedImage: *mut cocos2d_CCNode,
    #[doc = " the image used when the item is disabled"]
    pub m_pDisabledImage: *mut cocos2d_CCNode,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemSprite() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenuItemSprite> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemSprite>(),
        308usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemSprite))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemSprite>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemSprite))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pNormalImage) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pNormalImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSelectedImage) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pSelectedImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDisabledImage) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemSprite),
            "::",
            stringify!(m_pDisabledImage)
        )
    );
}
extern "C" {
    #[doc = " creates a menu item with a normal, selected and disabled image"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPAV12@PAVCCNode@2@00@Z"]
    pub fn cocos2d_CCMenuItemSprite_create(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image with target/selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPAV12@PAVCCNode@2@0PAVCCObject@2@P842@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_create1(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image with target/selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemSprite@cocos2d@@SAPAV12@PAVCCNode@2@00PAVCCObject@2@P842@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_create2(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite;
}
extern "thiscall" {
    #[doc = " initializes a menu item with a normal, selected  and disabled image with target/selector"]
    #[link_name = "\u{1}?initWithNormalSprite@CCMenuItemSprite@cocos2d@@QAE_NPAVCCNode@2@00PAVCCObject@2@P842@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemSprite_initWithNormalSprite(
        this: *mut cocos2d_CCMenuItemSprite,
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
impl cocos2d_CCMenuItemSprite {
    #[inline]
    pub unsafe fn create(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create(normalSprite, selectedSprite, disabledSprite)
    }
    #[inline]
    pub unsafe fn create1(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create1(normalSprite, selectedSprite, target, selector)
    }
    #[inline]
    pub unsafe fn create2(
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemSprite {
        cocos2d_CCMenuItemSprite_create2(
            normalSprite,
            selectedSprite,
            disabledSprite,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn initWithNormalSprite(
        &mut self,
        normalSprite: *mut cocos2d_CCNode,
        selectedSprite: *mut cocos2d_CCNode,
        disabledSprite: *mut cocos2d_CCNode,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemSprite_initWithNormalSprite(
            self,
            normalSprite,
            selectedSprite,
            disabledSprite,
            target,
            selector,
        )
    }
}
extern "thiscall" {
    #[doc = " the image used when the item is not selected"]
    #[link_name = "\u{1}?getNormalImage@CCMenuItemSprite@cocos2d@@UAEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getNormalImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " the image used when the item is not selected"]
    #[link_name = "\u{1}?setNormalImage@CCMenuItemSprite@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setNormalImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " the image used when the item is selected"]
    #[link_name = "\u{1}?getSelectedImage@CCMenuItemSprite@cocos2d@@UAEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getSelectedImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " the image used when the item is selected"]
    #[link_name = "\u{1}?setSelectedImage@CCMenuItemSprite@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setSelectedImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " the image used when the item is disabled"]
    #[link_name = "\u{1}?getDisabledImage@CCMenuItemSprite@cocos2d@@UAEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCMenuItemSprite_getDisabledImage(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[doc = " the image used when the item is disabled"]
    #[link_name = "\u{1}?setDisabledImage@CCMenuItemSprite@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenuItemSprite_setDisabledImage(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = "@since v0.99.5"]
    #[link_name = "\u{1}?selected@CCMenuItemSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemSprite_selected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?unselected@CCMenuItemSprite@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemSprite_unselected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setEnabled@CCMenuItemSprite@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCMenuItemSprite_setEnabled(this: *mut ::std::os::raw::c_void, bEnabled: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateImagesVisibility@CCMenuItemSprite@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCMenuItemSprite_updateImagesVisibility(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCMenuItemImage accepts images as items.\nThe images has 3 different states:\n- unselected image\n- selected image\n- disabled image\n\nFor best results try that all images are of the same size"]
#[repr(C)]
pub struct cocos2d_CCMenuItemImage {
    pub _base: cocos2d_CCMenuItemSprite,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemImage() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemImage>(),
        308usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemImage))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemImage>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemImage))
    );
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPAV12@PBD0@Z"]
    pub fn cocos2d_CCMenuItemImage_create(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPAV12@PBD00@Z"]
    pub fn cocos2d_CCMenuItemImage_create1(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal and selected image with target/selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPAV12@PBD0PAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_create2(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "C" {
    #[doc = " creates a menu item with a normal,selected  and disabled image with target/selector\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPAV12@PBD00PAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_create3(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage;
}
extern "thiscall" {
    #[doc = " initializes a menu item with a normal, selected  and disabled image with target/selector"]
    #[link_name = "\u{1}?initWithNormalImage@CCMenuItemImage@cocos2d@@QAE_NPBD00PAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCMenuItemImage_initWithNormalImage(
        this: *mut cocos2d_CCMenuItemImage,
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " sets the sprite frame for the normal image"]
    #[link_name = "\u{1}?setNormalSpriteFrame@CCMenuItemImage@cocos2d@@QAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setNormalSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "thiscall" {
    #[doc = " sets the sprite frame for the selected image"]
    #[link_name = "\u{1}?setSelectedSpriteFrame@CCMenuItemImage@cocos2d@@QAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setSelectedSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "thiscall" {
    #[doc = " sets the sprite frame for the disabled image"]
    #[link_name = "\u{1}?setDisabledSpriteFrame@CCMenuItemImage@cocos2d@@QAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCMenuItemImage_setDisabledSpriteFrame(
        this: *mut cocos2d_CCMenuItemImage,
        frame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "C" {
    #[doc = " Creates an CCMenuItemImage.\n @js NA"]
    #[link_name = "\u{1}?create@CCMenuItemImage@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCMenuItemImage_create4() -> *mut cocos2d_CCMenuItemImage;
}
impl cocos2d_CCMenuItemImage {
    #[inline]
    pub unsafe fn create(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create(normalImage, selectedImage)
    }
    #[inline]
    pub unsafe fn create1(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create1(normalImage, selectedImage, disabledImage)
    }
    #[inline]
    pub unsafe fn create2(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create2(normalImage, selectedImage, target, selector)
    }
    #[inline]
    pub unsafe fn create3(
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create3(normalImage, selectedImage, disabledImage, target, selector)
    }
    #[inline]
    pub unsafe fn initWithNormalImage(
        &mut self,
        normalImage: *const ::std::os::raw::c_char,
        selectedImage: *const ::std::os::raw::c_char,
        disabledImage: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
    ) -> bool {
        cocos2d_CCMenuItemImage_initWithNormalImage(
            self,
            normalImage,
            selectedImage,
            disabledImage,
            target,
            selector,
        )
    }
    #[inline]
    pub unsafe fn setNormalSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setNormalSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn setSelectedSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setSelectedSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn setDisabledSpriteFrame(&mut self, frame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCMenuItemImage_setDisabledSpriteFrame(self, frame)
    }
    #[inline]
    pub unsafe fn create4() -> *mut cocos2d_CCMenuItemImage {
        cocos2d_CCMenuItemImage_create4()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCMenuItemImage@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCMenuItemImage_init(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " @brief A CCMenuItemToggle\nA simple container class that \"toggles\" it's inner items\nThe inner items can be any MenuItem"]
#[repr(C)]
pub struct cocos2d_CCMenuItemToggle {
    pub _base: cocos2d_CCMenuItem,
    #[doc = " returns the selected item"]
    pub m_uSelectedIndex: ::std::os::raw::c_uint,
    #[doc = " CCMutableArray that contains the subitems. You can add/remove items in runtime, and you can replace the array with a new one.\n@since v0.7.2"]
    pub m_pSubItems: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenuItemToggle() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenuItemToggle> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenuItemToggle>(),
        304usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenuItemToggle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenuItemToggle>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenuItemToggle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uSelectedIndex) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemToggle),
            "::",
            stringify!(m_uSelectedIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSubItems) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenuItemToggle),
            "::",
            stringify!(m_pSubItems)
        )
    );
}
extern "C" {
    #[doc = " creates a menu item from a CCArray with a target selector"]
    #[link_name = "\u{1}?createWithTarget@CCMenuItemToggle@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEX0@ZPAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_createWithTarget(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        menuItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " creates a menu item from a list of items with a target/selector"]
    #[link_name = "\u{1}?createWithTarget@CCMenuItemToggle@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEX0@ZPAVCCMenuItem@2@ZZ"]
    pub fn cocos2d_CCMenuItemToggle_createWithTarget1(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        ...
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "C" {
    #[doc = " creates a menu item with no target/selector and no items\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenuItemToggle@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCMenuItemToggle_create() -> *mut cocos2d_CCMenuItemToggle;
}
extern "thiscall" {
    #[doc = " initializes a menu item from a list of items with a target selector"]
    #[link_name = "\u{1}?initWithTarget@CCMenuItemToggle@cocos2d@@QAE_NPAVCCObject@2@P832@AEX0@ZPAVCCMenuItem@2@PAD@Z"]
    pub fn cocos2d_CCMenuItemToggle_initWithTarget(
        this: *mut cocos2d_CCMenuItemToggle,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " creates a menu item with a item"]
    #[link_name = "\u{1}?create@CCMenuItemToggle@cocos2d@@SAPAV12@PAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_create1(
        item: *mut cocos2d_CCMenuItem,
    ) -> *mut cocos2d_CCMenuItemToggle;
}
extern "thiscall" {
    #[doc = " initializes a menu item with a item"]
    #[link_name = "\u{1}?initWithItem@CCMenuItemToggle@cocos2d@@QAE_NPAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_initWithItem(
        this: *mut cocos2d_CCMenuItemToggle,
        item: *mut cocos2d_CCMenuItem,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " add more menu item"]
    #[link_name = "\u{1}?addSubItem@CCMenuItemToggle@cocos2d@@QAEXPAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_addSubItem(
        this: *mut cocos2d_CCMenuItemToggle,
        item: *mut cocos2d_CCMenuItem,
    );
}
extern "thiscall" {
    #[doc = " return the selected item"]
    #[link_name = "\u{1}?selectedItem@CCMenuItemToggle@cocos2d@@QAEPAVCCMenuItem@2@XZ"]
    pub fn cocos2d_CCMenuItemToggle_selectedItem(
        this: *mut cocos2d_CCMenuItemToggle,
    ) -> *mut cocos2d_CCMenuItem;
}
impl cocos2d_CCMenuItemToggle {
    #[inline]
    pub unsafe fn createWithTarget(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        menuItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_createWithTarget(target, selector, menuItems)
    }
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_create()
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_MenuHandler,
        item: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> bool {
        cocos2d_CCMenuItemToggle_initWithTarget(self, target, selector, item, args)
    }
    #[inline]
    pub unsafe fn create1(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenuItemToggle {
        cocos2d_CCMenuItemToggle_create1(item)
    }
    #[inline]
    pub unsafe fn initWithItem(&mut self, item: *mut cocos2d_CCMenuItem) -> bool {
        cocos2d_CCMenuItemToggle_initWithItem(self, item)
    }
    #[inline]
    pub unsafe fn addSubItem(&mut self, item: *mut cocos2d_CCMenuItem) {
        cocos2d_CCMenuItemToggle_addSubItem(self, item)
    }
    #[inline]
    pub unsafe fn selectedItem(&mut self) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenuItemToggle_selectedItem(self)
    }
}
extern "thiscall" {
    #[doc = " returns the selected item"]
    #[link_name = "\u{1}?getSelectedIndex@CCMenuItemToggle@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCMenuItemToggle_getSelectedIndex(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " returns the selected item"]
    #[link_name = "\u{1}?setSelectedIndex@CCMenuItemToggle@cocos2d@@UAEXI@Z"]
    pub fn cocos2d_CCMenuItemToggle_setSelectedIndex(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " CCMutableArray that contains the subitems. You can add/remove items in runtime, and you can replace the array with a new one.\n@since v0.7.2"]
    #[link_name = "\u{1}?getSubItems@CCMenuItemToggle@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCMenuItemToggle_getSubItems(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " CCMutableArray that contains the subitems. You can add/remove items in runtime, and you can replace the array with a new one.\n@since v0.7.2"]
    #[link_name = "\u{1}?setSubItems@CCMenuItemToggle@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenuItemToggle_setSubItems(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCMenuItemToggle@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMenuItemToggle_CCMenuItemToggle_destructor(
        this: *mut cocos2d_CCMenuItemToggle,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?activate@CCMenuItemToggle@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemToggle_activate(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?selected@CCMenuItemToggle@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemToggle_selected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?unselected@CCMenuItemToggle@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenuItemToggle_unselected(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setEnabled@CCMenuItemToggle@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCMenuItemToggle_setEnabled(this: *mut ::std::os::raw::c_void, var: bool);
}
pub const cocos2d_tCCMenuState_kCCMenuStateWaiting: cocos2d_tCCMenuState = 0;
pub const cocos2d_tCCMenuState_kCCMenuStateTrackingTouch: cocos2d_tCCMenuState = 1;
#[doc = " @addtogroup GUI\n @{\n @addtogroup menu\n @{"]
pub type cocos2d_tCCMenuState = ::std::os::raw::c_int;
pub const kCCMenuHandlerPriority: cocos2d__bindgen_ty_8 = -128;
pub type cocos2d__bindgen_ty_8 = ::std::os::raw::c_int;
#[doc = " @brief A CCMenu\n\n Features and Limitation:\n  - You can add MenuItem objects in runtime using addChild:\n  - But the only accepted children are MenuItem objects"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMenu {
    pub _base: cocos2d_CCLayerRGBA,
    #[doc = " whether or not the menu will receive events"]
    pub m_bEnabled: bool,
    pub m_eState: cocos2d_tCCMenuState,
    pub m_pSelectedItem: *mut cocos2d_CCMenuItem,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMenu() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMenu> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMenu>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCMenu))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMenu>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMenu))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bEnabled) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_bEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eState) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_eState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSelectedItem) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMenu),
            "::",
            stringify!(m_pSelectedItem)
        )
    );
}
extern "C" {
    #[doc = " creates an empty CCMenu"]
    #[link_name = "\u{1}?create@CCMenu@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCMenu_create() -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with CCMenuItem objects\n @lua NA"]
    #[link_name = "\u{1}?create@CCMenu@cocos2d@@SAPAV12@PAVCCMenuItem@2@ZZ"]
    pub fn cocos2d_CCMenu_create1(item: *mut cocos2d_CCMenuItem, ...) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with a CCArray of CCMenuItem objects\n @js NA"]
    #[link_name = "\u{1}?createWithArray@CCMenu@cocos2d@@SAPAV12@PAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_createWithArray(
        pArrayOfItems: *mut cocos2d_CCArray,
    ) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with it's item, then use addChild() to add\n other items. It is used for script, it can't init with undetermined\n number of variables.\n @js NA"]
    #[link_name = "\u{1}?createWithItem@CCMenu@cocos2d@@SAPAV12@PAVCCMenuItem@2@@Z"]
    pub fn cocos2d_CCMenu_createWithItem(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenu;
}
extern "C" {
    #[doc = " creates a CCMenu with CCMenuItem objects\n @js NA\n @lua NA"]
    #[link_name = "\u{1}?createWithItems@CCMenu@cocos2d@@SAPAV12@PAVCCMenuItem@2@PAD@Z"]
    pub fn cocos2d_CCMenu_createWithItems(
        firstItem: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> *mut cocos2d_CCMenu;
}
extern "thiscall" {
    #[doc = " initializes a CCMenu with a NSArray of CCMenuItem objects\n @lua NA"]
    #[link_name = "\u{1}?initWithArray@CCMenu@cocos2d@@QAE_NPAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_initWithArray(
        this: *mut cocos2d_CCMenu,
        pArrayOfItems: *mut cocos2d_CCArray,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " align items vertically"]
    #[link_name = "\u{1}?alignItemsVertically@CCMenu@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCMenu_alignItemsVertically(this: *mut cocos2d_CCMenu);
}
extern "thiscall" {
    #[doc = " align items vertically with padding\n@since v0.7.2"]
    #[link_name = "\u{1}?alignItemsVerticallyWithPadding@CCMenu@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCMenu_alignItemsVerticallyWithPadding(this: *mut cocos2d_CCMenu, padding: f32);
}
extern "thiscall" {
    #[doc = " align items horizontally"]
    #[link_name = "\u{1}?alignItemsHorizontally@CCMenu@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCMenu_alignItemsHorizontally(this: *mut cocos2d_CCMenu);
}
extern "thiscall" {
    #[doc = " align items horizontally with padding\n@since v0.7.2"]
    #[link_name = "\u{1}?alignItemsHorizontallyWithPadding@CCMenu@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCMenu_alignItemsHorizontallyWithPadding(
        this: *mut cocos2d_CCMenu,
        padding: f32,
    );
}
extern "C" {
    #[doc = " align items in rows of columns\n @code\n when this function bound to js,the input params are changed\n js:var alignItemsInColumns(...)\n @endcode\n @lua NA"]
    #[link_name = "\u{1}?alignItemsInColumns@CCMenu@cocos2d@@QAAXIZZ"]
    pub fn cocos2d_CCMenu_alignItemsInColumns(
        this: *mut cocos2d_CCMenu,
        columns: ::std::os::raw::c_uint,
        ...
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?alignItemsInColumns@CCMenu@cocos2d@@QAEXIPAD@Z"]
    pub fn cocos2d_CCMenu_alignItemsInColumns1(
        this: *mut cocos2d_CCMenu,
        columns: ::std::os::raw::c_uint,
        args: va_list,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?alignItemsInColumnsWithArray@CCMenu@cocos2d@@QAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_alignItemsInColumnsWithArray(
        this: *mut cocos2d_CCMenu,
        rows: *mut cocos2d_CCArray,
    );
}
extern "C" {
    #[doc = " align items in columns of rows\n @code\n when this function bound to js,the input params are changed\n js:var alignItemsInRows(...)\n @endcode\n @lua NA"]
    #[link_name = "\u{1}?alignItemsInRows@CCMenu@cocos2d@@QAAXIZZ"]
    pub fn cocos2d_CCMenu_alignItemsInRows(
        this: *mut cocos2d_CCMenu,
        rows: ::std::os::raw::c_uint,
        ...
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?alignItemsInRows@CCMenu@cocos2d@@QAEXIPAD@Z"]
    pub fn cocos2d_CCMenu_alignItemsInRows1(
        this: *mut cocos2d_CCMenu,
        rows: ::std::os::raw::c_uint,
        args: va_list,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?alignItemsInRowsWithArray@CCMenu@cocos2d@@QAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCMenu_alignItemsInRowsWithArray(
        this: *mut cocos2d_CCMenu,
        columns: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " set event handler priority. By default it is: kCCMenuTouchPriority"]
    #[link_name = "\u{1}?setHandlerPriority@CCMenu@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCMenu_setHandlerPriority(
        this: *mut cocos2d_CCMenu,
        newPriority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?itemForTouch@CCMenu@cocos2d@@IAEPAVCCMenuItem@2@PAVCCTouch@2@@Z"]
    pub fn cocos2d_CCMenu_itemForTouch(
        this: *mut cocos2d_CCMenu,
        touch: *mut cocos2d_CCTouch,
    ) -> *mut cocos2d_CCMenuItem;
}
impl cocos2d_CCMenu {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_create()
    }
    #[inline]
    pub unsafe fn createWithArray(pArrayOfItems: *mut cocos2d_CCArray) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithArray(pArrayOfItems)
    }
    #[inline]
    pub unsafe fn createWithItem(item: *mut cocos2d_CCMenuItem) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithItem(item)
    }
    #[inline]
    pub unsafe fn createWithItems(
        firstItem: *mut cocos2d_CCMenuItem,
        args: va_list,
    ) -> *mut cocos2d_CCMenu {
        cocos2d_CCMenu_createWithItems(firstItem, args)
    }
    #[inline]
    pub unsafe fn initWithArray(&mut self, pArrayOfItems: *mut cocos2d_CCArray) -> bool {
        cocos2d_CCMenu_initWithArray(self, pArrayOfItems)
    }
    #[inline]
    pub unsafe fn alignItemsVertically(&mut self) {
        cocos2d_CCMenu_alignItemsVertically(self)
    }
    #[inline]
    pub unsafe fn alignItemsVerticallyWithPadding(&mut self, padding: f32) {
        cocos2d_CCMenu_alignItemsVerticallyWithPadding(self, padding)
    }
    #[inline]
    pub unsafe fn alignItemsHorizontally(&mut self) {
        cocos2d_CCMenu_alignItemsHorizontally(self)
    }
    #[inline]
    pub unsafe fn alignItemsHorizontallyWithPadding(&mut self, padding: f32) {
        cocos2d_CCMenu_alignItemsHorizontallyWithPadding(self, padding)
    }
    #[inline]
    pub unsafe fn alignItemsInColumns(&mut self, columns: ::std::os::raw::c_uint, args: va_list) {
        cocos2d_CCMenu_alignItemsInColumns1(self, columns, args)
    }
    #[inline]
    pub unsafe fn alignItemsInColumnsWithArray(&mut self, rows: *mut cocos2d_CCArray) {
        cocos2d_CCMenu_alignItemsInColumnsWithArray(self, rows)
    }
    #[inline]
    pub unsafe fn alignItemsInRows(&mut self, rows: ::std::os::raw::c_uint, args: va_list) {
        cocos2d_CCMenu_alignItemsInRows1(self, rows, args)
    }
    #[inline]
    pub unsafe fn alignItemsInRowsWithArray(&mut self, columns: *mut cocos2d_CCArray) {
        cocos2d_CCMenu_alignItemsInRowsWithArray(self, columns)
    }
    #[inline]
    pub unsafe fn setHandlerPriority(&mut self, newPriority: ::std::os::raw::c_int) {
        cocos2d_CCMenu_setHandlerPriority(self, newPriority)
    }
    #[inline]
    pub unsafe fn itemForTouch(&mut self, touch: *mut cocos2d_CCTouch) -> *mut cocos2d_CCMenuItem {
        cocos2d_CCMenu_itemForTouch(self, touch)
    }
}
extern "thiscall" {
    #[doc = " initializes an empty CCMenu"]
    #[link_name = "\u{1}?init@CCMenu@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCMenu_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCMenu_addChild(this: *mut ::std::os::raw::c_void, child: *mut cocos2d_CCNode);
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCMenu_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCMenu@cocos2d@@UAEXPAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCMenu_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?registerWithTouchDispatcher@CCMenu@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenu_registerWithTouchDispatcher(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?removeChild@CCMenu@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCMenu_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[doc = "@brief For phone event handle functions"]
    #[link_name = "\u{1}?ccTouchBegan@CCMenu@cocos2d@@UAE_NPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchBegan(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchEnded@CCMenu@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchEnded(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchCancelled@CCMenu@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchCancelled(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?ccTouchMoved@CCMenu@cocos2d@@UAEXPAVCCTouch@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCMenu_ccTouchMoved(
        this: *mut ::std::os::raw::c_void,
        touch: *mut cocos2d_CCTouch,
        event: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[doc = "@since v0.99.5\noverride onExit\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCMenu@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMenu_onExit(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCClippingNode is a subclass of CCNode.\nIt draws its content (childs) clipped using a stencil.\nThe stencil is an other CCNode that will not be drawn.\nThe clipping is done using the alpha part of the stencil (adjusted with an alphaThreshold)."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCClippingNode {
    pub _base: cocos2d_CCNode,
    pub m_pStencil: *mut cocos2d_CCNode,
    pub m_fAlphaThreshold: GLfloat,
    pub m_bInverted: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCClippingNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCClippingNode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCClippingNode>(),
        276usize,
        concat!("Size of: ", stringify!(cocos2d_CCClippingNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCClippingNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCClippingNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pStencil) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_pStencil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAlphaThreshold) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_fAlphaThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bInverted) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCClippingNode),
            "::",
            stringify!(m_bInverted)
        )
    );
}
extern "C" {
    #[doc = " Creates and initializes a clipping node without a stencil."]
    #[link_name = "\u{1}?create@CCClippingNode@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCClippingNode_create() -> *mut cocos2d_CCClippingNode;
}
extern "C" {
    #[doc = " Creates and initializes a clipping node with an other node as its stencil.\nThe stencil node will be retained."]
    #[link_name = "\u{1}?create@CCClippingNode@cocos2d@@SAPAV12@PAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_create1(
        pStencil: *mut cocos2d_CCNode,
    ) -> *mut cocos2d_CCClippingNode;
}
extern "thiscall" {
    #[doc = " The CCNode to use as a stencil to do the clipping.\nThe stencil node will be retained.\nThis default to nil."]
    #[link_name = "\u{1}?getStencil@CCClippingNode@cocos2d@@QBEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCClippingNode_getStencil(
        this: *const cocos2d_CCClippingNode,
    ) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStencil@CCClippingNode@cocos2d@@QAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_setStencil(
        this: *mut cocos2d_CCClippingNode,
        pStencil: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[doc = " The alpha threshold.\nThe content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold.\nShould be a float between 0 and 1.\nThis default to 1 (so alpha test is disabled)."]
    #[link_name = "\u{1}?getAlphaThreshold@CCClippingNode@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCClippingNode_getAlphaThreshold(this: *const cocos2d_CCClippingNode)
        -> GLfloat;
}
extern "thiscall" {
    #[link_name = "\u{1}?setAlphaThreshold@CCClippingNode@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCClippingNode_setAlphaThreshold(
        this: *mut cocos2d_CCClippingNode,
        fAlphaThreshold: GLfloat,
    );
}
extern "thiscall" {
    #[doc = " Inverted. If this is set to YES,\nthe stencil is inverted, so the content is drawn where the stencil is NOT drawn.\nThis default to NO."]
    #[link_name = "\u{1}?isInverted@CCClippingNode@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCClippingNode_isInverted(this: *const cocos2d_CCClippingNode) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setInverted@CCClippingNode@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCClippingNode_setInverted(this: *mut cocos2d_CCClippingNode, bInverted: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCClippingNode@cocos2d@@IAE@XZ"]
    pub fn cocos2d_CCClippingNode_CCClippingNode(this: *mut cocos2d_CCClippingNode);
}
impl cocos2d_CCClippingNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCClippingNode {
        cocos2d_CCClippingNode_create()
    }
    #[inline]
    pub unsafe fn create1(pStencil: *mut cocos2d_CCNode) -> *mut cocos2d_CCClippingNode {
        cocos2d_CCClippingNode_create1(pStencil)
    }
    #[inline]
    pub unsafe fn getStencil(&self) -> *mut cocos2d_CCNode {
        cocos2d_CCClippingNode_getStencil(self)
    }
    #[inline]
    pub unsafe fn setStencil(&mut self, pStencil: *mut cocos2d_CCNode) {
        cocos2d_CCClippingNode_setStencil(self, pStencil)
    }
    #[inline]
    pub unsafe fn getAlphaThreshold(&self) -> GLfloat {
        cocos2d_CCClippingNode_getAlphaThreshold(self)
    }
    #[inline]
    pub unsafe fn setAlphaThreshold(&mut self, fAlphaThreshold: GLfloat) {
        cocos2d_CCClippingNode_setAlphaThreshold(self, fAlphaThreshold)
    }
    #[inline]
    pub unsafe fn isInverted(&self) -> bool {
        cocos2d_CCClippingNode_isInverted(self)
    }
    #[inline]
    pub unsafe fn setInverted(&mut self, bInverted: bool) {
        cocos2d_CCClippingNode_setInverted(self, bInverted)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCClippingNode_CCClippingNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCClippingNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCClippingNode_CCClippingNode_destructor(this: *mut cocos2d_CCClippingNode);
}
extern "thiscall" {
    #[doc = " Initializes a clipping node without a stencil."]
    #[link_name = "\u{1}?init@CCClippingNode@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCClippingNode_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a clipping node with an other node as its stencil.\nThe stencil node will be retained, and its parent will be set to this clipping node."]
    #[link_name = "\u{1}?init@CCClippingNode@cocos2d@@UAE_NPAVCCNode@2@@Z"]
    pub fn cocos2d_CCClippingNode_init1(
        this: *mut ::std::os::raw::c_void,
        pStencil: *mut cocos2d_CCNode,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCClippingNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCClippingNode_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnterTransitionDidFinish@CCClippingNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCClippingNode_onEnterTransitionDidFinish(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExitTransitionDidStart@CCClippingNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCClippingNode_onExitTransitionDidStart(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCClippingNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCClippingNode_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCClippingNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCClippingNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " MotionStreak.\nCreates a trailing path."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMotionStreak {
    pub _base: cocos2d_CCNodeRGBA,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_bFastMode: bool,
    pub m_bStartingPositionInitialized: bool,
    #[doc = " texture used for the motion streak"]
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    pub m_tPositionR: cocos2d_CCPoint,
    pub m_fStroke: f32,
    pub m_fFadeDelta: f32,
    pub m_fMinSeg: f32,
    pub m_uMaxPoints: ::std::os::raw::c_uint,
    pub m_uNuPoints: ::std::os::raw::c_uint,
    pub m_uPreviousNuPoints: ::std::os::raw::c_uint,
    #[doc = " Pointers"]
    pub m_pPointVertexes: *mut cocos2d_CCPoint,
    pub m_pPointState: *mut f32,
    pub m_pVertices: *mut cocos2d_ccVertex2F,
    pub m_pColorPointer: *mut GLubyte,
    pub m_pTexCoords: *mut cocos2d_ccTex2F,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMotionStreak() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMotionStreak> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMotionStreak>(),
        352usize,
        concat!("Size of: ", stringify!(cocos2d_CCMotionStreak))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMotionStreak>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMotionStreak))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bFastMode) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_bFastMode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_bStartingPositionInitialized) as usize - ptr as usize
        },
        285usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_bStartingPositionInitialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexture) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBlendFunc) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_tBlendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tPositionR) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_tPositionR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStroke) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_fStroke)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFadeDelta) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_fFadeDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fMinSeg) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_fMinSeg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMaxPoints) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_uMaxPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uNuPoints) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_uNuPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uPreviousNuPoints) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_uPreviousNuPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPointVertexes) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pPointVertexes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPointState) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pPointState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pVertices) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pVertices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pColorPointer) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pColorPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexCoords) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMotionStreak),
            "::",
            stringify!(m_pTexCoords)
        )
    );
}
extern "C" {
    #[doc = " creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture filename"]
    #[link_name = "\u{1}?create@CCMotionStreak@cocos2d@@SAPAV12@MMMABU_ccColor3B@2@PBD@Z"]
    pub fn cocos2d_CCMotionStreak_create(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMotionStreak;
}
extern "C" {
    #[doc = " creates and initializes a motion streak with fade in seconds, minimum segments, stroke's width, color, texture"]
    #[link_name = "\u{1}?create@CCMotionStreak@cocos2d@@SAPAV12@MMMABU_ccColor3B@2@PAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_create1(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCMotionStreak;
}
extern "thiscall" {
    #[doc = " initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture filename"]
    #[link_name = "\u{1}?initWithFade@CCMotionStreak@cocos2d@@QAE_NMMMABU_ccColor3B@2@PBD@Z"]
    pub fn cocos2d_CCMotionStreak_initWithFade(
        this: *mut cocos2d_CCMotionStreak,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a motion streak with fade in seconds, minimum segments, stroke's width, color and texture"]
    #[link_name = "\u{1}?initWithFade@CCMotionStreak@cocos2d@@QAE_NMMMABU_ccColor3B@2@PAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_initWithFade1(
        this: *mut cocos2d_CCMotionStreak,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " color used for the tint"]
    #[link_name = "\u{1}?tintWithColor@CCMotionStreak@cocos2d@@QAEXU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCMotionStreak_tintWithColor(
        this: *mut cocos2d_CCMotionStreak,
        colors: cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[doc = " Remove all living segments of the ribbon"]
    #[link_name = "\u{1}?reset@CCMotionStreak@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCMotionStreak_reset(this: *mut cocos2d_CCMotionStreak);
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCMotionStreak@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCMotionStreak_CCMotionStreak(this: *mut cocos2d_CCMotionStreak);
}
impl cocos2d_CCMotionStreak {
    #[inline]
    pub unsafe fn create(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCMotionStreak {
        cocos2d_CCMotionStreak_create(fade, minSeg, stroke, color, path)
    }
    #[inline]
    pub unsafe fn create1(
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> *mut cocos2d_CCMotionStreak {
        cocos2d_CCMotionStreak_create1(fade, minSeg, stroke, color, texture)
    }
    #[inline]
    pub unsafe fn initWithFade(
        &mut self,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        path: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCMotionStreak_initWithFade(self, fade, minSeg, stroke, color, path)
    }
    #[inline]
    pub unsafe fn initWithFade1(
        &mut self,
        fade: f32,
        minSeg: f32,
        stroke: f32,
        color: *const cocos2d_ccColor3B,
        texture: *mut cocos2d_CCTexture2D,
    ) -> bool {
        cocos2d_CCMotionStreak_initWithFade1(self, fade, minSeg, stroke, color, texture)
    }
    #[inline]
    pub unsafe fn tintWithColor(&mut self, colors: cocos2d_ccColor3B) {
        cocos2d_CCMotionStreak_tintWithColor(self, colors)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCMotionStreak_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMotionStreak_CCMotionStreak(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCMotionStreak@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMotionStreak_CCMotionStreak_destructor(this: *mut cocos2d_CCMotionStreak);
}
extern "thiscall" {
    #[doc = " Override super methods"]
    #[link_name = "\u{1}?setPosition@CCMotionStreak@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setPosition(
        this: *mut ::std::os::raw::c_void,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCMotionStreak@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCMotionStreak_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCMotionStreak@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCMotionStreak_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getTexture@CCMotionStreak@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCMotionStreak_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTexture@CCMotionStreak@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setBlendFunc@CCMotionStreak@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCMotionStreak_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCMotionStreak@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCMotionStreak_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[link_name = "\u{1}?getOpacity@CCMotionStreak@cocos2d@@UAEEXZ"]
    pub fn cocos2d_CCMotionStreak_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCMotionStreak@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCMotionStreak_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacityModifyRGB@CCMotionStreak@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCMotionStreak_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        bValue: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isOpacityModifyRGB@CCMotionStreak@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCMotionStreak_isOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = " Radial Counter-Clockwise"]
pub const cocos2d_CCProgressTimerType_kCCProgressTimerTypeRadial: cocos2d_CCProgressTimerType = 0;
#[doc = " Bar"]
pub const cocos2d_CCProgressTimerType_kCCProgressTimerTypeBar: cocos2d_CCProgressTimerType = 1;
#[doc = " Types of progress\n@since v0.99.1"]
pub type cocos2d_CCProgressTimerType = ::std::os::raw::c_int;
#[doc = "@brief CCProgressTimer is a subclass of CCNode.\nIt renders the inner sprite according to the percentage.\nThe progress can be Radial, Horizontal or vertical.\n@since v0.99.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProgressTimer {
    pub _base: cocos2d_CCNodeRGBA,
    pub m_eType: cocos2d_CCProgressTimerType,
    pub m_fPercentage: f32,
    pub m_pSprite: *mut cocos2d_CCSprite,
    pub m_nVertexDataCount: ::std::os::raw::c_int,
    pub m_pVertexData: *mut cocos2d_ccV2F_C4B_T2F,
    #[doc = "    Midpoint is used to modify the progress start position.\n    If you're using radials type then the midpoint changes the center point\n    If you're using bar type the the midpoint changes the bar growth\n        it expands from the center but clamps to the sprites edge so:\n        you want a left to right then set the midpoint all the way to ccp(0,y)\n        you want a right to left then set the midpoint all the way to ccp(1,y)\n        you want a bottom to top then set the midpoint all the way to ccp(x,0)\n        you want a top to bottom then set the midpoint all the way to ccp(x,1)"]
    pub m_tMidpoint: cocos2d_CCPoint,
    #[doc = "    This allows the bar type to move the component at a specific rate\n    Set the component to 0 to make sure it stays at 100%.\n    For example you want a left to right bar but not have the height stay 100%\n    Set the rate to be ccp(0,1); and set the midpoint to = ccp(0,.5f);"]
    pub m_tBarChangeRate: cocos2d_CCPoint,
    pub m_bReverseDirection: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProgressTimer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCProgressTimer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProgressTimer>(),
        320usize,
        concat!("Size of: ", stringify!(cocos2d_CCProgressTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProgressTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProgressTimer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eType) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_eType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fPercentage) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_fPercentage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSprite) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_pSprite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVertexDataCount) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_nVertexDataCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pVertexData) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_pVertexData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tMidpoint) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_tMidpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBarChangeRate) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_tBarChangeRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bReverseDirection) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProgressTimer),
            "::",
            stringify!(m_bReverseDirection)
        )
    );
}
extern "thiscall" {
    #[doc = " Initializes a progress timer with the sprite as the shape the timer goes through"]
    #[link_name = "\u{1}?initWithSprite@CCProgressTimer@cocos2d@@QAE_NPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_initWithSprite(
        this: *mut cocos2d_CCProgressTimer,
        sp: *mut cocos2d_CCSprite,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setPercentage@CCProgressTimer@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCProgressTimer_setPercentage(
        this: *mut cocos2d_CCProgressTimer,
        fPercentage: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setSprite@CCProgressTimer@cocos2d@@QAEXPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setSprite(
        this: *mut cocos2d_CCProgressTimer,
        pSprite: *mut cocos2d_CCSprite,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setType@CCProgressTimer@cocos2d@@QAEXW4CCProgressTimerType@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setType(
        this: *mut cocos2d_CCProgressTimer,
        type_: cocos2d_CCProgressTimerType,
    );
}
extern "thiscall" {
    #[doc = "  @js setReverseDirection"]
    #[link_name = "\u{1}?setReverseProgress@CCProgressTimer@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCProgressTimer_setReverseProgress(
        this: *mut cocos2d_CCProgressTimer,
        reverse: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setAnchorPoint@CCProgressTimer@cocos2d@@QAEXVCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setAnchorPoint(
        this: *mut cocos2d_CCProgressTimer,
        anchorPoint: cocos2d_CCPoint,
    );
}
extern "C" {
    #[doc = " Creates a progress timer with the sprite as the shape the timer goes through"]
    #[link_name = "\u{1}?create@CCProgressTimer@cocos2d@@SAPAV12@PAVCCSprite@2@@Z"]
    pub fn cocos2d_CCProgressTimer_create(
        sp: *mut cocos2d_CCSprite,
    ) -> *mut cocos2d_CCProgressTimer;
}
extern "thiscall" {
    #[link_name = "\u{1}?textureCoordFromAlphaPoint@CCProgressTimer@cocos2d@@IAE?AU_ccTex2F@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_textureCoordFromAlphaPoint(
        this: *mut cocos2d_CCProgressTimer,
        alpha: cocos2d_CCPoint,
    ) -> cocos2d_ccTex2F;
}
extern "thiscall" {
    #[link_name = "\u{1}?vertexFromAlphaPoint@CCProgressTimer@cocos2d@@IAE?AU_ccVertex2F@2@VCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_vertexFromAlphaPoint(
        this: *mut cocos2d_CCProgressTimer,
        alpha: cocos2d_CCPoint,
    ) -> cocos2d_ccVertex2F;
}
extern "thiscall" {
    #[link_name = "\u{1}?updateProgress@CCProgressTimer@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCProgressTimer_updateProgress(this: *mut cocos2d_CCProgressTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateBar@CCProgressTimer@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCProgressTimer_updateBar(this: *mut cocos2d_CCProgressTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateRadial@CCProgressTimer@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCProgressTimer_updateRadial(this: *mut cocos2d_CCProgressTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateColor@CCProgressTimer@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCProgressTimer_updateColor(this: *mut cocos2d_CCProgressTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}?boundaryTexCoord@CCProgressTimer@cocos2d@@IAE?AVCCPoint@2@D@Z"]
    pub fn cocos2d_CCProgressTimer_boundaryTexCoord(
        this: *mut cocos2d_CCProgressTimer,
        index: ::std::os::raw::c_char,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCProgressTimer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCProgressTimer_CCProgressTimer(this: *mut cocos2d_CCProgressTimer);
}
impl cocos2d_CCProgressTimer {
    #[inline]
    pub unsafe fn initWithSprite(&mut self, sp: *mut cocos2d_CCSprite) -> bool {
        cocos2d_CCProgressTimer_initWithSprite(self, sp)
    }
    #[inline]
    pub unsafe fn setPercentage(&mut self, fPercentage: f32) {
        cocos2d_CCProgressTimer_setPercentage(self, fPercentage)
    }
    #[inline]
    pub unsafe fn setSprite(&mut self, pSprite: *mut cocos2d_CCSprite) {
        cocos2d_CCProgressTimer_setSprite(self, pSprite)
    }
    #[inline]
    pub unsafe fn setType(&mut self, type_: cocos2d_CCProgressTimerType) {
        cocos2d_CCProgressTimer_setType(self, type_)
    }
    #[inline]
    pub unsafe fn setReverseProgress(&mut self, reverse: bool) {
        cocos2d_CCProgressTimer_setReverseProgress(self, reverse)
    }
    #[inline]
    pub unsafe fn setAnchorPoint(&mut self, anchorPoint: cocos2d_CCPoint) {
        cocos2d_CCProgressTimer_setAnchorPoint(self, anchorPoint)
    }
    #[inline]
    pub unsafe fn create(sp: *mut cocos2d_CCSprite) -> *mut cocos2d_CCProgressTimer {
        cocos2d_CCProgressTimer_create(sp)
    }
    #[inline]
    pub unsafe fn textureCoordFromAlphaPoint(&mut self, alpha: cocos2d_CCPoint) -> cocos2d_ccTex2F {
        cocos2d_CCProgressTimer_textureCoordFromAlphaPoint(self, alpha)
    }
    #[inline]
    pub unsafe fn vertexFromAlphaPoint(&mut self, alpha: cocos2d_CCPoint) -> cocos2d_ccVertex2F {
        cocos2d_CCProgressTimer_vertexFromAlphaPoint(self, alpha)
    }
    #[inline]
    pub unsafe fn updateProgress(&mut self) {
        cocos2d_CCProgressTimer_updateProgress(self)
    }
    #[inline]
    pub unsafe fn updateBar(&mut self) {
        cocos2d_CCProgressTimer_updateBar(self)
    }
    #[inline]
    pub unsafe fn updateRadial(&mut self) {
        cocos2d_CCProgressTimer_updateRadial(self)
    }
    #[inline]
    pub unsafe fn updateColor(&mut self) {
        cocos2d_CCProgressTimer_updateColor(self)
    }
    #[inline]
    pub unsafe fn boundaryTexCoord(&mut self, index: ::std::os::raw::c_char) -> cocos2d_CCPoint {
        cocos2d_CCProgressTimer_boundaryTexCoord(self, index)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCProgressTimer_CCProgressTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCProgressTimer@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCProgressTimer_CCProgressTimer_destructor(this: *mut cocos2d_CCProgressTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCProgressTimer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCProgressTimer_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setColor@CCProgressTimer@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setColor(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getColor@CCProgressTimer@cocos2d@@UBEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCProgressTimer_getColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?getOpacity@CCProgressTimer@cocos2d@@UBEEXZ"]
    pub fn cocos2d_CCProgressTimer_getOpacity(this: *mut ::std::os::raw::c_void) -> GLubyte;
}
extern "thiscall" {
    #[link_name = "\u{1}?setOpacity@CCProgressTimer@cocos2d@@UAEXE@Z"]
    pub fn cocos2d_CCProgressTimer_setOpacity(this: *mut ::std::os::raw::c_void, opacity: GLubyte);
}
extern "thiscall" {
    #[doc = "    Midpoint is used to modify the progress start position.\n    If you're using radials type then the midpoint changes the center point\n    If you're using bar type the the midpoint changes the bar growth\n        it expands from the center but clamps to the sprites edge so:\n        you want a left to right then set the midpoint all the way to ccp(0,y)\n        you want a right to left then set the midpoint all the way to ccp(1,y)\n        you want a bottom to top then set the midpoint all the way to ccp(x,0)\n        you want a top to bottom then set the midpoint all the way to ccp(x,1)"]
    #[link_name = "\u{1}?getMidpoint@CCProgressTimer@cocos2d@@UAE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCProgressTimer_getMidpoint(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = "    Midpoint is used to modify the progress start position.\n    If you're using radials type then the midpoint changes the center point\n    If you're using bar type the the midpoint changes the bar growth\n        it expands from the center but clamps to the sprites edge so:\n        you want a left to right then set the midpoint all the way to ccp(0,y)\n        you want a right to left then set the midpoint all the way to ccp(1,y)\n        you want a bottom to top then set the midpoint all the way to ccp(x,0)\n        you want a top to bottom then set the midpoint all the way to ccp(x,1)"]
    #[link_name = "\u{1}?setMidpoint@CCProgressTimer@cocos2d@@UAEXVCCPoint@2@@Z"]
    pub fn cocos2d_CCProgressTimer_setMidpoint(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_CCPoint,
    );
}
pub const cocos2d_eImageFormat_kCCImageFormatJPEG: cocos2d_eImageFormat = 0;
pub const cocos2d_eImageFormat_kCCImageFormatPNG: cocos2d_eImageFormat = 1;
#[doc = " @addtogroup textures\n @{"]
pub type cocos2d_eImageFormat = ::std::os::raw::c_int;
#[doc = " @addtogroup textures\n @{"]
pub use self::cocos2d_eImageFormat as cocos2d_tCCImageFormat;
#[doc = "@brief CCRenderTexture is a generic rendering target. To render things into it,\nsimply construct a render target, call begin on it, call visit on any cocos\nscenes or objects to render them, and call end. For convenience, render texture\nadds a sprite as it's display child with the results, so you can simply add\nthe render texture to your scene and treat it like any other CocosNode.\nThere are also functions for saving the render texture to disk in PNG or JPG format.\n\n@since v0.8.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCRenderTexture {
    pub _base: cocos2d_CCNode,
    #[doc = " The CCSprite being used.\nThe sprite, by default, will use the following blending function: GL_ONE, GL_ONE_MINUS_SRC_ALPHA.\nThe blending function can be changed in runtime by calling:\n- [[renderTexture sprite] setBlendFunc:(ccBlendFunc){GL_ONE, GL_ONE_MINUS_SRC_ALPHA}];"]
    pub m_pSprite: *mut cocos2d_CCSprite,
    pub m_uFBO: GLuint,
    pub m_uDepthRenderBufffer: GLuint,
    pub m_nOldFBO: GLint,
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    pub m_pTextureCopy: *mut cocos2d_CCTexture2D,
    pub m_pUITextureImage: *mut cocos2d_CCImage,
    pub m_ePixelFormat: GLenum,
    pub m_uClearFlags: GLbitfield,
    pub m_sClearColor: cocos2d_ccColor4F,
    pub m_fClearDepth: GLclampf,
    pub m_nClearStencil: GLint,
    pub m_bAutoDraw: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCRenderTexture() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCRenderTexture> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCRenderTexture>(),
        328usize,
        concat!("Size of: ", stringify!(cocos2d_CCRenderTexture))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCRenderTexture>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCRenderTexture))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSprite) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pSprite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uFBO) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uFBO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uDepthRenderBufffer) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uDepthRenderBufffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOldFBO) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_nOldFBO)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexture) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTextureCopy) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pTextureCopy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUITextureImage) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_pUITextureImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ePixelFormat) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_ePixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uClearFlags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_uClearFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sClearColor) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_sClearColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fClearDepth) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_fClearDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nClearStencil) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_nClearStencil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAutoDraw) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCRenderTexture),
            "::",
            stringify!(m_bAutoDraw)
        )
    );
}
extern "C" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPAV12@HHW4CCTexture2DPixelFormat@2@I@Z"]
    pub fn cocos2d_CCRenderTexture_create(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "C" {
    #[doc = " creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPAV12@HHW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_create1(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "C" {
    #[doc = " creates a RenderTexture object with width and height in Points, pixel format is RGBA8888"]
    #[link_name = "\u{1}?create@CCRenderTexture@cocos2d@@SAPAV12@HH@Z"]
    pub fn cocos2d_CCRenderTexture_create2(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCRenderTexture;
}
extern "thiscall" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid"]
    #[link_name = "\u{1}?initWithWidthAndHeight@CCRenderTexture@cocos2d@@QAE_NHHW4CCTexture2DPixelFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_initWithWidthAndHeight(
        this: *mut cocos2d_CCRenderTexture,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a RenderTexture object with width and height in Points and a pixel format( only RGB and RGBA formats are valid ) and depthStencil format"]
    #[link_name = "\u{1}?initWithWidthAndHeight@CCRenderTexture@cocos2d@@QAE_NHHW4CCTexture2DPixelFormat@2@I@Z"]
    pub fn cocos2d_CCRenderTexture_initWithWidthAndHeight1(
        this: *mut cocos2d_CCRenderTexture,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " starts grabbing"]
    #[link_name = "\u{1}?begin@CCRenderTexture@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCRenderTexture_begin(this: *mut cocos2d_CCRenderTexture);
}
extern "thiscall" {
    #[doc = " starts rendering to the texture while clearing the texture first.\nThis is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QAEXMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    );
}
extern "thiscall" {
    #[doc = " starts rendering to the texture while clearing the texture first.\nThis is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QAEXMMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear1(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
    );
}
extern "thiscall" {
    #[doc = " starts rendering to the texture while clearing the texture first.\nThis is more efficient then calling -clear first and then -begin"]
    #[link_name = "\u{1}?beginWithClear@CCRenderTexture@cocos2d@@QAEXMMMMMH@Z"]
    pub fn cocos2d_CCRenderTexture_beginWithClear2(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
        stencilValue: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " ends grabbing"]
    #[link_name = "\u{1}?end@CCRenderTexture@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCRenderTexture_end(this: *mut cocos2d_CCRenderTexture);
}
extern "thiscall" {
    #[doc = " clears the texture with a color"]
    #[link_name = "\u{1}?clear@CCRenderTexture@cocos2d@@QAEXMMMM@Z"]
    pub fn cocos2d_CCRenderTexture_clear(
        this: *mut cocos2d_CCRenderTexture,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    );
}
extern "thiscall" {
    #[doc = " clears the texture with a specified depth value"]
    #[link_name = "\u{1}?clearDepth@CCRenderTexture@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCRenderTexture_clearDepth(this: *mut cocos2d_CCRenderTexture, depthValue: f32);
}
extern "thiscall" {
    #[doc = " clears the texture with a specified stencil value"]
    #[link_name = "\u{1}?clearStencil@CCRenderTexture@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCRenderTexture_clearStencil(
        this: *mut cocos2d_CCRenderTexture,
        stencilValue: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?newCCImage@CCRenderTexture@cocos2d@@QAEPAVCCImage@2@_N@Z"]
    pub fn cocos2d_CCRenderTexture_newCCImage(
        this: *mut cocos2d_CCRenderTexture,
        flipImage: bool,
    ) -> *mut cocos2d_CCImage;
}
extern "thiscall" {
    #[doc = " saves the texture into a file using JPEG format. The file will be saved in the Documents folder.\nReturns YES if the operation is successful."]
    #[link_name = "\u{1}?saveToFile@CCRenderTexture@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCRenderTexture_saveToFile(
        this: *mut cocos2d_CCRenderTexture,
        szFilePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " saves the texture into a file. The format could be JPG or PNG. The file will be saved in the Documents folder.\nReturns YES if the operation is successful."]
    #[link_name = "\u{1}?saveToFile@CCRenderTexture@cocos2d@@QAE_NPBDW4eImageFormat@2@@Z"]
    pub fn cocos2d_CCRenderTexture_saveToFile1(
        this: *mut cocos2d_CCRenderTexture,
        name: *const ::std::os::raw::c_char,
        format: cocos2d_tCCImageFormat,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Listen \"come to background\" message, and save render texture.\nIt only has effect on Android."]
    #[link_name = "\u{1}?listenToBackground@CCRenderTexture@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCRenderTexture_listenToBackground(
        this: *mut cocos2d_CCRenderTexture,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Listen \"come to foreground\" message and restore the frame buffer object\nIt only has effect on Android."]
    #[link_name = "\u{1}?listenToForeground@CCRenderTexture@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCRenderTexture_listenToForeground(
        this: *mut cocos2d_CCRenderTexture,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. They can be OR'ed. Valid when \"autoDraw is YES."]
    #[link_name = "\u{1}?getClearFlags@CCRenderTexture@cocos2d@@QBEIXZ"]
    pub fn cocos2d_CCRenderTexture_getClearFlags(
        this: *const cocos2d_CCRenderTexture,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?setClearFlags@CCRenderTexture@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCRenderTexture_setClearFlags(
        this: *mut cocos2d_CCRenderTexture,
        uClearFlags: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Clear color value. Valid only when \"autoDraw\" is true."]
    #[link_name = "\u{1}?getClearColor@CCRenderTexture@cocos2d@@QBEABU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCRenderTexture_getClearColor(
        this: *const cocos2d_CCRenderTexture,
    ) -> *const cocos2d_ccColor4F;
}
extern "thiscall" {
    #[link_name = "\u{1}?setClearColor@CCRenderTexture@cocos2d@@QAEXABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCRenderTexture_setClearColor(
        this: *mut cocos2d_CCRenderTexture,
        clearColor: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " Value for clearDepth. Valid only when autoDraw is true."]
    #[link_name = "\u{1}?getClearDepth@CCRenderTexture@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCRenderTexture_getClearDepth(this: *const cocos2d_CCRenderTexture) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setClearDepth@CCRenderTexture@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCRenderTexture_setClearDepth(
        this: *mut cocos2d_CCRenderTexture,
        fClearDepth: f32,
    );
}
extern "thiscall" {
    #[doc = " Value for clear Stencil. Valid only when autoDraw is true"]
    #[link_name = "\u{1}?getClearStencil@CCRenderTexture@cocos2d@@QBEHXZ"]
    pub fn cocos2d_CCRenderTexture_getClearStencil(
        this: *const cocos2d_CCRenderTexture,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setClearStencil@CCRenderTexture@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCRenderTexture_setClearStencil(
        this: *mut cocos2d_CCRenderTexture,
        fClearStencil: f32,
    );
}
extern "thiscall" {
    #[doc = " When enabled, it will render its children into the texture automatically. Disabled by default for compatiblity reasons.\nWill be enabled in the future."]
    #[link_name = "\u{1}?isAutoDraw@CCRenderTexture@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCRenderTexture_isAutoDraw(this: *const cocos2d_CCRenderTexture) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setAutoDraw@CCRenderTexture@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCRenderTexture_setAutoDraw(this: *mut cocos2d_CCRenderTexture, bAutoDraw: bool);
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCRenderTexture@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCRenderTexture_CCRenderTexture(this: *mut cocos2d_CCRenderTexture);
}
impl cocos2d_CCRenderTexture {
    #[inline]
    pub unsafe fn create(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create(w, h, eFormat, uDepthStencilFormat)
    }
    #[inline]
    pub unsafe fn create1(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create1(w, h, eFormat)
    }
    #[inline]
    pub unsafe fn create2(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCRenderTexture {
        cocos2d_CCRenderTexture_create2(w, h)
    }
    #[inline]
    pub unsafe fn initWithWidthAndHeight(
        &mut self,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
    ) -> bool {
        cocos2d_CCRenderTexture_initWithWidthAndHeight(self, w, h, eFormat)
    }
    #[inline]
    pub unsafe fn initWithWidthAndHeight1(
        &mut self,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        eFormat: cocos2d_CCTexture2DPixelFormat,
        uDepthStencilFormat: GLuint,
    ) -> bool {
        cocos2d_CCRenderTexture_initWithWidthAndHeight1(self, w, h, eFormat, uDepthStencilFormat)
    }
    #[inline]
    pub unsafe fn begin(&mut self) {
        cocos2d_CCRenderTexture_begin(self)
    }
    #[inline]
    pub unsafe fn beginWithClear(&mut self, r: f32, g: f32, b: f32, a: f32) {
        cocos2d_CCRenderTexture_beginWithClear(self, r, g, b, a)
    }
    #[inline]
    pub unsafe fn beginWithClear1(&mut self, r: f32, g: f32, b: f32, a: f32, depthValue: f32) {
        cocos2d_CCRenderTexture_beginWithClear1(self, r, g, b, a, depthValue)
    }
    #[inline]
    pub unsafe fn beginWithClear2(
        &mut self,
        r: f32,
        g: f32,
        b: f32,
        a: f32,
        depthValue: f32,
        stencilValue: ::std::os::raw::c_int,
    ) {
        cocos2d_CCRenderTexture_beginWithClear2(self, r, g, b, a, depthValue, stencilValue)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        cocos2d_CCRenderTexture_end(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self, r: f32, g: f32, b: f32, a: f32) {
        cocos2d_CCRenderTexture_clear(self, r, g, b, a)
    }
    #[inline]
    pub unsafe fn clearDepth(&mut self, depthValue: f32) {
        cocos2d_CCRenderTexture_clearDepth(self, depthValue)
    }
    #[inline]
    pub unsafe fn clearStencil(&mut self, stencilValue: ::std::os::raw::c_int) {
        cocos2d_CCRenderTexture_clearStencil(self, stencilValue)
    }
    #[inline]
    pub unsafe fn newCCImage(&mut self, flipImage: bool) -> *mut cocos2d_CCImage {
        cocos2d_CCRenderTexture_newCCImage(self, flipImage)
    }
    #[inline]
    pub unsafe fn saveToFile(&mut self, szFilePath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCRenderTexture_saveToFile(self, szFilePath)
    }
    #[inline]
    pub unsafe fn saveToFile1(
        &mut self,
        name: *const ::std::os::raw::c_char,
        format: cocos2d_tCCImageFormat,
    ) -> bool {
        cocos2d_CCRenderTexture_saveToFile1(self, name, format)
    }
    #[inline]
    pub unsafe fn listenToBackground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCRenderTexture_listenToBackground(self, obj)
    }
    #[inline]
    pub unsafe fn listenToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCRenderTexture_listenToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn getClearFlags(&self) -> ::std::os::raw::c_uint {
        cocos2d_CCRenderTexture_getClearFlags(self)
    }
    #[inline]
    pub unsafe fn setClearFlags(&mut self, uClearFlags: ::std::os::raw::c_uint) {
        cocos2d_CCRenderTexture_setClearFlags(self, uClearFlags)
    }
    #[inline]
    pub unsafe fn getClearColor(&self) -> *const cocos2d_ccColor4F {
        cocos2d_CCRenderTexture_getClearColor(self)
    }
    #[inline]
    pub unsafe fn setClearColor(&mut self, clearColor: *const cocos2d_ccColor4F) {
        cocos2d_CCRenderTexture_setClearColor(self, clearColor)
    }
    #[inline]
    pub unsafe fn getClearDepth(&self) -> f32 {
        cocos2d_CCRenderTexture_getClearDepth(self)
    }
    #[inline]
    pub unsafe fn setClearDepth(&mut self, fClearDepth: f32) {
        cocos2d_CCRenderTexture_setClearDepth(self, fClearDepth)
    }
    #[inline]
    pub unsafe fn getClearStencil(&self) -> ::std::os::raw::c_int {
        cocos2d_CCRenderTexture_getClearStencil(self)
    }
    #[inline]
    pub unsafe fn setClearStencil(&mut self, fClearStencil: f32) {
        cocos2d_CCRenderTexture_setClearStencil(self, fClearStencil)
    }
    #[inline]
    pub unsafe fn isAutoDraw(&self) -> bool {
        cocos2d_CCRenderTexture_isAutoDraw(self)
    }
    #[inline]
    pub unsafe fn setAutoDraw(&mut self, bAutoDraw: bool) {
        cocos2d_CCRenderTexture_setAutoDraw(self, bAutoDraw)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCRenderTexture_CCRenderTexture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " The CCSprite being used.\nThe sprite, by default, will use the following blending function: GL_ONE, GL_ONE_MINUS_SRC_ALPHA.\nThe blending function can be changed in runtime by calling:\n- [[renderTexture sprite] setBlendFunc:(ccBlendFunc){GL_ONE, GL_ONE_MINUS_SRC_ALPHA}];"]
    #[link_name = "\u{1}?getSprite@CCRenderTexture@cocos2d@@UAEPAVCCSprite@2@XZ"]
    pub fn cocos2d_CCRenderTexture_getSprite(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCSprite;
}
extern "thiscall" {
    #[doc = " The CCSprite being used.\nThe sprite, by default, will use the following blending function: GL_ONE, GL_ONE_MINUS_SRC_ALPHA.\nThe blending function can be changed in runtime by calling:\n- [[renderTexture sprite] setBlendFunc:(ccBlendFunc){GL_ONE, GL_ONE_MINUS_SRC_ALPHA}];"]
    #[link_name = "\u{1}?setSprite@CCRenderTexture@cocos2d@@UAEXPAVCCSprite@2@@Z"]
    pub fn cocos2d_CCRenderTexture_setSprite(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCSprite,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCRenderTexture@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCRenderTexture_CCRenderTexture_destructor(this: *mut cocos2d_CCRenderTexture);
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCRenderTexture@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCRenderTexture_visit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCRenderTexture@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCRenderTexture_draw(this: *mut ::std::os::raw::c_void);
}
#[doc = " CCParticleBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call\n (often known as \"batch draw\").\n\n A CCParticleBatchNode can reference one and only one texture (one image file, one texture atlas).\n Only the CCParticleSystems that are contained in that texture can be added to the CCSpriteBatchNode.\n All CCParticleSystems added to a CCSpriteBatchNode are drawn in one OpenGL ES draw call.\n If the CCParticleSystems are not added to a CCParticleBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient.\n\n\n Limitations:\n - At the moment only CCParticleSystemQuad is supported\n - All systems need to be drawn with the same parameters, blend function, aliasing, texture\n\n Most efficient usage\n - Initialize the ParticleBatchNode with the texture and enough capacity for all the particle systems\n - Initialize all particle systems and add them as child to the batch node\n @since v1.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleBatchNode {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    #[doc = " the texture atlas used for drawing the quads"]
    pub m_pTextureAtlas: *mut cocos2d_CCTextureAtlas,
    #[doc = " the blend function used for drawing the quads"]
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleBatchNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParticleBatchNode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleBatchNode>(),
        280usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleBatchNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleBatchNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleBatchNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTextureAtlas) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleBatchNode),
            "::",
            stringify!(m_pTextureAtlas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBlendFunc) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleBatchNode),
            "::",
            stringify!(m_tBlendFunc)
        )
    );
}
extern "C" {
    #[doc = " initializes the particle system with CCTexture2D, a capacity of particles, which particle system to use"]
    #[link_name = "\u{1}?createWithTexture@CCParticleBatchNode@cocos2d@@SAPAV12@PAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "C" {
    #[doc = " initializes the particle system with the name of a file on disk (for a list of supported formats look at the CCTexture2D class), a capacity of particles"]
    #[link_name = "\u{1}?create@CCParticleBatchNode@cocos2d@@SAPAV12@PBDI@Z"]
    pub fn cocos2d_CCParticleBatchNode_create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "thiscall" {
    #[doc = " initializes the particle system with CCTexture2D, a capacity of particles"]
    #[link_name = "\u{1}?initWithTexture@CCParticleBatchNode@cocos2d@@QAE_NPAVCCTexture2D@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_initWithTexture(
        this: *mut cocos2d_CCParticleBatchNode,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the particle system with the name of a file on disk (for a list of supported formats look at the CCTexture2D class), a capacity of particles"]
    #[link_name = "\u{1}?initWithFile@CCParticleBatchNode@cocos2d@@QAE_NPBDI@Z"]
    pub fn cocos2d_CCParticleBatchNode_initWithFile(
        this: *mut cocos2d_CCParticleBatchNode,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Inserts a child into the CCParticleBatchNode"]
    #[link_name = "\u{1}?insertChild@CCParticleBatchNode@cocos2d@@QAEXPAVCCParticleSystem@2@I@Z"]
    pub fn cocos2d_CCParticleBatchNode_insertChild(
        this: *mut cocos2d_CCParticleBatchNode,
        pSystem: *mut cocos2d_CCParticleSystem,
        index: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeChildAtIndex@CCParticleBatchNode@cocos2d@@QAEXI_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeChildAtIndex(
        this: *mut cocos2d_CCParticleBatchNode,
        index: ::std::os::raw::c_uint,
        doCleanup: bool,
    );
}
extern "thiscall" {
    #[doc = " disables a particle by inserting a 0'd quad into the texture atlas"]
    #[link_name = "\u{1}?disableParticle@CCParticleBatchNode@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCParticleBatchNode_disableParticle(
        this: *mut cocos2d_CCParticleBatchNode,
        particleIndex: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleBatchNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCParticleBatchNode_CCParticleBatchNode(this: *mut cocos2d_CCParticleBatchNode);
}
impl cocos2d_CCParticleBatchNode {
    #[inline]
    pub unsafe fn createWithTexture(
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode {
        cocos2d_CCParticleBatchNode_createWithTexture(tex, capacity)
    }
    #[inline]
    pub unsafe fn create(
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleBatchNode {
        cocos2d_CCParticleBatchNode_create(fileImage, capacity)
    }
    #[inline]
    pub unsafe fn initWithTexture(
        &mut self,
        tex: *mut cocos2d_CCTexture2D,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCParticleBatchNode_initWithTexture(self, tex, capacity)
    }
    #[inline]
    pub unsafe fn initWithFile(
        &mut self,
        fileImage: *const ::std::os::raw::c_char,
        capacity: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCParticleBatchNode_initWithFile(self, fileImage, capacity)
    }
    #[inline]
    pub unsafe fn insertChild(
        &mut self,
        pSystem: *mut cocos2d_CCParticleSystem,
        index: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCParticleBatchNode_insertChild(self, pSystem, index)
    }
    #[inline]
    pub unsafe fn removeChildAtIndex(&mut self, index: ::std::os::raw::c_uint, doCleanup: bool) {
        cocos2d_CCParticleBatchNode_removeChildAtIndex(self, index, doCleanup)
    }
    #[inline]
    pub unsafe fn disableParticle(&mut self, particleIndex: ::std::os::raw::c_uint) {
        cocos2d_CCParticleBatchNode_disableParticle(self, particleIndex)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleBatchNode_CCParticleBatchNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCParticleBatchNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCParticleBatchNode_CCParticleBatchNode_destructor(
        this: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "thiscall" {
    #[doc = " Add a child into the CCParticleBatchNode"]
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCParticleBatchNode@cocos2d@@UAEXPAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCParticleBatchNode_addChild2(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " remove child from the CCParticleBatchNode"]
    #[link_name = "\u{1}?removeChild@CCParticleBatchNode@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reorderChild@CCParticleBatchNode@cocos2d@@UAEXPAVCCNode@2@H@Z"]
    pub fn cocos2d_CCParticleBatchNode_reorderChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCParticleBatchNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParticleBatchNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        doCleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCParticleBatchNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleBatchNode_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?getTexture@CCParticleBatchNode@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCParticleBatchNode_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTexture@CCParticleBatchNode@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setBlendFunc@CCParticleBatchNode@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCParticleBatchNode_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        blendFunc: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " returns the blending function used for the texture\n @js NA"]
    #[link_name = "\u{1}?getBlendFunc@CCParticleBatchNode@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCParticleBatchNode_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCParticleBatchNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleBatchNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " The Particle emitter lives forever"]
pub const kCCParticleDurationInfinity: cocos2d__bindgen_ty_9 = -1;
#[doc = " The starting size of the particle is equal to the ending size"]
pub const kCCParticleStartSizeEqualToEndSize: cocos2d__bindgen_ty_9 = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kCCParticleStartRadiusEqualToEndRadius: cocos2d__bindgen_ty_9 = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kParticleStartSizeEqualToEndSize: cocos2d__bindgen_ty_9 = -1;
#[doc = " The starting radius of the particle is equal to the ending radius"]
pub const kParticleDurationInfinity: cocos2d__bindgen_ty_9 = -1;
pub type cocos2d__bindgen_ty_9 = ::std::os::raw::c_int;
#[doc = " Gravity mode (A mode)"]
pub const kCCParticleModeGravity: cocos2d__bindgen_ty_10 = 0;
#[doc = " Radius mode (B mode)"]
pub const kCCParticleModeRadius: cocos2d__bindgen_ty_10 = 1;
pub type cocos2d__bindgen_ty_10 = ::std::os::raw::c_int;
#[doc = " Living particles are attached to the world and are unaffected by emitter repositioning."]
pub const cocos2d_tCCPositionType_kCCPositionTypeFree: cocos2d_tCCPositionType = 0;
#[doc = " Living particles are attached to the world but will follow the emitter repositioning.\nUse case: Attach an emitter to an sprite, and you want that the emitter follows the sprite."]
pub const cocos2d_tCCPositionType_kCCPositionTypeRelative: cocos2d_tCCPositionType = 1;
#[doc = " Living particles are attached to the emitter and are translated along with it."]
pub const cocos2d_tCCPositionType_kCCPositionTypeGrouped: cocos2d_tCCPositionType = 2;
#[doc = " @typedef tCCPositionType\npossible types of particle positions"]
pub type cocos2d_tCCPositionType = ::std::os::raw::c_int;
pub const kPositionTypeFree: cocos2d__bindgen_ty_11 = 0;
pub const kPositionTypeGrouped: cocos2d__bindgen_ty_11 = 2;
pub type cocos2d__bindgen_ty_11 = ::std::os::raw::c_int;
#[doc = "Structure that contains the values of each particle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle {
    pub pos: cocos2d_CCPoint,
    pub startPos: cocos2d_CCPoint,
    pub color: cocos2d_ccColor4F,
    pub deltaColor: cocos2d_ccColor4F,
    pub size: f32,
    pub deltaSize: f32,
    pub rotation: f32,
    pub deltaRotation: f32,
    pub timeToLive: f32,
    pub atlasIndex: ::std::os::raw::c_uint,
    pub modeA: cocos2d_sCCParticle__bindgen_ty_1,
    pub modeB: cocos2d_sCCParticle__bindgen_ty_2,
}
#[doc = "! Mode A: gravity, direction, radial accel, tangential accel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle__bindgen_ty_1 {
    pub dir: cocos2d_CCPoint,
    pub radialAccel: f32,
    pub tangentialAccel: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_sCCParticle__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radialAccel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(radialAccel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangentialAccel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_1),
            "::",
            stringify!(tangentialAccel)
        )
    );
}
#[doc = "! Mode B: radius mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sCCParticle__bindgen_ty_2 {
    pub angle: f32,
    pub degreesPerSecond: f32,
    pub radius: f32,
    pub deltaRadius: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_sCCParticle__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).degreesPerSecond) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(degreesPerSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deltaRadius) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle__bindgen_ty_2),
            "::",
            stringify!(deltaRadius)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_sCCParticle() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_sCCParticle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_sCCParticle>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_sCCParticle))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_sCCParticle>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_sCCParticle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startPos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(startPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deltaColor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deltaSize) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deltaRotation) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(deltaRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeToLive) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(timeToLive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).atlasIndex) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(atlasIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modeA) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(modeA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modeB) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_sCCParticle),
            "::",
            stringify!(modeB)
        )
    );
}
#[doc = "Structure that contains the values of each particle"]
pub type cocos2d_tCCParticle = cocos2d_sCCParticle;
#[doc = " @brief Particle System base class.\nAttributes of a Particle System:\n- emission rate of the particles\n- Gravity Mode (Mode A):\n- gravity\n- direction\n- speed +-  variance\n- tangential acceleration +- variance\n- radial acceleration +- variance\n- Radius Mode (Mode B):\n- startRadius +- variance\n- endRadius +- variance\n- rotate +- variance\n- Properties common to all modes:\n- life +- life variance\n- start spin +- variance\n- end spin +- variance\n- start size +- variance\n- end size +- variance\n- start color +- variance\n- end color +- variance\n- life +- variance\n- blending function\n- texture\n\ncocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).\n'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guaranteed in cocos2d,\ncocos2d uses a another approach, but the results are almost identical.\n\ncocos2d supports all the variables used by Particle Designer plus a bit more:\n- spinning particles (supported when using CCParticleSystemQuad)\n- tangential acceleration (Gravity mode)\n- radial acceleration (Gravity mode)\n- radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)\n\nIt is possible to customize any of the above mentioned properties in runtime. Example:\n\n@code\nemitter.radialAccel = 15;\nemitter.startSpin = 0;\n@endcode"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSystem {
    pub _base: cocos2d_CCNode,
    pub _base_1: cocos2d_CCTextureProtocol,
    pub m_sPlistFile: std_string,
    #[doc = "! time elapsed since the start of the system (in seconds)"]
    pub m_fElapsed: f32,
    pub modeA: cocos2d_CCParticleSystem__bindgen_ty_1,
    pub modeB: cocos2d_CCParticleSystem__bindgen_ty_2,
    #[doc = "! Array of particles"]
    pub m_pParticles: *mut cocos2d_tCCParticle,
    #[doc = "! How many particles can be emitted per second"]
    pub m_fEmitCounter: f32,
    #[doc = "!  particle idx"]
    pub m_uParticleIdx: ::std::os::raw::c_uint,
    #[doc = " weak reference to the CCSpriteBatchNode that renders the CCSprite"]
    pub m_pBatchNode: *mut cocos2d_CCParticleBatchNode,
    pub m_uAtlasIndex: ::std::os::raw::c_uint,
    pub m_bTransformSystemDirty: bool,
    pub m_uAllocatedParticles: ::std::os::raw::c_uint,
    #[doc = " Is the emitter active"]
    pub m_bIsActive: bool,
    #[doc = " Quantity of particles that are being simulated at the moment"]
    pub m_uParticleCount: ::std::os::raw::c_uint,
    #[doc = " How many seconds the emitter will run. -1 means 'forever'"]
    pub m_fDuration: f32,
    #[doc = " sourcePosition of the emitter"]
    pub m_tSourcePosition: cocos2d_CCPoint,
    #[doc = " Position variance of the emitter"]
    pub m_tPosVar: cocos2d_CCPoint,
    #[doc = " life, and life variation of each particle"]
    pub m_fLife: f32,
    #[doc = " life variance of each particle"]
    pub m_fLifeVar: f32,
    #[doc = " angle and angle variation of each particle"]
    pub m_fAngle: f32,
    #[doc = " angle variance of each particle"]
    pub m_fAngleVar: f32,
    #[doc = " start size in pixels of each particle"]
    pub m_fStartSize: f32,
    #[doc = " size variance in pixels of each particle"]
    pub m_fStartSizeVar: f32,
    #[doc = " end size in pixels of each particle"]
    pub m_fEndSize: f32,
    #[doc = " end size variance in pixels of each particle"]
    pub m_fEndSizeVar: f32,
    #[doc = " start color of each particle"]
    pub m_tStartColor: cocos2d_ccColor4F,
    #[doc = " start color variance of each particle"]
    pub m_tStartColorVar: cocos2d_ccColor4F,
    #[doc = " end color and end color variation of each particle"]
    pub m_tEndColor: cocos2d_ccColor4F,
    #[doc = " end color variance of each particle"]
    pub m_tEndColorVar: cocos2d_ccColor4F,
    #[doc = " end color variance of each particle"]
    pub m_fStartSpin: f32,
    #[doc = " end color variance of each particle"]
    pub m_fStartSpinVar: f32,
    #[doc = " end color variance of each particle"]
    pub m_fEndSpin: f32,
    #[doc = " end color variance of each particle"]
    pub m_fEndSpinVar: f32,
    #[doc = " emission rate of the particles"]
    pub m_fEmissionRate: f32,
    #[doc = " maximum particles of the system"]
    pub m_uTotalParticles: ::std::os::raw::c_uint,
    #[doc = " conforms to CocosNodeTexture protocol"]
    pub m_pTexture: *mut cocos2d_CCTexture2D,
    #[doc = " conforms to CocosNodeTexture protocol"]
    pub m_tBlendFunc: cocos2d_ccBlendFunc,
    #[doc = " does the alpha value modify color"]
    pub m_bOpacityModifyRGB: bool,
    #[doc = " whether or not the particles are using blend additive.\nIf enabled, the following blending function will be used.\n@code\nsource blend function = GL_SRC_ALPHA;\ndest blend function = GL_ONE;\n@endcode"]
    pub m_bIsBlendAdditive: bool,
    #[doc = " particles movement type: Free or Grouped\n@since v0.8"]
    pub m_ePositionType: cocos2d_tCCPositionType,
    #[doc = " whether or not the node will be auto-removed when it has no particles left.\nBy default it is false.\n@since v0.8"]
    pub m_bIsAutoRemoveOnFinish: bool,
    #[doc = " Switch between different kind of emitter modes:\n- kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration\n- kCCParticleModeRadius: uses radius movement + rotation"]
    pub m_nEmitterMode: ::std::os::raw::c_int,
}
#[doc = "! Mode A:Gravity + Tangential Accel + Radial Accel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCParticleSystem__bindgen_ty_1 {
    #[doc = " Gravity value. Only available in 'Gravity' mode."]
    pub gravity: cocos2d_CCPoint,
    #[doc = " speed of each particle. Only available in 'Gravity' mode."]
    pub speed: f32,
    #[doc = " speed variance of each particle. Only available in 'Gravity' mode."]
    pub speedVar: f32,
    #[doc = " tangential acceleration of each particle. Only available in 'Gravity' mode."]
    pub tangentialAccel: f32,
    #[doc = " tangential acceleration variance of each particle. Only available in 'Gravity' mode."]
    pub tangentialAccelVar: f32,
    #[doc = " radial acceleration of each particle. Only available in 'Gravity' mode."]
    pub radialAccel: f32,
    #[doc = " radial acceleration variance of each particle. Only available in 'Gravity' mode."]
    pub radialAccelVar: f32,
    #[doc = " set the rotation of each particle to its direction Only available in 'Gravity' mode."]
    pub rotationIsDir: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParticleSystem__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gravity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(gravity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speedVar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(speedVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangentialAccel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(tangentialAccel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tangentialAccelVar) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(tangentialAccelVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radialAccel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(radialAccel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radialAccelVar) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(radialAccelVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotationIsDir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_1),
            "::",
            stringify!(rotationIsDir)
        )
    );
}
#[doc = "! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCParticleSystem__bindgen_ty_2 {
    #[doc = " The starting radius of the particles. Only available in 'Radius' mode."]
    pub startRadius: f32,
    #[doc = " The starting radius variance of the particles. Only available in 'Radius' mode."]
    pub startRadiusVar: f32,
    #[doc = " The ending radius of the particles. Only available in 'Radius' mode."]
    pub endRadius: f32,
    #[doc = " The ending radius variance of the particles. Only available in 'Radius' mode."]
    pub endRadiusVar: f32,
    #[doc = " Number of degrees to rotate a particle around the source pos per second. Only available in 'Radius' mode."]
    pub rotatePerSecond: f32,
    #[doc = " Variance in degrees for rotatePerSecond. Only available in 'Radius' mode."]
    pub rotatePerSecondVar: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParticleSystem__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startRadius) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(startRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startRadiusVar) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(startRadiusVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endRadius) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(endRadius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endRadiusVar) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(endRadiusVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotatePerSecond) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(rotatePerSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotatePerSecondVar) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem__bindgen_ty_2),
            "::",
            stringify!(rotatePerSecondVar)
        )
    );
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystem() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParticleSystem> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystem>(),
        560usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystem>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSystem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sPlistFile) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_sPlistFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fElapsed) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fElapsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modeA) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(modeA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modeB) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(modeB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pParticles) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_pParticles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEmitCounter) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEmitCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uParticleIdx) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_uParticleIdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pBatchNode) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_pBatchNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAtlasIndex) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_uAtlasIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bTransformSystemDirty) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_bTransformSystemDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uAllocatedParticles) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_uAllocatedParticles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsActive) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_bIsActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uParticleCount) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_uParticleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDuration) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tSourcePosition) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tSourcePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tPosVar) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tPosVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fLife) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fLife)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fLifeVar) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fLifeVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngle) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fAngle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fAngleVar) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fAngleVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSize) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fStartSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSizeVar) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fStartSizeVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSize) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEndSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSizeVar) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEndSizeVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tStartColor) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tStartColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tStartColorVar) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tStartColorVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tEndColor) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tEndColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tEndColorVar) as usize - ptr as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tEndColorVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSpin) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fStartSpin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fStartSpinVar) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fStartSpinVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSpin) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEndSpin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEndSpinVar) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEndSpinVar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fEmissionRate) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_fEmissionRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTotalParticles) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_uTotalParticles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTexture) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_pTexture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tBlendFunc) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_tBlendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOpacityModifyRGB) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_bOpacityModifyRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsBlendAdditive) as usize - ptr as usize },
        545usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_bIsBlendAdditive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ePositionType) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_ePositionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsAutoRemoveOnFinish) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_bIsAutoRemoveOnFinish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nEmitterMode) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystem),
            "::",
            stringify!(m_nEmitterMode)
        )
    );
}
extern "C" {
    #[doc = " creates an initializes a CCParticleSystem from a plist file.\nThis plist files can be created manually or with Particle Designer:\nhttp://particledesigner.71squared.com/\n@since v2.0"]
    #[link_name = "\u{1}?create@CCParticleSystem@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCParticleSystem_create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystem;
}
extern "C" {
    #[doc = "! create a system with a fixed number of particles"]
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSystem@cocos2d@@SAPAV12@I_N@Z"]
    pub fn cocos2d_CCParticleSystem_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
        a2: bool,
    ) -> *mut cocos2d_CCParticleSystem;
}
extern "thiscall" {
    #[doc = " initializes a CCParticleSystem from a plist file.\nThis plist files can be created manually or with Particle Designer:\nhttp://particledesigner.71squared.com/\n@since v0.99.3"]
    #[link_name = "\u{1}?initWithFile@CCParticleSystem@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCParticleSystem_initWithFile(
        this: *mut cocos2d_CCParticleSystem,
        plistFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a CCQuadParticleSystem from a CCDictionary.\n@since v0.99.3"]
    #[link_name = "\u{1}?initWithDictionary@CCParticleSystem@cocos2d@@QAE_NPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCParticleSystem_initWithDictionary(
        this: *mut cocos2d_CCParticleSystem,
        dictionary: *mut cocos2d_CCDictionary,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a particle system from a NSDictionary and the path from where to load the png\n@since v2.1"]
    #[link_name = "\u{1}?initWithDictionary@CCParticleSystem@cocos2d@@QAE_NPAVCCDictionary@2@PBD@Z"]
    pub fn cocos2d_CCParticleSystem_initWithDictionary1(
        this: *mut cocos2d_CCParticleSystem,
        dictionary: *mut cocos2d_CCDictionary,
        dirname: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "! Add a particle to the emitter"]
    #[link_name = "\u{1}?addParticle@CCParticleSystem@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_addParticle(this: *mut cocos2d_CCParticleSystem) -> bool;
}
extern "thiscall" {
    #[doc = "! Initializes a particle"]
    #[link_name = "\u{1}?initParticle@CCParticleSystem@cocos2d@@QAEXPAUsCCParticle@2@@Z"]
    pub fn cocos2d_CCParticleSystem_initParticle(
        this: *mut cocos2d_CCParticleSystem,
        particle: *mut cocos2d_tCCParticle,
    );
}
extern "thiscall" {
    #[doc = "! stop emitting particles. Running particles will continue to run until they die"]
    #[link_name = "\u{1}?stopSystem@CCParticleSystem@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystem_stopSystem(this: *mut cocos2d_CCParticleSystem);
}
extern "thiscall" {
    #[doc = "! Kill all living particles."]
    #[link_name = "\u{1}?resetSystem@CCParticleSystem@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystem_resetSystem(this: *mut cocos2d_CCParticleSystem);
}
extern "thiscall" {
    #[doc = "! whether or not the system is full"]
    #[link_name = "\u{1}?isFull@CCParticleSystem@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_isFull(this: *mut cocos2d_CCParticleSystem) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?loadDefaults@CCParticleSystem@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystem_loadDefaults(this: *mut cocos2d_CCParticleSystem);
}
extern "thiscall" {
    #[link_name = "\u{1}?loadScaledDefaults@CCParticleSystem@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_loadScaledDefaults(
        this: *mut cocos2d_CCParticleSystem,
        arg1: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?resumeSystem@CCParticleSystem@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystem_resumeSystem(this: *mut cocos2d_CCParticleSystem);
}
extern "thiscall" {
    #[link_name = "\u{1}?saveDefaults@CCParticleSystem@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystem_saveDefaults(this: *mut cocos2d_CCParticleSystem);
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleSystem@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCParticleSystem_CCParticleSystem(this: *mut cocos2d_CCParticleSystem);
}
impl cocos2d_CCParticleSystem {
    #[inline]
    pub unsafe fn create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystem {
        cocos2d_CCParticleSystem_create(plistFile)
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
        a2: bool,
    ) -> *mut cocos2d_CCParticleSystem {
        cocos2d_CCParticleSystem_createWithTotalParticles(numberOfParticles, a2)
    }
    #[inline]
    pub unsafe fn initWithFile(&mut self, plistFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCParticleSystem_initWithFile(self, plistFile)
    }
    #[inline]
    pub unsafe fn initWithDictionary(&mut self, dictionary: *mut cocos2d_CCDictionary) -> bool {
        cocos2d_CCParticleSystem_initWithDictionary(self, dictionary)
    }
    #[inline]
    pub unsafe fn initWithDictionary1(
        &mut self,
        dictionary: *mut cocos2d_CCDictionary,
        dirname: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCParticleSystem_initWithDictionary1(self, dictionary, dirname)
    }
    #[inline]
    pub unsafe fn addParticle(&mut self) -> bool {
        cocos2d_CCParticleSystem_addParticle(self)
    }
    #[inline]
    pub unsafe fn initParticle(&mut self, particle: *mut cocos2d_tCCParticle) {
        cocos2d_CCParticleSystem_initParticle(self, particle)
    }
    #[inline]
    pub unsafe fn stopSystem(&mut self) {
        cocos2d_CCParticleSystem_stopSystem(self)
    }
    #[inline]
    pub unsafe fn resetSystem(&mut self) {
        cocos2d_CCParticleSystem_resetSystem(self)
    }
    #[inline]
    pub unsafe fn isFull(&mut self) -> bool {
        cocos2d_CCParticleSystem_isFull(self)
    }
    #[inline]
    pub unsafe fn loadDefaults(&mut self) {
        cocos2d_CCParticleSystem_loadDefaults(self)
    }
    #[inline]
    pub unsafe fn loadScaledDefaults(&mut self, arg1: f32) {
        cocos2d_CCParticleSystem_loadScaledDefaults(self, arg1)
    }
    #[inline]
    pub unsafe fn resumeSystem(&mut self) {
        cocos2d_CCParticleSystem_resumeSystem(self)
    }
    #[inline]
    pub unsafe fn saveDefaults(&mut self) {
        cocos2d_CCParticleSystem_saveDefaults(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleSystem_CCParticleSystem(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " weak reference to the CCSpriteBatchNode that renders the CCSprite"]
    #[link_name = "\u{1}?getBatchNode@CCParticleSystem@cocos2d@@UAEPAVCCParticleBatchNode@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getBatchNode(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCParticleBatchNode;
}
extern "thiscall" {
    #[doc = " weak reference to the CCSpriteBatchNode that renders the CCSprite"]
    #[link_name = "\u{1}?setBatchNode@CCParticleSystem@cocos2d@@UAEXPAVCCParticleBatchNode@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "thiscall" {
    #[doc = " Quantity of particles that are being simulated at the moment"]
    #[link_name = "\u{1}?getParticleCount@CCParticleSystem@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCParticleSystem_getParticleCount(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " How many seconds the emitter will run. -1 means 'forever'"]
    #[link_name = "\u{1}?getDuration@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getDuration(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " How many seconds the emitter will run. -1 means 'forever'"]
    #[link_name = "\u{1}?setDuration@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setDuration(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " sourcePosition of the emitter"]
    #[link_name = "\u{1}?getSourcePosition@CCParticleSystem@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getSourcePosition(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " sourcePosition of the emitter"]
    #[link_name = "\u{1}?setSourcePosition@CCParticleSystem@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setSourcePosition(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " Position variance of the emitter"]
    #[link_name = "\u{1}?getPosVar@CCParticleSystem@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getPosVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Position variance of the emitter"]
    #[link_name = "\u{1}?setPosVar@CCParticleSystem@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setPosVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " life, and life variation of each particle"]
    #[link_name = "\u{1}?getLife@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getLife(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " life, and life variation of each particle"]
    #[link_name = "\u{1}?setLife@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setLife(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " life variance of each particle"]
    #[link_name = "\u{1}?getLifeVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getLifeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " life variance of each particle"]
    #[link_name = "\u{1}?setLifeVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setLifeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " angle and angle variation of each particle"]
    #[link_name = "\u{1}?getAngle@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getAngle(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " angle and angle variation of each particle"]
    #[link_name = "\u{1}?setAngle@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setAngle(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " angle variance of each particle"]
    #[link_name = "\u{1}?getAngleVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getAngleVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " angle variance of each particle"]
    #[link_name = "\u{1}?setAngleVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setAngleVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getGravity@CCParticleSystem@cocos2d@@UAEABVCCPoint@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getGravity(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCPoint;
}
extern "thiscall" {
    #[link_name = "\u{1}?setGravity@CCParticleSystem@cocos2d@@UAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setGravity(
        this: *mut ::std::os::raw::c_void,
        g: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getSpeed@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getSpeed(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSpeed@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setSpeed(this: *mut ::std::os::raw::c_void, speed: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getSpeedVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getSpeedVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSpeedVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setSpeedVar(this: *mut ::std::os::raw::c_void, speed: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getTangentialAccel@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getTangentialAccel(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTangentialAccel@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setTangentialAccel(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getTangentialAccelVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getTangentialAccelVar(this: *mut ::std::os::raw::c_void)
        -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTangentialAccelVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setTangentialAccelVar(
        this: *mut ::std::os::raw::c_void,
        t: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getRadialAccel@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getRadialAccel(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setRadialAccel@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRadialAccel(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getRadialAccelVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getRadialAccelVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setRadialAccelVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRadialAccelVar(this: *mut ::std::os::raw::c_void, t: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getRotationIsDir@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_getRotationIsDir(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotationIsDir@CCParticleSystem@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setRotationIsDir(this: *mut ::std::os::raw::c_void, t: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?getStartRadius@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartRadius(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStartRadius@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartRadius(
        this: *mut ::std::os::raw::c_void,
        startRadius: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getStartRadiusVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartRadiusVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStartRadiusVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartRadiusVar(
        this: *mut ::std::os::raw::c_void,
        startRadiusVar: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getEndRadius@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndRadius(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEndRadius@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndRadius(this: *mut ::std::os::raw::c_void, endRadius: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getEndRadiusVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndRadiusVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEndRadiusVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndRadiusVar(
        this: *mut ::std::os::raw::c_void,
        endRadiusVar: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getRotatePerSecond@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getRotatePerSecond(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotatePerSecond@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotatePerSecond(
        this: *mut ::std::os::raw::c_void,
        degrees: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getRotatePerSecondVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getRotatePerSecondVar(this: *mut ::std::os::raw::c_void)
        -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotatePerSecondVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotatePerSecondVar(
        this: *mut ::std::os::raw::c_void,
        degrees: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setScale@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScale(this: *mut ::std::os::raw::c_void, s: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setRotation@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setRotation(
        this: *mut ::std::os::raw::c_void,
        newRotation: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setScaleX@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScaleX(this: *mut ::std::os::raw::c_void, newScaleX: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?setScaleY@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setScaleY(this: *mut ::std::os::raw::c_void, newScaleY: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?isActive@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_isActive(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?isBlendAdditive@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_isBlendAdditive(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setBlendAdditive@CCParticleSystem@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setBlendAdditive(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "thiscall" {
    #[doc = " start size in pixels of each particle"]
    #[link_name = "\u{1}?getStartSize@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSize(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " start size in pixels of each particle"]
    #[link_name = "\u{1}?setStartSize@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSize(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " size variance in pixels of each particle"]
    #[link_name = "\u{1}?getStartSizeVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSizeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " size variance in pixels of each particle"]
    #[link_name = "\u{1}?setStartSizeVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSizeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " end size in pixels of each particle"]
    #[link_name = "\u{1}?getEndSize@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSize(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end size in pixels of each particle"]
    #[link_name = "\u{1}?setEndSize@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSize(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " end size variance in pixels of each particle"]
    #[link_name = "\u{1}?getEndSizeVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSizeVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end size variance in pixels of each particle"]
    #[link_name = "\u{1}?setEndSizeVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSizeVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " start color of each particle"]
    #[link_name = "\u{1}?getStartColor@CCParticleSystem@cocos2d@@UAEABU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getStartColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "thiscall" {
    #[doc = " start color of each particle"]
    #[link_name = "\u{1}?setStartColor@CCParticleSystem@cocos2d@@UAEXABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setStartColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " start color variance of each particle"]
    #[link_name = "\u{1}?getStartColorVar@CCParticleSystem@cocos2d@@UAEABU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getStartColorVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "thiscall" {
    #[doc = " start color variance of each particle"]
    #[link_name = "\u{1}?setStartColorVar@CCParticleSystem@cocos2d@@UAEXABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setStartColorVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " end color and end color variation of each particle"]
    #[link_name = "\u{1}?getEndColor@CCParticleSystem@cocos2d@@UAEABU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getEndColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "thiscall" {
    #[doc = " end color and end color variation of each particle"]
    #[link_name = "\u{1}?setEndColor@CCParticleSystem@cocos2d@@UAEXABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setEndColor(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?getEndColorVar@CCParticleSystem@cocos2d@@UAEABU_ccColor4F@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getEndColorVar(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor4F;
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?setEndColorVar@CCParticleSystem@cocos2d@@UAEXABU_ccColor4F@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setEndColorVar(
        this: *mut ::std::os::raw::c_void,
        var: *const cocos2d_ccColor4F,
    );
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?getStartSpin@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSpin(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?setStartSpin@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSpin(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?getStartSpinVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getStartSpinVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?setStartSpinVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setStartSpinVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?getEndSpin@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSpin(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?setEndSpin@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSpin(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?getEndSpinVar@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEndSpinVar(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " end color variance of each particle"]
    #[link_name = "\u{1}?setEndSpinVar@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEndSpinVar(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " emission rate of the particles"]
    #[link_name = "\u{1}?getEmissionRate@CCParticleSystem@cocos2d@@UAEMXZ"]
    pub fn cocos2d_CCParticleSystem_getEmissionRate(this: *mut ::std::os::raw::c_void) -> f32;
}
extern "thiscall" {
    #[doc = " emission rate of the particles"]
    #[link_name = "\u{1}?setEmissionRate@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_setEmissionRate(this: *mut ::std::os::raw::c_void, var: f32);
}
extern "thiscall" {
    #[doc = " maximum particles of the system"]
    #[link_name = "\u{1}?getTotalParticles@CCParticleSystem@cocos2d@@UAEIXZ"]
    pub fn cocos2d_CCParticleSystem_getTotalParticles(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " maximum particles of the system"]
    #[link_name = "\u{1}?setTotalParticles@CCParticleSystem@cocos2d@@UAEXI@Z"]
    pub fn cocos2d_CCParticleSystem_setTotalParticles(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " conforms to CocosNodeTexture protocol"]
    #[link_name = "\u{1}?getTexture@CCParticleSystem@cocos2d@@UAEPAVCCTexture2D@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getTexture(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " conforms to CocosNodeTexture protocol"]
    #[link_name = "\u{1}?setTexture@CCParticleSystem@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setTexture(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " conforms to CocosNodeTexture protocol"]
    #[link_name = "\u{1}?getBlendFunc@CCParticleSystem@cocos2d@@UAE?AU_ccBlendFunc@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getBlendFunc(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccBlendFunc;
}
extern "thiscall" {
    #[doc = " conforms to CocosNodeTexture protocol"]
    #[link_name = "\u{1}?setBlendFunc@CCParticleSystem@cocos2d@@UAEXU_ccBlendFunc@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setBlendFunc(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_ccBlendFunc,
    );
}
extern "thiscall" {
    #[doc = " does the alpha value modify color"]
    #[link_name = "\u{1}?getOpacityModifyRGB@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_getOpacityModifyRGB(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " does the alpha value modify color"]
    #[link_name = "\u{1}?setOpacityModifyRGB@CCParticleSystem@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setOpacityModifyRGB(
        this: *mut ::std::os::raw::c_void,
        var: bool,
    );
}
extern "thiscall" {
    #[doc = " particles movement type: Free or Grouped\n@since v0.8"]
    #[link_name = "\u{1}?getPositionType@CCParticleSystem@cocos2d@@UAE?AW4tCCPositionType@2@XZ"]
    pub fn cocos2d_CCParticleSystem_getPositionType(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_tCCPositionType;
}
extern "thiscall" {
    #[doc = " particles movement type: Free or Grouped\n@since v0.8"]
    #[link_name = "\u{1}?setPositionType@CCParticleSystem@cocos2d@@UAEXW4tCCPositionType@2@@Z"]
    pub fn cocos2d_CCParticleSystem_setPositionType(
        this: *mut ::std::os::raw::c_void,
        var: cocos2d_tCCPositionType,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isAutoRemoveOnFinish@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_isAutoRemoveOnFinish(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setAutoRemoveOnFinish@CCParticleSystem@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParticleSystem_setAutoRemoveOnFinish(
        this: *mut ::std::os::raw::c_void,
        var: bool,
    );
}
extern "thiscall" {
    #[doc = " Switch between different kind of emitter modes:\n- kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration\n- kCCParticleModeRadius: uses radius movement + rotation"]
    #[link_name = "\u{1}?getEmitterMode@CCParticleSystem@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCParticleSystem_getEmitterMode(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " Switch between different kind of emitter modes:\n- kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration\n- kCCParticleModeRadius: uses radius movement + rotation"]
    #[link_name = "\u{1}?setEmitterMode@CCParticleSystem@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCParticleSystem_setEmitterMode(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCParticleSystem@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCParticleSystem_CCParticleSystem_destructor(
        this: *mut cocos2d_CCParticleSystem,
    );
}
extern "thiscall" {
    #[doc = " initializes a CCParticleSystem"]
    #[link_name = "\u{1}?init@CCParticleSystem@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCParticleSystem_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "! Initializes a system with a fixed number of particles"]
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSystem@cocos2d@@UAE_NI_N@Z"]
    pub fn cocos2d_CCParticleSystem_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
        a2: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "! should be overridden by subclasses"]
    #[link_name = "\u{1}?updateQuadWithParticle@CCParticleSystem@cocos2d@@UAEXPAUsCCParticle@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystem_updateQuadWithParticle(
        this: *mut ::std::os::raw::c_void,
        particle: *mut cocos2d_tCCParticle,
        newPosition: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = "! should be overridden by subclasses"]
    #[link_name = "\u{1}?postStep@CCParticleSystem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleSystem_postStep(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCParticleSystem@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCParticleSystem_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateWithNoTime@CCParticleSystem@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleSystem_updateWithNoTime(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?updateBlendFunc@CCParticleSystem@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCParticleSystem_updateBlendFunc(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCParticleSystemQuad is a subclass of CCParticleSystem\n\nIt includes all the features of ParticleSystem.\n\nSpecial features and Limitations:\n- Particle size can be any float number.\n- The system can be scaled\n- The particles can be rotated\n- It supports subrects\n- It supports batched rendering since 1.1\n@since v0.8"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSystemQuad {
    pub _base: cocos2d_CCParticleSystem,
    pub m_pQuads: *mut cocos2d_ccV3F_C4B_T2F_Quad,
    pub m_pIndices: *mut GLushort,
    pub m_pBuffersVBO: [GLuint; 2usize],
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSystemQuad() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParticleSystemQuad> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSystemQuad>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSystemQuad))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSystemQuad>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSystemQuad))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pQuads) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pQuads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIndices) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pIndices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pBuffersVBO) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParticleSystemQuad),
            "::",
            stringify!(m_pBuffersVBO)
        )
    );
}
extern "C" {
    #[doc = " creates an initializes a CCParticleSystemQuad from a plist file.\nThis plist files can be created manually or with Particle Designer:"]
    #[link_name = "\u{1}?create@CCParticleSystemQuad@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCParticleSystemQuad_create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystemQuad;
}
extern "thiscall" {
    #[doc = " initializes the indices for the vertices"]
    #[link_name = "\u{1}?initIndices@CCParticleSystemQuad@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_initIndices(this: *mut cocos2d_CCParticleSystemQuad);
}
extern "thiscall" {
    #[doc = " initializes the texture with a rectangle measured Points"]
    #[link_name = "\u{1}?initTexCoordsWithRect@CCParticleSystemQuad@cocos2d@@QAEXABVCCRect@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_initTexCoordsWithRect(
        this: *mut cocos2d_CCParticleSystemQuad,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " Sets a new CCSpriteFrame as particle.\nWARNING: this method is experimental. Use setTexture:withRect instead.\n@since v0.99.4"]
    #[link_name = "\u{1}?setDisplayFrame@CCParticleSystemQuad@cocos2d@@QAEXPAVCCSpriteFrame@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setDisplayFrame(
        this: *mut cocos2d_CCParticleSystemQuad,
        spriteFrame: *mut cocos2d_CCSpriteFrame,
    );
}
extern "thiscall" {
    #[doc = " Sets a new texture with a rect. The rect is in Points.\n@since v0.99.4"]
    #[link_name = "\u{1}?setTextureWithRect@CCParticleSystemQuad@cocos2d@@QAEXPAVCCTexture2D@2@ABVCCRect@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTextureWithRect(
        this: *mut cocos2d_CCParticleSystemQuad,
        texture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[doc = " listen the event that coming to foreground on Android\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?listenBackToForeground@CCParticleSystemQuad@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_listenBackToForeground(
        this: *mut cocos2d_CCParticleSystemQuad,
        obj: *mut cocos2d_CCObject,
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSystemQuad@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleSystemQuad_create1() -> *mut cocos2d_CCParticleSystemQuad;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSystemQuad@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleSystemQuad_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystemQuad;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCParticleSystemQuad@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCParticleSystemQuad_CCParticleSystemQuad(
        this: *mut cocos2d_CCParticleSystemQuad,
    );
}
impl cocos2d_CCParticleSystemQuad {
    #[inline]
    pub unsafe fn create(
        plistFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_create(plistFile)
    }
    #[inline]
    pub unsafe fn initIndices(&mut self) {
        cocos2d_CCParticleSystemQuad_initIndices(self)
    }
    #[inline]
    pub unsafe fn initTexCoordsWithRect(&mut self, rect: *const cocos2d_CCRect) {
        cocos2d_CCParticleSystemQuad_initTexCoordsWithRect(self, rect)
    }
    #[inline]
    pub unsafe fn setDisplayFrame(&mut self, spriteFrame: *mut cocos2d_CCSpriteFrame) {
        cocos2d_CCParticleSystemQuad_setDisplayFrame(self, spriteFrame)
    }
    #[inline]
    pub unsafe fn setTextureWithRect(
        &mut self,
        texture: *mut cocos2d_CCTexture2D,
        rect: *const cocos2d_CCRect,
    ) {
        cocos2d_CCParticleSystemQuad_setTextureWithRect(self, texture, rect)
    }
    #[inline]
    pub unsafe fn listenBackToForeground(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCParticleSystemQuad_listenBackToForeground(self, obj)
    }
    #[inline]
    pub unsafe fn create1() -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_create1()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSystemQuad {
        cocos2d_CCParticleSystemQuad_createWithTotalParticles(numberOfParticles)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParticleSystemQuad_CCParticleSystemQuad(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCParticleSystemQuad@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCParticleSystemQuad_CCParticleSystemQuad_destructor(
        this: *mut cocos2d_CCParticleSystemQuad,
    );
}
extern "thiscall" {
    #[doc = " super methods\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSystemQuad@cocos2d@@UAE_NI_N@Z"]
    pub fn cocos2d_CCParticleSystemQuad_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
        a2: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setTexture@CCParticleSystemQuad@cocos2d@@UAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTexture(
        this: *mut ::std::os::raw::c_void,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?updateQuadWithParticle@CCParticleSystemQuad@cocos2d@@UAEXPAUsCCParticle@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_updateQuadWithParticle(
        this: *mut ::std::os::raw::c_void,
        particle: *mut cocos2d_tCCParticle,
        newPosition: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?postStep@CCParticleSystemQuad@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_postStep(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}?draw@CCParticleSystemQuad@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParticleSystemQuad_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setBatchNode@CCParticleSystemQuad@cocos2d@@UAEXPAVCCParticleBatchNode@2@@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setBatchNode(
        this: *mut ::std::os::raw::c_void,
        batchNode: *mut cocos2d_CCParticleBatchNode,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?setTotalParticles@CCParticleSystemQuad@cocos2d@@UAEXI@Z"]
    pub fn cocos2d_CCParticleSystemQuad_setTotalParticles(
        this: *mut ::std::os::raw::c_void,
        tp: ::std::os::raw::c_uint,
    );
}
#[doc = "! @brief A fire particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFire {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFire() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFire>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFire))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFire>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFire))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFire@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleFire_create() -> *mut cocos2d_CCParticleFire;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFire@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleFire_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFire;
}
impl cocos2d_CCParticleFire {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFire {
        cocos2d_CCParticleFire_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFire {
        cocos2d_CCParticleFire_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFire@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleFire_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A fireworks particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFireworks {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFireworks() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFireworks>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFireworks))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFireworks>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFireworks))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFireworks@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleFireworks_create() -> *mut cocos2d_CCParticleFireworks;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFireworks@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleFireworks_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFireworks;
}
impl cocos2d_CCParticleFireworks {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFireworks {
        cocos2d_CCParticleFireworks_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFireworks {
        cocos2d_CCParticleFireworks_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFireworks@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleFireworks_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A sun particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSun {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSun() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSun>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSun))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSun>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSun))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSun@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleSun_create() -> *mut cocos2d_CCParticleSun;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSun@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleSun_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSun;
}
impl cocos2d_CCParticleSun {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSun {
        cocos2d_CCParticleSun_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSun {
        cocos2d_CCParticleSun_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSun@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleSun_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A galaxy particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleGalaxy {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleGalaxy() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleGalaxy>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleGalaxy))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleGalaxy>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleGalaxy))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleGalaxy@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleGalaxy_create() -> *mut cocos2d_CCParticleGalaxy;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleGalaxy@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleGalaxy_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleGalaxy;
}
impl cocos2d_CCParticleGalaxy {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleGalaxy {
        cocos2d_CCParticleGalaxy_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleGalaxy {
        cocos2d_CCParticleGalaxy_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleGalaxy@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleGalaxy_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A flower particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleFlower {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleFlower() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleFlower>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleFlower))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleFlower>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleFlower))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleFlower@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleFlower_create() -> *mut cocos2d_CCParticleFlower;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleFlower@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleFlower_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFlower;
}
impl cocos2d_CCParticleFlower {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleFlower {
        cocos2d_CCParticleFlower_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleFlower {
        cocos2d_CCParticleFlower_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleFlower@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleFlower_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A meteor particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleMeteor {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleMeteor() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleMeteor>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleMeteor))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleMeteor>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleMeteor))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleMeteor@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleMeteor_create() -> *mut cocos2d_CCParticleMeteor;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleMeteor@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleMeteor_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleMeteor;
}
impl cocos2d_CCParticleMeteor {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleMeteor {
        cocos2d_CCParticleMeteor_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleMeteor {
        cocos2d_CCParticleMeteor_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleMeteor@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleMeteor_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An spiral particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSpiral {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSpiral() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSpiral>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSpiral))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSpiral>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSpiral))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSpiral@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleSpiral_create() -> *mut cocos2d_CCParticleSpiral;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSpiral@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleSpiral_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSpiral;
}
impl cocos2d_CCParticleSpiral {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSpiral {
        cocos2d_CCParticleSpiral_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSpiral {
        cocos2d_CCParticleSpiral_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSpiral@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleSpiral_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An explosion particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleExplosion {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleExplosion() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleExplosion>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleExplosion))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleExplosion>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleExplosion))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleExplosion@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleExplosion_create() -> *mut cocos2d_CCParticleExplosion;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleExplosion@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleExplosion_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleExplosion;
}
impl cocos2d_CCParticleExplosion {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleExplosion {
        cocos2d_CCParticleExplosion_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleExplosion {
        cocos2d_CCParticleExplosion_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleExplosion@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleExplosion_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An smoke particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSmoke {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSmoke() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSmoke>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSmoke))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSmoke>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSmoke))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSmoke@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleSmoke_create() -> *mut cocos2d_CCParticleSmoke;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSmoke@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleSmoke_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSmoke;
}
impl cocos2d_CCParticleSmoke {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSmoke {
        cocos2d_CCParticleSmoke_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSmoke {
        cocos2d_CCParticleSmoke_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSmoke@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleSmoke_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief An snow particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleSnow {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleSnow() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleSnow>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleSnow))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleSnow>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleSnow))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleSnow@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleSnow_create() -> *mut cocos2d_CCParticleSnow;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleSnow@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleSnow_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSnow;
}
impl cocos2d_CCParticleSnow {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleSnow {
        cocos2d_CCParticleSnow_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleSnow {
        cocos2d_CCParticleSnow_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleSnow@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleSnow_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "! @brief A rain particle system"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParticleRain {
    pub _base: cocos2d_CCParticleSystemQuad,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParticleRain() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParticleRain>(),
        576usize,
        concat!("Size of: ", stringify!(cocos2d_CCParticleRain))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParticleRain>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParticleRain))
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParticleRain@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParticleRain_create() -> *mut cocos2d_CCParticleRain;
}
extern "C" {
    #[link_name = "\u{1}?createWithTotalParticles@CCParticleRain@cocos2d@@SAPAV12@I@Z"]
    pub fn cocos2d_CCParticleRain_createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleRain;
}
impl cocos2d_CCParticleRain {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParticleRain {
        cocos2d_CCParticleRain_create()
    }
    #[inline]
    pub unsafe fn createWithTotalParticles(
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> *mut cocos2d_CCParticleRain {
        cocos2d_CCParticleRain_createWithTotalParticles(numberOfParticles)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithTotalParticles@CCParticleRain@cocos2d@@UAE_NI@Z"]
    pub fn cocos2d_CCParticleRain_initWithTotalParticles(
        this: *mut ::std::os::raw::c_void,
        numberOfParticles: ::std::os::raw::c_uint,
    ) -> bool;
}
#[doc = "@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCDevice {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCDevice() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCDevice>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCDevice>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCDevice))
    );
}
extern "C" {
    #[doc = "  Gets the DPI of device\n  @return The DPI of device."]
    #[link_name = "\u{1}?getDPI@CCDevice@cocos2d@@SAHXZ"]
    pub fn cocos2d_CCDevice_getDPI() -> ::std::os::raw::c_int;
}
impl cocos2d_CCDevice {
    #[inline]
    pub unsafe fn getDPI() -> ::std::os::raw::c_int {
        cocos2d_CCDevice_getDPI()
    }
}
#[doc = "! @brief  Helper class to handle file operations"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCFileUtils {
    pub _base: cocos2d_TypeInfo,
    #[doc = " Dictionary used to lookup filenames based on a key.\n  It is used internally by the following methods:\n\n  std::string fullPathForFilename(const char*);\n\n  @since v2.1"]
    pub m_pFilenameLookupDict: *mut cocos2d_CCDictionary,
    #[doc = "  The vector contains resolution folders.\n  The lower index of the element in this vector, the higher priority for this resolution directory."]
    pub m_searchResolutionsOrderArray: [u32; 3usize],
    #[doc = " The vector contains search paths.\n The lower index of the element in this vector, the higher priority for this search path."]
    pub m_searchPathArray: [u32; 3usize],
    #[doc = "  The default root path of resources.\n  If the default root path of resources needs to be changed, do it in the `init` method of CCFileUtils's subclass.\n  For instance:\n  On Android, the default root path of resources will be assigned with \"assets/\" in CCFileUtilsAndroid::init().\n  Similarly on Blackberry, we assign \"app/native/Resources/\" to this variable in CCFileUtilsBlackberry::init()."]
    pub m_strDefaultResRootPath: std_string,
    #[doc = "  The full path cache. When a file is found, it will be added into this cache.\n  This variable is used for improving the performance of file search."]
    pub m_fullPathCache: [u32; 2usize],
}
extern "C" {
    #[doc = "  The singleton pointer of CCFileUtils."]
    #[link_name = "\u{1}?s_sharedFileUtils@CCFileUtils@cocos2d@@1PAV12@A"]
    pub static mut cocos2d_CCFileUtils_s_sharedFileUtils: *mut cocos2d_CCFileUtils;
}
#[test]
fn bindgen_test_layout_cocos2d_CCFileUtils() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCFileUtils> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCFileUtils>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCFileUtils))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCFileUtils>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCFileUtils))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFilenameLookupDict) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_pFilenameLookupDict)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_searchResolutionsOrderArray) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_searchResolutionsOrderArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_searchPathArray) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_searchPathArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strDefaultResRootPath) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_strDefaultResRootPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fullPathCache) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCFileUtils),
            "::",
            stringify!(m_fullPathCache)
        )
    );
}
extern "C" {
    #[doc = "  Gets the instance of CCFileUtils.\n  @js getInstance"]
    #[link_name = "\u{1}?sharedFileUtils@CCFileUtils@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCFileUtils_sharedFileUtils() -> *mut cocos2d_CCFileUtils;
}
extern "C" {
    #[doc = "  Destroys the instance of CCFileUtils."]
    #[link_name = "\u{1}?purgeFileUtils@CCFileUtils@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCFileUtils_purgeFileUtils();
}
extern "thiscall" {
    #[doc = " Removes all paths.\n\n @since v2.2\n @lua NA"]
    #[link_name = "\u{1}?removeAllPaths@CCFileUtils@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCFileUtils_removeAllPaths(this: *mut cocos2d_CCFileUtils);
}
extern "thiscall" {
    #[doc = "  The default constructor."]
    #[link_name = "\u{1}??0CCFileUtils@cocos2d@@IAE@XZ"]
    pub fn cocos2d_CCFileUtils_CCFileUtils(this: *mut cocos2d_CCFileUtils);
}
impl cocos2d_CCFileUtils {
    #[inline]
    pub unsafe fn sharedFileUtils() -> *mut cocos2d_CCFileUtils {
        cocos2d_CCFileUtils_sharedFileUtils()
    }
    #[inline]
    pub unsafe fn purgeFileUtils() {
        cocos2d_CCFileUtils_purgeFileUtils()
    }
    #[inline]
    pub unsafe fn removeAllPaths(&mut self) {
        cocos2d_CCFileUtils_removeAllPaths(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCFileUtils_CCFileUtils(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  The destructor of CCFileUtils.\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCFileUtils@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCFileUtils_CCFileUtils_destructor(this: *mut cocos2d_CCFileUtils);
}
extern "thiscall" {
    #[doc = "  Purges the file searching cache.\n\n  @note It should be invoked after the resources were updated.\n        For instance, in the CocosPlayer sample, every time you run application from CocosBuilder,\n        All the resources will be downloaded to the writable folder, before new js app launchs,\n        this method should be invoked to clean the file search cache."]
    #[link_name = "\u{1}?purgeCachedEntries@CCFileUtils@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCFileUtils_purgeCachedEntries(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  Gets resource file data\n\n  @param[in]  pszFileName The resource file name which contains the path.\n  @param[in]  pszMode The read mode of the file.\n  @param[out] pSize If the file read operation succeeds, it will be the data size, otherwise 0.\n  @return Upon success, a pointer to the data is returned, otherwise NULL.\n  @warning Recall: you are responsible for calling delete[] on any Non-NULL pointer returned.\n  @js NA"]
    #[link_name = "\u{1}?getFileData@CCFileUtils@cocos2d@@UAEPAEPBD0PAK@Z"]
    pub fn cocos2d_CCFileUtils_getFileData(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
        pszMode: *const ::std::os::raw::c_char,
        pSize: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "thiscall" {
    #[doc = "  Gets resource file data from a zip file.\n\n  @param[in]  pszFileName The resource file name which contains the relative path of the zip file.\n  @param[out] pSize If the file read operation succeeds, it will be the data size, otherwise 0.\n  @return Upon success, a pointer to the data is returned, otherwise NULL.\n  @warning Recall: you are responsible for calling delete[] on any Non-NULL pointer returned.\n  @js NA"]
    #[link_name = "\u{1}?getFileDataFromZip@CCFileUtils@cocos2d@@UAEPAEPBD0PAK@Z"]
    pub fn cocos2d_CCFileUtils_getFileDataFromZip(
        this: *mut ::std::os::raw::c_void,
        pszZipFilePath: *const ::std::os::raw::c_char,
        pszFileName: *const ::std::os::raw::c_char,
        pSize: *mut ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "thiscall" {
    #[link_name = "\u{1}?fullPathForFilename@CCFileUtils@cocos2d@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD_N@Z"]
    pub fn cocos2d_CCFileUtils_fullPathForFilename(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
        arg1: bool,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?removeFullPath@CCFileUtils@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCFileUtils_removeFullPath(
        this: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Loads the filenameLookup dictionary from the contents of a filename.\n\n @note The plist file name should follow the format below:\n\n @code\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n <plist version=\"1.0\">\n <dict>\n     <key>filenames</key>\n     <dict>\n         <key>sounds/click.wav</key>\n         <string>sounds/click.caf</string>\n         <key>sounds/endgame.wav</key>\n         <string>sounds/endgame.caf</string>\n         <key>sounds/gem-0.wav</key>\n         <string>sounds/gem-0.caf</string>\n     </dict>\n     <key>metadata</key>\n     <dict>\n         <key>version</key>\n         <integer>1</integer>\n     </dict>\n </dict>\n </plist>\n @endcode\n @param filename The plist file name.\n\n @since v2.1\n @loadFilenameLookup"]
    #[link_name = "\u{1}?loadFilenameLookupDictionaryFromFile@CCFileUtils@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCFileUtils_loadFilenameLookupDictionaryFromFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = "  Sets the filenameLookup dictionary.\n\n  @param pFilenameLookupDict The dictionary for replacing filename.\n  @since v2.1\n  @lua NA"]
    #[link_name = "\u{1}?setFilenameLookupDictionary@CCFileUtils@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCFileUtils_setFilenameLookupDictionary(
        this: *mut ::std::os::raw::c_void,
        pFilenameLookupDict: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = "  Gets full path from a file name and the path of the reletive file.\n  @param pszFilename The file name.\n  @param pszRelativeFile The path of the relative file.\n  @return The full path.\n          e.g. pszFilename: hello.png, pszRelativeFile: /User/path1/path2/hello.plist\n               Return: /User/path1/path2/hello.pvr (If there a a key(hello.png)-value(hello.pvr) in FilenameLookup dictionary. )\n"]
    #[link_name = "\u{1}?fullPathFromRelativeFile@CCFileUtils@cocos2d@@UAEPBDPBD0@Z"]
    pub fn cocos2d_CCFileUtils_fullPathFromRelativeFile(
        this: *mut ::std::os::raw::c_void,
        pszFilename: *const ::std::os::raw::c_char,
        pszRelativeFile: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = "  Sets the array that contains the search order of the resources.\n\n  @param searchResolutionsOrder The source array that contains the search order of the resources.\n  @see getSearchResolutionsOrder(void), fullPathForFilename(const char*).\n  @since v2.1\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?setSearchResolutionsOrder@CCFileUtils@cocos2d@@UAEXABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_setSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
        searchResolutionsOrder: *const [u32; 3usize],
    );
}
extern "thiscall" {
    #[doc = " Append search order of the resources.\n\n @see setSearchResolutionsOrder(), fullPathForFilename().\n @since v2.1"]
    #[link_name = "\u{1}?addSearchResolutionsOrder@CCFileUtils@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCFileUtils_addSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
        order: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = "  Gets the array that contains the search order of the resources.\n\n  @see setSearchResolutionsOrder(const std::vector<std::string>&), fullPathForFilename(const char*).\n  @since v2.1\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?getSearchResolutionsOrder@CCFileUtils@cocos2d@@UAEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn cocos2d_CCFileUtils_getSearchResolutionsOrder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const [u32; 3usize];
}
extern "thiscall" {
    #[doc = "  Sets the array of search paths.\n\n  You can use this array to modify the search path of the resources.\n  If you want to use \"themes\" or search resources in the \"cache\", you can do it easily by adding new entries in this array.\n\n  @note This method could access relative path and absolute path.\n        If the relative path was passed to the vector, CCFileUtils will add the default resource directory before the relative path.\n        For instance:\n        \tOn Android, the default resource root path is \"assets/\".\n        \tIf \"/mnt/sdcard/\" and \"resources-large\" were set to the search paths vector,\n        \t\"resources-large\" will be converted to \"assets/resources-large\" since it was a relative path.\n\n  @param searchPaths The array contains search paths.\n  @see fullPathForFilename(const char*)\n  @since v2.1\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?setSearchPaths@CCFileUtils@cocos2d@@UAEXABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_setSearchPaths(
        this: *mut ::std::os::raw::c_void,
        searchPaths: *const [u32; 3usize],
    );
}
extern "thiscall" {
    #[doc = " Adds a path to search paths.\n\n @since v2.2"]
    #[link_name = "\u{1}?addSearchPath@CCFileUtils@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCFileUtils_addSearchPath(
        this: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Removes a path from search paths.\n\n @since v2.2\n @lua NA"]
    #[link_name = "\u{1}?removeSearchPath@CCFileUtils@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCFileUtils_removeSearchPath(
        this: *mut ::std::os::raw::c_void,
        path: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = "  Gets the array of search paths.\n\n  @return The array of search paths.\n  @see fullPathForFilename(const char*).\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?getSearchPaths@CCFileUtils@cocos2d@@UAEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn cocos2d_CCFileUtils_getSearchPaths(
        this: *mut ::std::os::raw::c_void,
    ) -> *const [u32; 3usize];
}
extern "thiscall" {
    #[link_name = "\u{1}?getWritablePath2@CCFileUtils@cocos2d@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCFileUtils_getWritablePath2(this: *mut ::std::os::raw::c_void) -> std_string;
}
extern "thiscall" {
    #[doc = "  Checks whether the path is an absolute path.\n\n  @note On Android, if the parameter passed in is relative to \"assets/\", this method will treat it as an absolute path.\n        Also on Blackberry, path starts with \"app/native/Resources/\" is treated as an absolute path.\n\n  @param strPath The path that needs to be checked.\n  @return true if it's an absolute path, otherwise it will return false.\n  @lua NA"]
    #[link_name = "\u{1}?isAbsolutePath@CCFileUtils@cocos2d@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_isAbsolutePath(
        this: *mut ::std::os::raw::c_void,
        strPath: *const std_string,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  Sets/Gets whether to pop-up a message box when failed to load an image."]
    #[link_name = "\u{1}?setPopupNotify@CCFileUtils@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCFileUtils_setPopupNotify(this: *mut ::std::os::raw::c_void, bNotify: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?isPopupNotify@CCFileUtils@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCFileUtils_isPopupNotify(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "  Initializes the instance of CCFileUtils. It will set m_searchPathArray and m_searchResolutionsOrderArray to default values.\n\n  @note When you are porting Cocos2d-x to a new platform, you may need to take care of this method.\n        You could assign a default value to m_strDefaultResRootPath in the subclass of CCFileUtils(e.g. CCFileUtilsAndroid). Then invoke the CCFileUtils::init().\n  @return true if successed, otherwise it returns false.\n"]
    #[link_name = "\u{1}?init@CCFileUtils@cocos2d@@MAE_NXZ"]
    pub fn cocos2d_CCFileUtils_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "  Gets the new filename from the filename lookup dictionary.\n  @param pszFileName The original filename.\n  @return The new filename after searching in the filename lookup dictionary.\n          If the original filename wasn't in the dictionary, it will return the original filename."]
    #[link_name = "\u{1}?getNewFilename@CCFileUtils@cocos2d@@MAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z"]
    pub fn cocos2d_CCFileUtils_getNewFilename(
        this: *mut ::std::os::raw::c_void,
        pszFileName: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?shouldUseHD@CCFileUtils@cocos2d@@MAE_NXZ"]
    pub fn cocos2d_CCFileUtils_shouldUseHD(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?addSuffix@CCFileUtils@cocos2d@@MAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V34@0@Z"]
    pub fn cocos2d_CCFileUtils_addSuffix(
        this: *mut ::std::os::raw::c_void,
        arg1: std_string,
        arg2: std_string,
    ) -> std_string;
}
extern "thiscall" {
    #[doc = "  Gets full path for filename, resolution directory and search path.\n\n  @param filename The file name.\n  @param resolutionDirectory The resolution directory.\n  @param searchPath The search path.\n  @return The full path of the file. It will return an empty string if the full path of the file doesn't exist."]
    #[link_name = "\u{1}?getPathForFilename@CCFileUtils@cocos2d@@MAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@00@Z"]
    pub fn cocos2d_CCFileUtils_getPathForFilename(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
        resolutionDirectory: *const std_string,
        searchPath: *const std_string,
    ) -> std_string;
}
extern "thiscall" {
    #[doc = "  Gets full path for the directory and the filename.\n\n  @note Only iOS and Mac need to override this method since they are using\n        `[[NSBundle mainBundle] pathForResource: ofType: inDirectory:]` to make a full path.\n        Other platforms will use the default implementation of this method.\n  @param strDirectory The directory contains the file we are looking for.\n  @param strFilename  The name of the file.\n  @return The full path of the file, if the file can't be found, it will return an empty string."]
    #[link_name = "\u{1}?getFullPathForDirectoryAndFilename@CCFileUtils@cocos2d@@MAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@0@Z"]
    pub fn cocos2d_CCFileUtils_getFullPathForDirectoryAndFilename(
        this: *mut ::std::os::raw::c_void,
        strDirectory: *const std_string,
        strFilename: *const std_string,
    ) -> std_string;
}
extern "thiscall" {
    #[doc = "  Creates a dictionary by the contents of a file.\n  @note This method is used internally."]
    #[link_name = "\u{1}?createCCDictionaryWithContentsOfFile@CCFileUtils@cocos2d@@MAEPAVCCDictionary@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_createCCDictionaryWithContentsOfFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = "  Write a dictionary to a plist file.\n  @note This method is used internally."]
    #[link_name = "\u{1}?writeToFile@CCFileUtils@cocos2d@@MAE_NPAVCCDictionary@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_writeToFile(
        this: *mut ::std::os::raw::c_void,
        dict: *mut cocos2d_CCDictionary,
        fullPath: *const std_string,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  Creates an array by the contents of a file.\n  @note This method is used internally."]
    #[link_name = "\u{1}?createCCArrayWithContentsOfFile@CCFileUtils@cocos2d@@MAEPAVCCArray@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCFileUtils_createCCArrayWithContentsOfFile(
        this: *mut ::std::os::raw::c_void,
        filename: *const std_string,
    ) -> *mut cocos2d_CCArray;
}
#[doc = " @addtogroup platform\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCImage {
    pub _base: cocos2d_CCObject,
    pub m_nWidth: ::std::os::raw::c_ushort,
    pub m_nHeight: ::std::os::raw::c_ushort,
    pub m_nBitsPerComponent: ::std::os::raw::c_int,
    pub m_pData: *mut ::std::os::raw::c_uchar,
    pub m_bHasAlpha: bool,
    pub m_bPreMulti: bool,
}
pub const cocos2d_CCImage_EImageFormat_kFmtJpg: cocos2d_CCImage_EImageFormat = 0;
pub const cocos2d_CCImage_EImageFormat_kFmtPng: cocos2d_CCImage_EImageFormat = 1;
pub const cocos2d_CCImage_EImageFormat_kFmtTiff: cocos2d_CCImage_EImageFormat = 2;
pub const cocos2d_CCImage_EImageFormat_kFmtWebp: cocos2d_CCImage_EImageFormat = 3;
pub const cocos2d_CCImage_EImageFormat_kFmtRawData: cocos2d_CCImage_EImageFormat = 4;
pub const cocos2d_CCImage_EImageFormat_kFmtUnKnown: cocos2d_CCImage_EImageFormat = 5;
pub type cocos2d_CCImage_EImageFormat = ::std::os::raw::c_int;
#[doc = "< Horizontal center and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignCenter: cocos2d_CCImage_ETextAlign = 51;
#[doc = "< Horizontal center and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTop: cocos2d_CCImage_ETextAlign = 19;
#[doc = "< Horizontal right and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTopRight: cocos2d_CCImage_ETextAlign = 18;
#[doc = "< Horizontal right and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignRight: cocos2d_CCImage_ETextAlign = 50;
#[doc = "< Horizontal right and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottomRight: cocos2d_CCImage_ETextAlign = 34;
#[doc = "< Horizontal center and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottom: cocos2d_CCImage_ETextAlign = 35;
#[doc = "< Horizontal left and vertical bottom."]
pub const cocos2d_CCImage_ETextAlign_kAlignBottomLeft: cocos2d_CCImage_ETextAlign = 33;
#[doc = "< Horizontal left and vertical center."]
pub const cocos2d_CCImage_ETextAlign_kAlignLeft: cocos2d_CCImage_ETextAlign = 49;
#[doc = "< Horizontal left and vertical top."]
pub const cocos2d_CCImage_ETextAlign_kAlignTopLeft: cocos2d_CCImage_ETextAlign = 17;
pub type cocos2d_CCImage_ETextAlign = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_cocos2d_CCImage() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCImage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCImage>(),
        68usize,
        concat!("Size of: ", stringify!(cocos2d_CCImage))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCImage>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCImage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nWidth) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nHeight) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nBitsPerComponent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_nBitsPerComponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pData) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAlpha) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_bHasAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bPreMulti) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCImage),
            "::",
            stringify!(m_bPreMulti)
        )
    );
}
extern "thiscall" {
    #[doc = "@brief  Load the image from the specified path.\n@param strPath   the absolute file path.\n@param imageType the type of image, currently only supporting two types.\n@return  true if loaded correctly."]
    #[link_name = "\u{1}?initWithImageFile@CCImage@cocos2d@@QAE_NPBDW4EImageFormat@12@@Z"]
    pub fn cocos2d_CCImage_initWithImageFile(
        this: *mut cocos2d_CCImage,
        strPath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithImageFileThreadSafe@CCImage@cocos2d@@QAE_NPBDW4EImageFormat@12@@Z"]
    pub fn cocos2d_CCImage_initWithImageFileThreadSafe(
        this: *mut cocos2d_CCImage,
        fullpath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief  Load image from stream buffer.\n\n@warning kFmtRawData only supports RGBA8888.\n@param pBuffer  stream buffer which holds the image data.\n@param nLength  data length expressed in (number of) bytes.\n@param nWidth, nHeight, nBitsPerComponent are used for kFmtRawData.\n@return true if loaded correctly.\n@js NA"]
    #[link_name = "\u{1}?initWithImageData@CCImage@cocos2d@@QAE_NPAXHW4EImageFormat@12@HHH@Z"]
    pub fn cocos2d_CCImage_initWithImageData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
        eFmt: cocos2d_CCImage_EImageFormat,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief    Create image with specified string.\n@param  pText       the text the image will show (cannot be nil).\n@param  nWidth      the image width, if 0, the width will match the text's width.\n@param  nHeight     the image height, if 0, the height will match the text's height.\n@param  eAlignMask  the test Alignment\n@param  pFontName   the name of the font used to draw the text. If nil, use the default system font.\n@param  nSize       the font size, if 0, use the system default size.\n@js NA"]
    #[link_name = "\u{1}?initWithString@CCImage@cocos2d@@QAE_NPBDHHW4ETextAlign@12@0H@Z"]
    pub fn cocos2d_CCImage_initWithString(
        this: *mut cocos2d_CCImage,
        pText: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        eAlignMask: cocos2d_CCImage_ETextAlign,
        pFontName: *const ::std::os::raw::c_char,
        nSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief    Save CCImage data to the specified file, with specified format.\n@param    pszFilePath        the file's absolute path, including file suffix.\n@param    bIsToRGB        whether the image is saved as RGB format."]
    #[link_name = "\u{1}?saveToFile@CCImage@cocos2d@@QAE_NPBD_N@Z"]
    pub fn cocos2d_CCImage_saveToFile(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_initWithJpgData@CCImage@cocos2d@@IAE_NPAXH@Z"]
    pub fn cocos2d_CCImage__initWithJpgData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_initWithPngData@CCImage@cocos2d@@IAE_NPAXH@Z"]
    pub fn cocos2d_CCImage__initWithPngData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_initWithTiffData@CCImage@cocos2d@@IAE_NPAXH@Z"]
    pub fn cocos2d_CCImage__initWithTiffData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_initWithWebpData@CCImage@cocos2d@@IAE_NPAXH@Z"]
    pub fn cocos2d_CCImage__initWithWebpData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_initWithRawData@CCImage@cocos2d@@IAE_NPAXHHHH_N@Z"]
    pub fn cocos2d_CCImage__initWithRawData(
        this: *mut cocos2d_CCImage,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
        bPreMulti: bool,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_saveImageToPNG@CCImage@cocos2d@@IAE_NPBD_N@Z"]
    pub fn cocos2d_CCImage__saveImageToPNG(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?_saveImageToJPG@CCImage@cocos2d@@IAE_NPBD@Z"]
    pub fn cocos2d_CCImage__saveImageToJPG(
        this: *mut cocos2d_CCImage,
        pszFilePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@js ctor"]
    #[link_name = "\u{1}??0CCImage@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCImage_CCImage(this: *mut cocos2d_CCImage);
}
impl cocos2d_CCImage {
    #[inline]
    pub unsafe fn initWithImageFile(
        &mut self,
        strPath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool {
        cocos2d_CCImage_initWithImageFile(self, strPath, imageType)
    }
    #[inline]
    pub unsafe fn initWithImageFileThreadSafe(
        &mut self,
        fullpath: *const ::std::os::raw::c_char,
        imageType: cocos2d_CCImage_EImageFormat,
    ) -> bool {
        cocos2d_CCImage_initWithImageFileThreadSafe(self, fullpath, imageType)
    }
    #[inline]
    pub unsafe fn initWithImageData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
        eFmt: cocos2d_CCImage_EImageFormat,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage_initWithImageData(
            self,
            pData,
            nDataLen,
            eFmt,
            nWidth,
            nHeight,
            nBitsPerComponent,
        )
    }
    #[inline]
    pub unsafe fn initWithString(
        &mut self,
        pText: *const ::std::os::raw::c_char,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        eAlignMask: cocos2d_CCImage_ETextAlign,
        pFontName: *const ::std::os::raw::c_char,
        nSize: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage_initWithString(self, pText, nWidth, nHeight, eAlignMask, pFontName, nSize)
    }
    #[inline]
    pub unsafe fn saveToFile(
        &mut self,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool {
        cocos2d_CCImage_saveToFile(self, pszFilePath, bIsToRGB)
    }
    #[inline]
    pub unsafe fn _initWithJpgData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithJpgData(self, pData, nDatalen)
    }
    #[inline]
    pub unsafe fn _initWithPngData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithPngData(self, pData, nDatalen)
    }
    #[inline]
    pub unsafe fn _initWithTiffData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithTiffData(self, pData, nDataLen)
    }
    #[inline]
    pub unsafe fn _initWithWebpData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDataLen: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCImage__initWithWebpData(self, pData, nDataLen)
    }
    #[inline]
    pub unsafe fn _initWithRawData(
        &mut self,
        pData: *mut ::std::os::raw::c_void,
        nDatalen: ::std::os::raw::c_int,
        nWidth: ::std::os::raw::c_int,
        nHeight: ::std::os::raw::c_int,
        nBitsPerComponent: ::std::os::raw::c_int,
        bPreMulti: bool,
    ) -> bool {
        cocos2d_CCImage__initWithRawData(
            self,
            pData,
            nDatalen,
            nWidth,
            nHeight,
            nBitsPerComponent,
            bPreMulti,
        )
    }
    #[inline]
    pub unsafe fn _saveImageToPNG(
        &mut self,
        pszFilePath: *const ::std::os::raw::c_char,
        bIsToRGB: bool,
    ) -> bool {
        cocos2d_CCImage__saveImageToPNG(self, pszFilePath, bIsToRGB)
    }
    #[inline]
    pub unsafe fn _saveImageToJPG(&mut self, pszFilePath: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCImage__saveImageToJPG(self, pszFilePath)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCImage_CCImage(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCImage@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCImage_CCImage_destructor(this: *mut cocos2d_CCImage);
}
#[doc = " @addtogroup platform\n @{"]
pub type cocos2d_CC_XML_CHAR = ::std::os::raw::c_uchar;
#[repr(C)]
pub struct cocos2d_CCSAXDelegator__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSAXDelegator {
    pub vtable_: *const cocos2d_CCSAXDelegator__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSAXDelegator() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSAXDelegator>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCSAXDelegator))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSAXDelegator>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSAXDelegator))
    );
}
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSAXParser {
    pub m_pDelegator: *mut cocos2d_CCSAXDelegator,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSAXParser() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSAXParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSAXParser>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCSAXParser))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSAXParser>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSAXParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSAXParser),
            "::",
            stringify!(m_pDelegator)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCSAXParser@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCSAXParser_init(
        this: *mut cocos2d_CCSAXParser,
        pszEncoding: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?parse@CCSAXParser@cocos2d@@QAE_NPBDI@Z"]
    pub fn cocos2d_CCSAXParser_parse(
        this: *mut cocos2d_CCSAXParser,
        pXMLData: *const ::std::os::raw::c_char,
        uDataLength: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?parse@CCSAXParser@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCSAXParser_parse1(
        this: *mut cocos2d_CCSAXParser,
        pszFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegator@CCSAXParser@cocos2d@@QAEXPAVCCSAXDelegator@2@@Z"]
    pub fn cocos2d_CCSAXParser_setDelegator(
        this: *mut cocos2d_CCSAXParser,
        pDelegator: *mut cocos2d_CCSAXDelegator,
    );
}
extern "C" {
    #[link_name = "\u{1}?startElement@CCSAXParser@cocos2d@@SAXPAXPBEPAPBE@Z"]
    pub fn cocos2d_CCSAXParser_startElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        atts: *mut *const cocos2d_CC_XML_CHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}?endElement@CCSAXParser@cocos2d@@SAXPAXPBE@Z"]
    pub fn cocos2d_CCSAXParser_endElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}?textHandler@CCSAXParser@cocos2d@@SAXPAXPBEH@Z"]
    pub fn cocos2d_CCSAXParser_textHandler(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        len: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCSAXParser@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSAXParser_CCSAXParser(this: *mut cocos2d_CCSAXParser);
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCSAXParser@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCSAXParser_CCSAXParser_destructor(this: *mut cocos2d_CCSAXParser);
}
impl cocos2d_CCSAXParser {
    #[inline]
    pub unsafe fn init(&mut self, pszEncoding: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCSAXParser_init(self, pszEncoding)
    }
    #[inline]
    pub unsafe fn parse(
        &mut self,
        pXMLData: *const ::std::os::raw::c_char,
        uDataLength: ::std::os::raw::c_uint,
    ) -> bool {
        cocos2d_CCSAXParser_parse(self, pXMLData, uDataLength)
    }
    #[inline]
    pub unsafe fn parse1(&mut self, pszFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCSAXParser_parse1(self, pszFile)
    }
    #[inline]
    pub unsafe fn setDelegator(&mut self, pDelegator: *mut cocos2d_CCSAXDelegator) {
        cocos2d_CCSAXParser_setDelegator(self, pDelegator)
    }
    #[inline]
    pub unsafe fn startElement(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        atts: *mut *const cocos2d_CC_XML_CHAR,
    ) {
        cocos2d_CCSAXParser_startElement(ctx, name, atts)
    }
    #[inline]
    pub unsafe fn endElement(ctx: *mut ::std::os::raw::c_void, name: *const cocos2d_CC_XML_CHAR) {
        cocos2d_CCSAXParser_endElement(ctx, name)
    }
    #[inline]
    pub unsafe fn textHandler(
        ctx: *mut ::std::os::raw::c_void,
        name: *const cocos2d_CC_XML_CHAR,
        len: ::std::os::raw::c_int,
    ) {
        cocos2d_CCSAXParser_textHandler(ctx, name, len)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCSAXParser_CCSAXParser(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCSAXParser_CCSAXParser_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCThread {
    pub m_pAutoreasePool: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cocos2d_CCThread() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCThread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCThread>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCThread))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCThread>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCThread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAutoreasePool) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCThread),
            "::",
            stringify!(m_pAutoreasePool)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?createAutoreleasePool@CCThread@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCThread_createAutoreleasePool(this: *mut cocos2d_CCThread);
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCThread@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCThread_CCThread_destructor(this: *mut cocos2d_CCThread);
}
impl cocos2d_CCThread {
    #[inline]
    pub unsafe fn createAutoreleasePool(&mut self) {
        cocos2d_CCThread_createAutoreleasePool(self)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCThread_CCThread_destructor(self)
    }
}
#[doc = " @addtogroup platform\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_cc_timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_cc_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_cc_timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_cc_timeval>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_cc_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_cc_timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_cc_timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_cc_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_cc_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTime {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTime() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTime>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCTime))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTime>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTime))
    );
}
extern "C" {
    #[link_name = "\u{1}?gettimeofdayCocos2d@CCTime@cocos2d@@SAHPAUcc_timeval@2@PAX@Z"]
    pub fn cocos2d_CCTime_gettimeofdayCocos2d(
        tp: *mut cocos2d_cc_timeval,
        tzp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?timersubCocos2d@CCTime@cocos2d@@SANPAUcc_timeval@2@0@Z"]
    pub fn cocos2d_CCTime_timersubCocos2d(
        start: *mut cocos2d_cc_timeval,
        end: *mut cocos2d_cc_timeval,
    ) -> f64;
}
impl cocos2d_CCTime {
    #[inline]
    pub unsafe fn gettimeofdayCocos2d(
        tp: *mut cocos2d_cc_timeval,
        tzp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCTime_gettimeofdayCocos2d(tp, tzp)
    }
    #[inline]
    pub unsafe fn timersubCocos2d(
        start: *mut cocos2d_cc_timeval,
        end: *mut cocos2d_cc_timeval,
    ) -> f64 {
        cocos2d_CCTime_timersubCocos2d(start, end)
    }
}
pub const cocos2d_TargetPlatform_kTargetWindows: cocos2d_TargetPlatform = 0;
pub const cocos2d_TargetPlatform_kTargetLinux: cocos2d_TargetPlatform = 1;
pub const cocos2d_TargetPlatform_kTargetMacOS: cocos2d_TargetPlatform = 2;
pub const cocos2d_TargetPlatform_kTargetAndroid: cocos2d_TargetPlatform = 3;
pub const cocos2d_TargetPlatform_kTargetIphone: cocos2d_TargetPlatform = 4;
pub const cocos2d_TargetPlatform_kTargetIpad: cocos2d_TargetPlatform = 5;
pub const cocos2d_TargetPlatform_kTargetBlackBerry: cocos2d_TargetPlatform = 6;
pub const cocos2d_TargetPlatform_kTargetNaCl: cocos2d_TargetPlatform = 7;
pub const cocos2d_TargetPlatform_kTargetEmscripten: cocos2d_TargetPlatform = 8;
pub const cocos2d_TargetPlatform_kTargetTizen: cocos2d_TargetPlatform = 9;
pub const cocos2d_TargetPlatform_kTargetWinRT: cocos2d_TargetPlatform = 10;
pub const cocos2d_TargetPlatform_kTargetWP8: cocos2d_TargetPlatform = 11;
pub type cocos2d_TargetPlatform = ::std::os::raw::c_int;
#[repr(C)]
pub struct cocos2d_CCApplicationProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup platform\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCApplicationProtocol {
    pub vtable_: *const cocos2d_CCApplicationProtocol__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCApplicationProtocol() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCApplicationProtocol>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCApplicationProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCApplicationProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCApplicationProtocol))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?applicationWillBecomeActive@CCApplicationProtocol@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplicationProtocol_applicationWillBecomeActive(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?applicationWillResignActive@CCApplicationProtocol@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplicationProtocol_applicationWillResignActive(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?trySaveGame@CCApplicationProtocol@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCApplicationProtocol_trySaveGame(this: *mut ::std::os::raw::c_void, a1: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?gameDidSave@CCApplicationProtocol@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplicationProtocol_gameDidSave(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?openURL@CCApplicationProtocol@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCApplicationProtocol_openURL(
        this: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
pub struct cocos2d_CCApplication {
    pub _base: cocos2d_CCApplicationProtocol,
    pub m_hInstance: HINSTANCE,
    pub m_hAccelTable: HACCEL,
    pub m_nAnimationInterval: LARGE_INTEGER,
    pub m_resourceRootPath: std_string,
    pub m_startupScriptFilename: std_string,
}
extern "C" {
    #[link_name = "\u{1}?sm_pSharedApplication@CCApplication@cocos2d@@2PAV12@A"]
    pub static mut cocos2d_CCApplication_sm_pSharedApplication: *mut cocos2d_CCApplication;
}
#[test]
fn bindgen_test_layout_cocos2d_CCApplication() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCApplication> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCApplication>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCApplication))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hInstance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_hInstance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_hAccelTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_hAccelTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nAnimationInterval) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_nAnimationInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_resourceRootPath) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_resourceRootPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startupScriptFilename) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCApplication),
            "::",
            stringify!(m_startupScriptFilename)
        )
    );
}
extern "C" {
    #[doc = "@brief    Get current applicaiton instance.\n@return Current application instance pointer."]
    #[link_name = "\u{1}?sharedApplication@CCApplication@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCApplication_sharedApplication() -> *mut cocos2d_CCApplication;
}
extern "thiscall" {
    #[link_name = "\u{1}?toggleVerticalSync@CCApplication@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCApplication_toggleVerticalSync(this: *mut cocos2d_CCApplication, arg1: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?getVerticalSyncEnabled@CCApplication@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCApplication_getVerticalSyncEnabled(this: *const cocos2d_CCApplication)
        -> bool;
}
extern "thiscall" {
    #[doc = "  Sets the Resource root path.\n  @deprecated Please use CCFileUtils::sharedFileUtils()->setSearchPaths() instead."]
    #[link_name = "\u{1}?setResourceRootPath@CCApplication@cocos2d@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCApplication_setResourceRootPath(
        this: *mut cocos2d_CCApplication,
        rootResDir: *const std_string,
    );
}
extern "thiscall" {
    #[doc = "  Gets the Resource root path.\n  @deprecated Please use CCFileUtils::sharedFileUtils()->getSearchPaths() instead."]
    #[link_name = "\u{1}?getResourceRootPath@CCApplication@cocos2d@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCApplication_getResourceRootPath(
        this: *mut cocos2d_CCApplication,
    ) -> *const std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?setStartupScriptFilename@CCApplication@cocos2d@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCApplication_setStartupScriptFilename(
        this: *mut cocos2d_CCApplication,
        startupScriptFile: *const std_string,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getControllerConnected@CCApplication@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCApplication_getControllerConnected(this: *const cocos2d_CCApplication)
        -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCApplication@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCApplication_CCApplication(this: *mut cocos2d_CCApplication);
}
impl cocos2d_CCApplication {
    #[inline]
    pub unsafe fn sharedApplication() -> *mut cocos2d_CCApplication {
        cocos2d_CCApplication_sharedApplication()
    }
    #[inline]
    pub unsafe fn toggleVerticalSync(&mut self, arg1: bool) {
        cocos2d_CCApplication_toggleVerticalSync(self, arg1)
    }
    #[inline]
    pub unsafe fn getVerticalSyncEnabled(&self) -> bool {
        cocos2d_CCApplication_getVerticalSyncEnabled(self)
    }
    #[inline]
    pub unsafe fn setResourceRootPath(&mut self, rootResDir: *const std_string) {
        cocos2d_CCApplication_setResourceRootPath(self, rootResDir)
    }
    #[inline]
    pub unsafe fn getResourceRootPath(&mut self) -> *const std_string {
        cocos2d_CCApplication_getResourceRootPath(self)
    }
    #[inline]
    pub unsafe fn setStartupScriptFilename(&mut self, startupScriptFile: *const std_string) {
        cocos2d_CCApplication_setStartupScriptFilename(self, startupScriptFile)
    }
    #[inline]
    pub unsafe fn getControllerConnected(&self) -> bool {
        cocos2d_CCApplication_getControllerConnected(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCApplication_CCApplication(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCApplication@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCApplication_CCApplication_destructor(this: *mut cocos2d_CCApplication);
}
extern "thiscall" {
    #[link_name = "\u{1}?gameDidSave@CCApplication@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplication_gameDidSave(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAnimationInterval@CCApplication@cocos2d@@UAEXN@Z"]
    pub fn cocos2d_CCApplication_setAnimationInterval(
        this: *mut ::std::os::raw::c_void,
        interval: f64,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getCurrentLanguage@CCApplication@cocos2d@@UAE?AW4LanguageType@2@XZ"]
    pub fn cocos2d_CCApplication_getCurrentLanguage(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_ccLanguageType;
}
extern "thiscall" {
    #[doc = "@brief Get target platform"]
    #[link_name = "\u{1}?getTargetPlatform@CCApplication@cocos2d@@UAE?AW4TargetPlatform@2@XZ"]
    pub fn cocos2d_CCApplication_getTargetPlatform(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_TargetPlatform;
}
extern "thiscall" {
    #[link_name = "\u{1}?openURL@CCApplication@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCApplication_openURL(
        this: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?run@CCApplication@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCApplication_run(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setupGLView@CCApplication@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplication_setupGLView(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?platformShutdown@CCApplication@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCApplication_platformShutdown(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct cocos2d_CCEGLViewProtocol__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup platform\n @{\n @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEGLViewProtocol {
    pub vtable_: *const cocos2d_CCEGLViewProtocol__bindgen_vtable,
    pub m_pDelegate: *mut cocos2d_EGLTouchDelegate,
    pub m_obScreenSize: cocos2d_CCSize,
    pub m_obDesignResolutionSize: cocos2d_CCSize,
    pub m_obViewPortRect: cocos2d_CCRect,
    pub m_szViewName: [::std::os::raw::c_char; 50usize],
    pub m_fScaleX: f32,
    pub m_fScaleY: f32,
    pub m_eResolutionPolicy: ResolutionPolicy,
}
#[test]
fn bindgen_test_layout_cocos2d_CCEGLViewProtocol() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCEGLViewProtocol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEGLViewProtocol>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCEGLViewProtocol))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEGLViewProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEGLViewProtocol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_pDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obScreenSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obScreenSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obDesignResolutionSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obDesignResolutionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obViewPortRect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_obViewPortRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_szViewName) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_szViewName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleX) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_fScaleX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fScaleY) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_fScaleY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eResolutionPolicy) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLViewProtocol),
            "::",
            stringify!(m_eResolutionPolicy)
        )
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?getViewName@CCEGLViewProtocol@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getViewName(
        this: *mut cocos2d_CCEGLViewProtocol,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " Get the opengl view port rectangle."]
    #[link_name = "\u{1}?getViewPortRect@CCEGLViewProtocol@cocos2d@@QBEABVCCRect@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getViewPortRect(
        this: *const cocos2d_CCEGLViewProtocol,
    ) -> *const cocos2d_CCRect;
}
extern "thiscall" {
    #[doc = " Get scale factor of the horizontal direction."]
    #[link_name = "\u{1}?getScaleX@CCEGLViewProtocol@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScaleX(this: *const cocos2d_CCEGLViewProtocol) -> f32;
}
extern "thiscall" {
    #[doc = " Get scale factor of the vertical direction."]
    #[link_name = "\u{1}?getScaleY@CCEGLViewProtocol@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScaleY(this: *const cocos2d_CCEGLViewProtocol) -> f32;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??0CCEGLViewProtocol@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_CCEGLViewProtocol(this: *mut cocos2d_CCEGLViewProtocol);
}
impl cocos2d_CCEGLViewProtocol {
    #[inline]
    pub unsafe fn getViewName(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCEGLViewProtocol_getViewName(self)
    }
    #[inline]
    pub unsafe fn getViewPortRect(&self) -> *const cocos2d_CCRect {
        cocos2d_CCEGLViewProtocol_getViewPortRect(self)
    }
    #[inline]
    pub unsafe fn getScaleX(&self) -> f32 {
        cocos2d_CCEGLViewProtocol_getScaleX(self)
    }
    #[inline]
    pub unsafe fn getScaleY(&self) -> f32 {
        cocos2d_CCEGLViewProtocol_getScaleY(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCEGLViewProtocol_CCEGLViewProtocol(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??1CCEGLViewProtocol@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_CCEGLViewProtocol_destructor(
        this: *mut cocos2d_CCEGLViewProtocol,
    );
}
extern "thiscall" {
    #[doc = " Get the frame size of EGL view.\n In general, it returns the screen size since the EGL view is a fullscreen view."]
    #[link_name = "\u{1}?getFrameSize@CCEGLViewProtocol@cocos2d@@UBEABVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getFrameSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " Set the frame size of EGL view."]
    #[link_name = "\u{1}?setFrameSize@CCEGLViewProtocol@cocos2d@@UAEXMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setFrameSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
    );
}
extern "thiscall" {
    #[doc = " Get the visible area size of opengl viewport."]
    #[link_name = "\u{1}?getVisibleSize@CCEGLViewProtocol@cocos2d@@UBE?AVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getVisibleSize(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " Get the visible origin point of opengl viewport."]
    #[link_name = "\u{1}?getVisibleOrigin@CCEGLViewProtocol@cocos2d@@UBE?AVCCPoint@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getVisibleOrigin(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " Set the design resolution size.\n @param width Design resolution width.\n @param height Design resolution height.\n @param resolutionPolicy The resolution policy desired, you may choose:\n                         [1] kResolutionExactFit Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.\n                         [2] kResolutionNoBorder Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.\n                         [3] kResolutionShowAll  Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown."]
    #[link_name = "\u{1}?setDesignResolutionSize@CCEGLViewProtocol@cocos2d@@UAEXMMW4ResolutionPolicy@@@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setDesignResolutionSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
        resolutionPolicy: ResolutionPolicy,
    );
}
extern "thiscall" {
    #[doc = " Get design resolution size.\n  Default resolution size is the same as 'getFrameSize'."]
    #[link_name = "\u{1}?getDesignResolutionSize@CCEGLViewProtocol@cocos2d@@UBEABVCCSize@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getDesignResolutionSize(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_CCSize;
}
extern "thiscall" {
    #[doc = " Set touch delegate"]
    #[link_name = "\u{1}?setTouchDelegate@CCEGLViewProtocol@cocos2d@@UAEXPAVEGLTouchDelegate@2@@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setTouchDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_EGLTouchDelegate,
    );
}
extern "thiscall" {
    #[doc = " Set opengl view port rectangle with points."]
    #[link_name = "\u{1}?setViewPortInPoints@CCEGLViewProtocol@cocos2d@@UAEXMMMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setViewPortInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "thiscall" {
    #[doc = " Set Scissor rectangle with points."]
    #[link_name = "\u{1}?setScissorInPoints@CCEGLViewProtocol@cocos2d@@UAEXMMMM@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setScissorInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "thiscall" {
    #[doc = " Get whether GL_SCISSOR_TEST is enable\n @lua NA"]
    #[link_name = "\u{1}?isScissorEnabled@CCEGLViewProtocol@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCEGLViewProtocol_isScissorEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = " Get the current scissor rectangle\n @lua NA"]
    #[link_name = "\u{1}?getScissorRect@CCEGLViewProtocol@cocos2d@@UAE?AVCCRect@2@XZ"]
    pub fn cocos2d_CCEGLViewProtocol_getScissorRect(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_CCRect;
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?setViewName@CCEGLViewProtocol@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCEGLViewProtocol_setViewName(
        this: *mut ::std::os::raw::c_void,
        pszViewName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Touch events are handled by default; if you want to customize your handlers, please override these functions:\n @lua NA"]
    #[link_name = "\u{1}?handleTouchesBegin@CCEGLViewProtocol@cocos2d@@UAEXHQAHQAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesBegin(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesMove@CCEGLViewProtocol@cocos2d@@UAEXHQAHQAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesMove(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesEnd@CCEGLViewProtocol@cocos2d@@UAEXHQAHQAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesEnd(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?handleTouchesCancel@CCEGLViewProtocol@cocos2d@@UAEXHQAHQAM1@Z"]
    pub fn cocos2d_CCEGLViewProtocol_handleTouchesCancel(
        this: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
        ids: *mut ::std::os::raw::c_int,
        xs: *mut f32,
        ys: *mut f32,
    );
}
pub type cocos2d_CUSTOM_WND_PROC = ::std::option::Option<
    unsafe extern "C" fn(
        message: UINT,
        wParam: WPARAM,
        lParam: LPARAM,
        pProcessed: *mut BOOL,
    ) -> LRESULT,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCEGL {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCEGLView {
    pub _base: cocos2d_CCEGLViewProtocol,
    pub _base_1: cocos2d_CCObject,
    pub m_bCaptured: bool,
    pub m_bSupportTouch: bool,
    pub m_bInRetinaMonitor: bool,
    pub m_bRetinaEnabled: bool,
    pub m_nRetinaFactor: ::std::os::raw::c_int,
    pub m_bCursorHidden: bool,
    pub m_fFrameZoomFactor: f32,
    pub m_pMainWindow: *mut GLFWwindow,
    pub m_pPrimaryMonitor: *mut GLFWmonitor,
    pub m_obWindowedSize: cocos2d_CCSize,
    pub m_fMouseX: f32,
    pub m_fMouseY: f32,
    pub m_bIsFullscreen: bool,
    pub m_bShouldHideCursor: bool,
    pub m_bShouldCallGLFinish: bool,
}
pub type cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK =
    ::std::option::Option<unsafe extern "C" fn(message: UINT, wParam: WPARAM, lParam: LPARAM)>;
extern "C" {
    #[link_name = "\u{1}?s_pEglView@CCEGLView@cocos2d@@1PAV12@A"]
    pub static mut cocos2d_CCEGLView_s_pEglView: *mut cocos2d_CCEGLView;
}
#[test]
fn bindgen_test_layout_cocos2d_CCEGLView() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCEGLView> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCEGLView>(),
        200usize,
        concat!("Size of: ", stringify!(cocos2d_CCEGLView))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCEGLView>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCEGLView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCaptured) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bCaptured)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSupportTouch) as usize - ptr as usize },
        157usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bSupportTouch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bInRetinaMonitor) as usize - ptr as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bInRetinaMonitor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRetinaEnabled) as usize - ptr as usize },
        159usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bRetinaEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nRetinaFactor) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_nRetinaFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCursorHidden) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bCursorHidden)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fFrameZoomFactor) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_fFrameZoomFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pMainWindow) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_pMainWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPrimaryMonitor) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_pPrimaryMonitor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_obWindowedSize) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_obWindowedSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fMouseX) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_fMouseX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fMouseY) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_fMouseY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bIsFullscreen) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bIsFullscreen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShouldHideCursor) as usize - ptr as usize },
        197usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bShouldHideCursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShouldCallGLFinish) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCEGLView),
            "::",
            stringify!(m_bShouldCallGLFinish)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setMenuResource@CCEGLView@cocos2d@@QAEXPB_W@Z"]
    pub fn cocos2d_CCEGLView_setMenuResource(this: *mut cocos2d_CCEGLView, menu: LPCWSTR);
}
extern "thiscall" {
    #[link_name = "\u{1}?setWndProc@CCEGLView@cocos2d@@QAEXP6AJIIJPAH@Z@Z"]
    pub fn cocos2d_CCEGLView_setWndProc(
        this: *mut cocos2d_CCEGLView,
        proc_: cocos2d_CUSTOM_WND_PROC,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initGL@CCEGLView@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCEGLView_initGL(this: *mut cocos2d_CCEGLView) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?destroyGL@CCEGLView@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCEGLView_destroyGL(this: *mut cocos2d_CCEGLView);
}
extern "thiscall" {
    #[link_name = "\u{1}?setHWnd@CCEGLView@cocos2d@@QAEXPAUHWND__@@@Z"]
    pub fn cocos2d_CCEGLView_setHWnd(this: *mut cocos2d_CCEGLView, hWnd: HWND);
}
extern "thiscall" {
    #[link_name = "\u{1}?resizeWindow@CCEGLView@cocos2d@@QAEXHH@Z"]
    pub fn cocos2d_CCEGLView_resizeWindow(
        this: *mut cocos2d_CCEGLView,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setFrameZoomFactor@CCEGLView@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCEGLView_setFrameZoomFactor(this: *mut cocos2d_CCEGLView, fZoomFactor: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?getFrameZoomFactor@CCEGLView@cocos2d@@QAEMXZ"]
    pub fn cocos2d_CCEGLView_getFrameZoomFactor(this: *mut cocos2d_CCEGLView) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?centerWindow@CCEGLView@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCEGLView_centerWindow(this: *mut cocos2d_CCEGLView);
}
extern "thiscall" {
    #[link_name = "\u{1}?showCursor@CCEGLView@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCEGLView_showCursor(this: *mut cocos2d_CCEGLView, state: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?setAccelerometerKeyHook@CCEGLView@cocos2d@@QAEXP6AXIIJ@Z@Z"]
    pub fn cocos2d_CCEGLView_setAccelerometerKeyHook(
        this: *mut cocos2d_CCEGLView,
        lpfnAccelerometerKeyHook: cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK,
    );
}
extern "C" {
    #[doc = "@brief    get the shared main open gl window"]
    #[link_name = "\u{1}?sharedOpenGLView@CCEGLView@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCEGLView_sharedOpenGLView() -> *mut cocos2d_CCEGLView;
}
extern "C" {
    #[link_name = "\u{1}?create@CCEGLView@cocos2d@@SAPAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCEGLView_create(arg1: *const std_string) -> *mut cocos2d_CCEGLView;
}
extern "thiscall" {
    #[link_name = "\u{1}?toggleFullScreen@CCEGLView@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCEGLView_toggleFullScreen(this: *mut cocos2d_CCEGLView, fullscreen: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?getWindow@CCEGLView@cocos2d@@QBEPAUGLFWwindow@@XZ"]
    pub fn cocos2d_CCEGLView_getWindow(this: *const cocos2d_CCEGLView) -> *mut GLFWwindow;
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWCharCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@I@Z"]
    pub fn cocos2d_CCEGLView_onGLFWCharCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        entered: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWCursorEnterFunCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@H@Z"]
    pub fn cocos2d_CCEGLView_onGLFWCursorEnterFunCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        entered: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWDeviceChangeFunCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@@Z"]
    pub fn cocos2d_CCEGLView_onGLFWDeviceChangeFunCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWError@CCEGLView@cocos2d@@IAEXHPBD@Z"]
    pub fn cocos2d_CCEGLView_onGLFWError(
        this: *mut cocos2d_CCEGLView,
        code: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWframebuffersize@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@HH@Z"]
    pub fn cocos2d_CCEGLView_onGLFWframebuffersize(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWMouseMoveCallBack@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@NN@Z"]
    pub fn cocos2d_CCEGLView_onGLFWMouseMoveCallBack(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        x: f64,
        y: f64,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWMouseCallBack@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@HHH@Z"]
    pub fn cocos2d_CCEGLView_onGLFWMouseCallBack(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        button: ::std::os::raw::c_int,
        action: ::std::os::raw::c_int,
        mods: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWKeyCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@HHHH@Z"]
    pub fn cocos2d_CCEGLView_onGLFWKeyCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        key: ::std::os::raw::c_int,
        scancode: ::std::os::raw::c_int,
        action: ::std::os::raw::c_int,
        mods: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWMouseScrollCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@NN@Z"]
    pub fn cocos2d_CCEGLView_onGLFWMouseScrollCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        xoffset: f64,
        yoffset: f64,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWWindowIconifyFunCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@H@Z"]
    pub fn cocos2d_CCEGLView_onGLFWWindowIconifyFunCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        iconified: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWWindowPosCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@HH@Z"]
    pub fn cocos2d_CCEGLView_onGLFWWindowPosCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?onGLFWWindowSizeFunCallback@CCEGLView@cocos2d@@IAEXPAUGLFWwindow@@HH@Z"]
    pub fn cocos2d_CCEGLView_onGLFWWindowSizeFunCallback(
        this: *mut cocos2d_CCEGLView,
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCEGLView@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCEGLView_CCEGLView(this: *mut cocos2d_CCEGLView);
}
impl cocos2d_CCEGLView {
    #[inline]
    pub unsafe fn setMenuResource(&mut self, menu: LPCWSTR) {
        cocos2d_CCEGLView_setMenuResource(self, menu)
    }
    #[inline]
    pub unsafe fn setWndProc(&mut self, proc_: cocos2d_CUSTOM_WND_PROC) {
        cocos2d_CCEGLView_setWndProc(self, proc_)
    }
    #[inline]
    pub unsafe fn initGL(&mut self) -> bool {
        cocos2d_CCEGLView_initGL(self)
    }
    #[inline]
    pub unsafe fn destroyGL(&mut self) {
        cocos2d_CCEGLView_destroyGL(self)
    }
    #[inline]
    pub unsafe fn setHWnd(&mut self, hWnd: HWND) {
        cocos2d_CCEGLView_setHWnd(self, hWnd)
    }
    #[inline]
    pub unsafe fn resizeWindow(
        &mut self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_resizeWindow(self, width, height)
    }
    #[inline]
    pub unsafe fn setFrameZoomFactor(&mut self, fZoomFactor: f32) {
        cocos2d_CCEGLView_setFrameZoomFactor(self, fZoomFactor)
    }
    #[inline]
    pub unsafe fn getFrameZoomFactor(&mut self) -> f32 {
        cocos2d_CCEGLView_getFrameZoomFactor(self)
    }
    #[inline]
    pub unsafe fn centerWindow(&mut self) {
        cocos2d_CCEGLView_centerWindow(self)
    }
    #[inline]
    pub unsafe fn showCursor(&mut self, state: bool) {
        cocos2d_CCEGLView_showCursor(self, state)
    }
    #[inline]
    pub unsafe fn setAccelerometerKeyHook(
        &mut self,
        lpfnAccelerometerKeyHook: cocos2d_CCEGLView_LPFN_ACCELEROMETER_KEYHOOK,
    ) {
        cocos2d_CCEGLView_setAccelerometerKeyHook(self, lpfnAccelerometerKeyHook)
    }
    #[inline]
    pub unsafe fn sharedOpenGLView() -> *mut cocos2d_CCEGLView {
        cocos2d_CCEGLView_sharedOpenGLView()
    }
    #[inline]
    pub unsafe fn create(arg1: *const std_string) -> *mut cocos2d_CCEGLView {
        cocos2d_CCEGLView_create(arg1)
    }
    #[inline]
    pub unsafe fn toggleFullScreen(&mut self, fullscreen: bool) {
        cocos2d_CCEGLView_toggleFullScreen(self, fullscreen)
    }
    #[inline]
    pub unsafe fn getWindow(&self) -> *mut GLFWwindow {
        cocos2d_CCEGLView_getWindow(self)
    }
    #[inline]
    pub unsafe fn onGLFWCharCallback(
        &mut self,
        window: *mut GLFWwindow,
        entered: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCEGLView_onGLFWCharCallback(self, window, entered)
    }
    #[inline]
    pub unsafe fn onGLFWCursorEnterFunCallback(
        &mut self,
        window: *mut GLFWwindow,
        entered: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWCursorEnterFunCallback(self, window, entered)
    }
    #[inline]
    pub unsafe fn onGLFWDeviceChangeFunCallback(&mut self, window: *mut GLFWwindow) {
        cocos2d_CCEGLView_onGLFWDeviceChangeFunCallback(self, window)
    }
    #[inline]
    pub unsafe fn onGLFWError(
        &mut self,
        code: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCEGLView_onGLFWError(self, code, description)
    }
    #[inline]
    pub unsafe fn onGLFWframebuffersize(
        &mut self,
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWframebuffersize(self, window, width, height)
    }
    #[inline]
    pub unsafe fn onGLFWMouseMoveCallBack(&mut self, window: *mut GLFWwindow, x: f64, y: f64) {
        cocos2d_CCEGLView_onGLFWMouseMoveCallBack(self, window, x, y)
    }
    #[inline]
    pub unsafe fn onGLFWMouseCallBack(
        &mut self,
        window: *mut GLFWwindow,
        button: ::std::os::raw::c_int,
        action: ::std::os::raw::c_int,
        mods: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWMouseCallBack(self, window, button, action, mods)
    }
    #[inline]
    pub unsafe fn onGLFWKeyCallback(
        &mut self,
        window: *mut GLFWwindow,
        key: ::std::os::raw::c_int,
        scancode: ::std::os::raw::c_int,
        action: ::std::os::raw::c_int,
        mods: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWKeyCallback(self, window, key, scancode, action, mods)
    }
    #[inline]
    pub unsafe fn onGLFWMouseScrollCallback(
        &mut self,
        window: *mut GLFWwindow,
        xoffset: f64,
        yoffset: f64,
    ) {
        cocos2d_CCEGLView_onGLFWMouseScrollCallback(self, window, xoffset, yoffset)
    }
    #[inline]
    pub unsafe fn onGLFWWindowIconifyFunCallback(
        &mut self,
        window: *mut GLFWwindow,
        iconified: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWWindowIconifyFunCallback(self, window, iconified)
    }
    #[inline]
    pub unsafe fn onGLFWWindowPosCallback(
        &mut self,
        window: *mut GLFWwindow,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWWindowPosCallback(self, window, x, y)
    }
    #[inline]
    pub unsafe fn onGLFWWindowSizeFunCallback(
        &mut self,
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        cocos2d_CCEGLView_onGLFWWindowSizeFunCallback(self, window, width, height)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCEGLView_CCEGLView(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?isOpenGLReady@CCEGLView@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCEGLView_isOpenGLReady(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?end@CCEGLView@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCEGLView_end(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?swapBuffers@CCEGLView@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCEGLView_swapBuffers(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?setFrameSize@CCEGLView@cocos2d@@UAEXMM@Z"]
    pub fn cocos2d_CCEGLView_setFrameSize(
        this: *mut ::std::os::raw::c_void,
        width: f32,
        height: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setIMEKeyboardState@CCEGLView@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCEGLView_setIMEKeyboardState(this: *mut ::std::os::raw::c_void, bOpen: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?setViewPortInPoints@CCEGLView@cocos2d@@UAEXMMMM@Z"]
    pub fn cocos2d_CCEGLView_setViewPortInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setScissorInPoints@CCEGLView@cocos2d@@UAEXMMMM@Z"]
    pub fn cocos2d_CCEGLView_setScissorInPoints(
        this: *mut ::std::os::raw::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
    );
}
#[doc = " CCShaderCache\nSingleton that stores manages GL shaders\n@since v2.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCShaderCache {
    pub _base: cocos2d_CCObject,
    pub m_pPrograms: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCShaderCache() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCShaderCache> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCShaderCache>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCShaderCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCShaderCache>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCShaderCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPrograms) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCShaderCache),
            "::",
            stringify!(m_pPrograms)
        )
    );
}
extern "C" {
    #[doc = " returns the shared instance\n  @js getInstance"]
    #[link_name = "\u{1}?sharedShaderCache@CCShaderCache@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCShaderCache_sharedShaderCache() -> *mut cocos2d_CCShaderCache;
}
extern "C" {
    #[doc = " purges the cache. It releases the retained instance."]
    #[link_name = "\u{1}?purgeSharedShaderCache@CCShaderCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCShaderCache_purgeSharedShaderCache();
}
extern "thiscall" {
    #[doc = " loads the default shaders"]
    #[link_name = "\u{1}?loadDefaultShaders@CCShaderCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCShaderCache_loadDefaultShaders(this: *mut cocos2d_CCShaderCache);
}
extern "thiscall" {
    #[doc = " reload the default shaders"]
    #[link_name = "\u{1}?reloadDefaultShaders@CCShaderCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCShaderCache_reloadDefaultShaders(this: *mut cocos2d_CCShaderCache);
}
extern "thiscall" {
    #[doc = " returns a GL program for a given key\n  @js getProgram"]
    #[link_name = "\u{1}?programForKey@CCShaderCache@cocos2d@@QAEPAVCCGLProgram@2@PBD@Z"]
    pub fn cocos2d_CCShaderCache_programForKey(
        this: *mut cocos2d_CCShaderCache,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCGLProgram;
}
extern "thiscall" {
    #[doc = " adds a CCGLProgram to the cache for a given name"]
    #[link_name = "\u{1}?addProgram@CCShaderCache@cocos2d@@QAEXPAVCCGLProgram@2@PBD@Z"]
    pub fn cocos2d_CCShaderCache_addProgram(
        this: *mut cocos2d_CCShaderCache,
        program: *mut cocos2d_CCGLProgram,
        key: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCShaderCache@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCShaderCache_CCShaderCache(this: *mut cocos2d_CCShaderCache);
}
impl cocos2d_CCShaderCache {
    #[inline]
    pub unsafe fn sharedShaderCache() -> *mut cocos2d_CCShaderCache {
        cocos2d_CCShaderCache_sharedShaderCache()
    }
    #[inline]
    pub unsafe fn purgeSharedShaderCache() {
        cocos2d_CCShaderCache_purgeSharedShaderCache()
    }
    #[inline]
    pub unsafe fn loadDefaultShaders(&mut self) {
        cocos2d_CCShaderCache_loadDefaultShaders(self)
    }
    #[inline]
    pub unsafe fn reloadDefaultShaders(&mut self) {
        cocos2d_CCShaderCache_reloadDefaultShaders(self)
    }
    #[inline]
    pub unsafe fn programForKey(
        &mut self,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCGLProgram {
        cocos2d_CCShaderCache_programForKey(self, key)
    }
    #[inline]
    pub unsafe fn addProgram(
        &mut self,
        program: *mut cocos2d_CCGLProgram,
        key: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCShaderCache_addProgram(self, program, key)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCShaderCache_CCShaderCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCShaderCache@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCShaderCache_CCShaderCache_destructor(this: *mut cocos2d_CCShaderCache);
}
extern "C" {
    #[doc = " @addtogroup shaders\n @{"]
    #[link_name = "\u{1}?ccPosition_uColor_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPosition_uColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPosition_uColor_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPosition_uColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColor_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColor_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTexture_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTexture_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureA8Color_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTextureA8Color_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureA8Color_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTextureA8Color_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColor_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTextureColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColor_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTextureColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTextureColorAlphaTest_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTextureColorAlphaTest_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_uColor_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTexture_uColor_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionTexture_uColor_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionTexture_uColor_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColorLengthTexture_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionColorLengthTexture_frag: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccPositionColorLengthTexture_vert@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccPositionColorLengthTexture_vert: *const GLchar;
}
extern "C" {
    #[link_name = "\u{1}?ccExSwitchMask_frag@cocos2d@@3PBDB"]
    pub static mut cocos2d_ccExSwitchMask_frag: *const GLchar;
}
#[doc = " Singleton that manages the Animations.\nIt saves in a cache the animations. You should use this class if you want to save your animations in a cache.\n\nBefore v0.99.5, the recommend way was to save them on the CCSprite. Since v0.99.5, you should use this class instead.\n\n@since v0.99.5"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCAnimationCache {
    pub _base: cocos2d_CCObject,
    pub m_pAnimations: *mut cocos2d_CCDictionary,
}
extern "C" {
    #[link_name = "\u{1}?s_pSharedAnimationCache@CCAnimationCache@cocos2d@@0PAV12@A"]
    pub static mut cocos2d_CCAnimationCache_s_pSharedAnimationCache: *mut cocos2d_CCAnimationCache;
}
#[test]
fn bindgen_test_layout_cocos2d_CCAnimationCache() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCAnimationCache> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCAnimationCache>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCAnimationCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCAnimationCache>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCAnimationCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAnimations) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCAnimationCache),
            "::",
            stringify!(m_pAnimations)
        )
    );
}
extern "C" {
    #[doc = " Returns the shared instance of the Animation cache\n  @js getInstance"]
    #[link_name = "\u{1}?sharedAnimationCache@CCAnimationCache@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCAnimationCache_sharedAnimationCache() -> *mut cocos2d_CCAnimationCache;
}
extern "C" {
    #[doc = " Purges the cache. It releases all the CCAnimation objects and the shared instance."]
    #[link_name = "\u{1}?purgeSharedAnimationCache@CCAnimationCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCAnimationCache_purgeSharedAnimationCache();
}
extern "thiscall" {
    #[doc = " Adds a CCAnimation with a name."]
    #[link_name = "\u{1}?addAnimation@CCAnimationCache@cocos2d@@QAEXPAVCCAnimation@2@PBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimation(
        this: *mut cocos2d_CCAnimationCache,
        animation: *mut cocos2d_CCAnimation,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Deletes a CCAnimation from the cache.\n@js removeAnimation"]
    #[link_name = "\u{1}?removeAnimationByName@CCAnimationCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCAnimationCache_removeAnimationByName(
        this: *mut cocos2d_CCAnimationCache,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Returns a CCAnimation that was previously added.\nIf the name is not found it will return nil.\nYou should retain the returned copy if you are going to use it.\n@js getAnimation"]
    #[link_name = "\u{1}?animationByName@CCAnimationCache@cocos2d@@QAEPAVCCAnimation@2@PBD@Z"]
    pub fn cocos2d_CCAnimationCache_animationByName(
        this: *mut cocos2d_CCAnimationCache,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCAnimation;
}
extern "thiscall" {
    #[doc = " Adds an animation from an NSDictionary\nMake sure that the frames were previously loaded in the CCSpriteFrameCache.\n@param plist The path of the relative file,it use to find the plist path for load SpriteFrames.\n@since v1.1"]
    #[link_name = "\u{1}?addAnimationsWithDictionary@CCAnimationCache@cocos2d@@QAEXPAVCCDictionary@2@PBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimationsWithDictionary(
        this: *mut cocos2d_CCAnimationCache,
        dictionary: *mut cocos2d_CCDictionary,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Adds an animation from a plist file.\nMake sure that the frames were previously loaded in the CCSpriteFrameCache.\n@since v1.1\n@js addAnimations"]
    #[link_name = "\u{1}?addAnimationsWithFile@CCAnimationCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCAnimationCache_addAnimationsWithFile(
        this: *mut cocos2d_CCAnimationCache,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCAnimationCache@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCAnimationCache_init(this: *mut cocos2d_CCAnimationCache) -> bool;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCAnimationCache@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCAnimationCache_CCAnimationCache(this: *mut cocos2d_CCAnimationCache);
}
impl cocos2d_CCAnimationCache {
    #[inline]
    pub unsafe fn sharedAnimationCache() -> *mut cocos2d_CCAnimationCache {
        cocos2d_CCAnimationCache_sharedAnimationCache()
    }
    #[inline]
    pub unsafe fn purgeSharedAnimationCache() {
        cocos2d_CCAnimationCache_purgeSharedAnimationCache()
    }
    #[inline]
    pub unsafe fn addAnimation(
        &mut self,
        animation: *mut cocos2d_CCAnimation,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimationCache_addAnimation(self, animation, name)
    }
    #[inline]
    pub unsafe fn removeAnimationByName(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCAnimationCache_removeAnimationByName(self, name)
    }
    #[inline]
    pub unsafe fn animationByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCAnimation {
        cocos2d_CCAnimationCache_animationByName(self, name)
    }
    #[inline]
    pub unsafe fn addAnimationsWithDictionary(
        &mut self,
        dictionary: *mut cocos2d_CCDictionary,
        plist: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCAnimationCache_addAnimationsWithDictionary(self, dictionary, plist)
    }
    #[inline]
    pub unsafe fn addAnimationsWithFile(&mut self, plist: *const ::std::os::raw::c_char) {
        cocos2d_CCAnimationCache_addAnimationsWithFile(self, plist)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCAnimationCache_init(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCAnimationCache_CCAnimationCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCAnimationCache@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCAnimationCache_CCAnimationCache_destructor(
        this: *mut cocos2d_CCAnimationCache,
    );
}
#[doc = " @brief Singleton that handles the loading of the sprite frames.\nIt saves in a cache the sprite frames.\n@since v0.9"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCSpriteFrameCache {
    pub _base: cocos2d_CCObject,
    pub m_pSpriteFrames: *mut cocos2d_CCDictionary,
    pub m_pSpriteFramesAliases: *mut cocos2d_CCDictionary,
    pub m_pLoadedFileNames: *mut u8,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSpriteFrameCache() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCSpriteFrameCache> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSpriteFrameCache>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCSpriteFrameCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSpriteFrameCache>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCSpriteFrameCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSpriteFrames) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pSpriteFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pSpriteFramesAliases) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pSpriteFramesAliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLoadedFileNames) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCSpriteFrameCache),
            "::",
            stringify!(m_pLoadedFileNames)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCSpriteFrameCache@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCSpriteFrameCache_init(this: *mut cocos2d_CCSpriteFrameCache) -> bool;
}
extern "thiscall" {
    #[doc = " Adds multiple Sprite Frames from a plist file.\n A texture will be loaded automatically. The texture name will composed by replacing the .plist suffix with .png\n If you want to use another texture, you should use the addSpriteFramesWithFile:texture method.\n @js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszPlist: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.\n@since v0.99.5\n@js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QAEXPBD0@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile1(
        this: *mut cocos2d_CCSpriteFrameCache,
        plist: *const ::std::os::raw::c_char,
        textureFileName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.\n @js addSpriteFrames"]
    #[link_name = "\u{1}?addSpriteFramesWithFile@CCSpriteFrameCache@cocos2d@@QAEXPBDPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile2(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszPlist: *const ::std::os::raw::c_char,
        pobTexture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " Adds an sprite frame with a given name.\nIf the name already exists, then the contents of the old name will be replaced with the new one."]
    #[link_name = "\u{1}?addSpriteFrame@CCSpriteFrameCache@cocos2d@@QAEXPAVCCSpriteFrame@2@PBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_addSpriteFrame(
        this: *mut cocos2d_CCSpriteFrameCache,
        pobFrame: *mut cocos2d_CCSpriteFrame,
        pszFrameName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Purges the dictionary of loaded sprite frames.\n Call this method if you receive the \"Memory Warning\".\n In the short term: it will free some resources preventing your app from being killed.\n In the medium term: it will allocate more resources.\n In the long term: it will be the same."]
    #[link_name = "\u{1}?removeSpriteFrames@CCSpriteFrameCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFrames(this: *mut cocos2d_CCSpriteFrameCache);
}
extern "thiscall" {
    #[doc = " Removes unused sprite frames.\n Sprite Frames that have a retain count of 1 will be deleted.\n It is convenient to call this method after when starting a new Scene."]
    #[link_name = "\u{1}?removeUnusedSpriteFrames@CCSpriteFrameCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_removeUnusedSpriteFrames(
        this: *mut cocos2d_CCSpriteFrameCache,
    );
}
extern "thiscall" {
    #[doc = " Deletes an sprite frame from the sprite frame cache.\n  @js getSpriteFrame"]
    #[link_name = "\u{1}?removeSpriteFrameByName@CCSpriteFrameCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFrameByName(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Removes multiple Sprite Frames from a plist file.\n Sprite Frames stored in this file will be removed.\n It is convenient to call this method when a specific texture needs to be removed.\n @since v0.99.5"]
    #[link_name = "\u{1}?removeSpriteFramesFromFile@CCSpriteFrameCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFramesFromFile(
        this: *mut cocos2d_CCSpriteFrameCache,
        plist: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Removes all Sprite Frames associated with the specified textures.\n It is convenient to call this method when a specific texture needs to be removed.\n @since v0.995."]
    #[link_name = "\u{1}?removeSpriteFramesFromTexture@CCSpriteFrameCache@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCSpriteFrameCache_removeSpriteFramesFromTexture(
        this: *mut cocos2d_CCSpriteFrameCache,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " Returns an Sprite Frame that was previously added.\nIf the name is not found it will return nil.\nYou should retain the returned copy if you are going to use it.\n@js getSpriteFrame"]
    #[link_name = "\u{1}?spriteFrameByName@CCSpriteFrameCache@cocos2d@@QAEPAVCCSpriteFrame@2@PBD@Z"]
    pub fn cocos2d_CCSpriteFrameCache_spriteFrameByName(
        this: *mut cocos2d_CCSpriteFrameCache,
        pszName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSpriteFrame;
}
extern "C" {
    #[doc = " Returns the shared instance of the Sprite Frame cache\n  @js getInstance"]
    #[link_name = "\u{1}?sharedSpriteFrameCache@CCSpriteFrameCache@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCSpriteFrameCache_sharedSpriteFrameCache() -> *mut cocos2d_CCSpriteFrameCache;
}
extern "C" {
    #[doc = " Purges the cache. It releases all the Sprite Frames and the retained instance."]
    #[link_name = "\u{1}?purgeSharedSpriteFrameCache@CCSpriteFrameCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCSpriteFrameCache_purgeSharedSpriteFrameCache();
}
impl cocos2d_CCSpriteFrameCache {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCSpriteFrameCache_init(self)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile(&mut self, pszPlist: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile(self, pszPlist)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile1(
        &mut self,
        plist: *const ::std::os::raw::c_char,
        textureFileName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile1(self, plist, textureFileName)
    }
    #[inline]
    pub unsafe fn addSpriteFramesWithFile2(
        &mut self,
        pszPlist: *const ::std::os::raw::c_char,
        pobTexture: *mut cocos2d_CCTexture2D,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFramesWithFile2(self, pszPlist, pobTexture)
    }
    #[inline]
    pub unsafe fn addSpriteFrame(
        &mut self,
        pobFrame: *mut cocos2d_CCSpriteFrame,
        pszFrameName: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCSpriteFrameCache_addSpriteFrame(self, pobFrame, pszFrameName)
    }
    #[inline]
    pub unsafe fn removeSpriteFrames(&mut self) {
        cocos2d_CCSpriteFrameCache_removeSpriteFrames(self)
    }
    #[inline]
    pub unsafe fn removeUnusedSpriteFrames(&mut self) {
        cocos2d_CCSpriteFrameCache_removeUnusedSpriteFrames(self)
    }
    #[inline]
    pub unsafe fn removeSpriteFrameByName(&mut self, pszName: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_removeSpriteFrameByName(self, pszName)
    }
    #[inline]
    pub unsafe fn removeSpriteFramesFromFile(&mut self, plist: *const ::std::os::raw::c_char) {
        cocos2d_CCSpriteFrameCache_removeSpriteFramesFromFile(self, plist)
    }
    #[inline]
    pub unsafe fn removeSpriteFramesFromTexture(&mut self, texture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCSpriteFrameCache_removeSpriteFramesFromTexture(self, texture)
    }
    #[inline]
    pub unsafe fn spriteFrameByName(
        &mut self,
        pszName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCSpriteFrame {
        cocos2d_CCSpriteFrameCache_spriteFrameByName(self, pszName)
    }
    #[inline]
    pub unsafe fn sharedSpriteFrameCache() -> *mut cocos2d_CCSpriteFrameCache {
        cocos2d_CCSpriteFrameCache_sharedSpriteFrameCache()
    }
    #[inline]
    pub unsafe fn purgeSharedSpriteFrameCache() {
        cocos2d_CCSpriteFrameCache_purgeSharedSpriteFrameCache()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCSpriteFrameCache@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCSpriteFrameCache_CCSpriteFrameCache_destructor(
        this: *mut cocos2d_CCSpriteFrameCache,
    );
}
extern "C" {
    #[link_name = "\u{1}?cc_wcslen@cocos2d@@YAHPBG@Z"]
    pub fn cocos2d_cc_wcslen(str_: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_trim_ws@cocos2d@@YAXPAV?$vector@GV?$allocator@G@std@@@std@@@Z"]
    pub fn cocos2d_cc_utf8_trim_ws(str_: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}?isspace_unicode@cocos2d@@YA_NG@Z"]
    pub fn cocos2d_isspace_unicode(ch: ::std::os::raw::c_ushort) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_strlen@cocos2d@@YAJPBDH@Z"]
    pub fn cocos2d_cc_utf8_strlen(
        p: *const ::std::os::raw::c_char,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_find_last_not_char@cocos2d@@YAIV?$vector@GV?$allocator@G@std@@@std@@G@Z"]
    pub fn cocos2d_cc_utf8_find_last_not_char(
        str_: u8,
        c: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf16_vec_from_utf16_str@cocos2d@@YA?AV?$vector@GV?$allocator@G@std@@@std@@PBG@Z"]
    pub fn cocos2d_cc_utf16_vec_from_utf16_str(str_: *const ::std::os::raw::c_ushort) -> u8;
}
extern "C" {
    #[link_name = "\u{1}?cc_utf8_to_utf16@cocos2d@@YAPAGPBDHPAH@Z"]
    pub fn cocos2d_cc_utf8_to_utf16(
        str_old: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        rUtf16Size: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " cc_utf16_to_utf8:\n @str: a UTF-16 encoded string\n @len: the maximum length of @str to use. If @len < 0, then\n       the string is terminated with a 0 character.\n @items_read: location to store number of words read, or %NULL.\n              If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be\n              returned in case @str contains a trailing partial\n              character. If an error occurs then the index of the\n              invalid input is stored here.\n @items_written: location to store number of bytes written, or %NULL.\n                 The value stored here does not include the trailing\n                 0 byte.\n @error: location to store the error occuring, or %NULL to ignore\n         errors. Any of the errors in #GConvertError other than\n         %G_CONVERT_ERROR_NO_CONVERSION may occur.\n\n Convert a string from UTF-16 to UTF-8. The result will be\n terminated with a 0 byte.\n\n Return value: a pointer to a newly allocated UTF-8 string.\n               This value must be freed with free(). If an\n               error occurs, %NULL will be returned and\n               @error set."]
    #[link_name = "\u{1}?cc_utf16_to_utf8@cocos2d@@YAPADPBGJPAJ1@Z"]
    pub fn cocos2d_cc_utf16_to_utf8(
        str_: *const ::std::os::raw::c_ushort,
        len: ::std::os::raw::c_long,
        items_read: *mut ::std::os::raw::c_long,
        items_written: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCNotificationCenter {
    pub _base: cocos2d_CCObject,
    pub m_observers: *mut cocos2d_CCArray,
    pub m_scriptHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNotificationCenter() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCNotificationCenter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNotificationCenter>(),
        60usize,
        concat!("Size of: ", stringify!(cocos2d_CCNotificationCenter))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNotificationCenter>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNotificationCenter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_observers) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationCenter),
            "::",
            stringify!(m_observers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_scriptHandler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationCenter),
            "::",
            stringify!(m_scriptHandler)
        )
    );
}
extern "C" {
    #[doc = " Gets the single instance of CCNotificationCenter."]
    #[link_name = "\u{1}?sharedNotificationCenter@CCNotificationCenter@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCNotificationCenter_sharedNotificationCenter(
    ) -> *mut cocos2d_CCNotificationCenter;
}
extern "C" {
    #[doc = " Destroys the single instance of CCNotificationCenter."]
    #[link_name = "\u{1}?purgeNotificationCenter@CCNotificationCenter@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCNotificationCenter_purgeNotificationCenter();
}
extern "thiscall" {
    #[doc = " @brief Adds an observer for the specified target.\n  @param target The target which wants to observe notification events.\n  @param selector The callback function which will be invoked when the specified notification event was posted.\n  @param name The name of this notification.\n  @param obj The extra parameter which will be passed to the callback function."]
    #[link_name = "\u{1}?addObserver@CCNotificationCenter@cocos2d@@QAEXPAVCCObject@2@P832@AEX0@ZPBD0@Z"]
    pub fn cocos2d_CCNotificationCenter_addObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " @brief Removes the observer by the specified target and name.\n  @param target The target of this notification.\n  @param name The name of this notification."]
    #[link_name = "\u{1}?removeObserver@CCNotificationCenter@cocos2d@@QAEXPAVCCObject@2@PBD@Z"]
    pub fn cocos2d_CCNotificationCenter_removeObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @brief Removes all notifications registered by this target\n  @param target The target of this notification.\n  @returns the number of observers removed"]
    #[link_name = "\u{1}?removeAllObservers@CCNotificationCenter@cocos2d@@QAEHPAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationCenter_removeAllObservers(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " @brief Registers one hander for script binding.\n  @note Only supports Lua Binding now.\n  @param handler The lua handler."]
    #[link_name = "\u{1}?registerScriptObserver@CCNotificationCenter@cocos2d@@QAEXPAVCCObject@2@HPBD@Z"]
    pub fn cocos2d_CCNotificationCenter_registerScriptObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        handler: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Unregisters script observer"]
    #[link_name = "\u{1}?unregisterScriptObserver@CCNotificationCenter@cocos2d@@QAEXPAVCCObject@2@PBD@Z"]
    pub fn cocos2d_CCNotificationCenter_unregisterScriptObserver(
        this: *mut cocos2d_CCNotificationCenter,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @brief Posts one notification event by name.\n  @param name The name of this notification."]
    #[link_name = "\u{1}?postNotification@CCNotificationCenter@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCNotificationCenter_postNotification(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @brief Posts one notification event by name.\n  @param name The name of this notification.\n  @param object The extra parameter."]
    #[link_name = "\u{1}?postNotification@CCNotificationCenter@cocos2d@@QAEXPBDPAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationCenter_postNotification1(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
        object: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " @brief Gets observer script handler.\n  @param name The name of this notification.\n  @return The observer script handle."]
    #[link_name = "\u{1}?getObserverHandlerByName@CCNotificationCenter@cocos2d@@QAEHPBD@Z"]
    pub fn cocos2d_CCNotificationCenter_getObserverHandlerByName(
        this: *mut cocos2d_CCNotificationCenter,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = " CCNotificationCenter constructor"]
    #[link_name = "\u{1}??0CCNotificationCenter@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCNotificationCenter_CCNotificationCenter(
        this: *mut cocos2d_CCNotificationCenter,
    );
}
impl cocos2d_CCNotificationCenter {
    #[inline]
    pub unsafe fn sharedNotificationCenter() -> *mut cocos2d_CCNotificationCenter {
        cocos2d_CCNotificationCenter_sharedNotificationCenter()
    }
    #[inline]
    pub unsafe fn purgeNotificationCenter() {
        cocos2d_CCNotificationCenter_purgeNotificationCenter()
    }
    #[inline]
    pub unsafe fn addObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCNotificationCenter_addObserver(self, target, selector, name, obj)
    }
    #[inline]
    pub unsafe fn removeObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_removeObserver(self, target, name)
    }
    #[inline]
    pub unsafe fn removeAllObservers(
        &mut self,
        target: *mut cocos2d_CCObject,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCNotificationCenter_removeAllObservers(self, target)
    }
    #[inline]
    pub unsafe fn registerScriptObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        handler: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_registerScriptObserver(self, target, handler, name)
    }
    #[inline]
    pub unsafe fn unregisterScriptObserver(
        &mut self,
        target: *mut cocos2d_CCObject,
        name: *const ::std::os::raw::c_char,
    ) {
        cocos2d_CCNotificationCenter_unregisterScriptObserver(self, target, name)
    }
    #[inline]
    pub unsafe fn postNotification(&mut self, name: *const ::std::os::raw::c_char) {
        cocos2d_CCNotificationCenter_postNotification(self, name)
    }
    #[inline]
    pub unsafe fn postNotification1(
        &mut self,
        name: *const ::std::os::raw::c_char,
        object: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCNotificationCenter_postNotification1(self, name, object)
    }
    #[inline]
    pub unsafe fn getObserverHandlerByName(
        &mut self,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCNotificationCenter_getObserverHandlerByName(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNotificationCenter_CCNotificationCenter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " CCNotificationCenter destructor"]
    #[link_name = "\u{1}??1CCNotificationCenter@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCNotificationCenter_CCNotificationCenter_destructor(
        this: *mut cocos2d_CCNotificationCenter,
    );
}
#[doc = " @js NA\n @lua NA"]
#[repr(C)]
pub struct cocos2d_CCNotificationObserver {
    pub _base: cocos2d_CCObject,
    pub m_target: *mut cocos2d_CCObject,
    pub m_selector: cocos2d_SEL_CallFuncO,
    pub m_name: *mut ::std::os::raw::c_char,
    pub m_object: *mut cocos2d_CCObject,
    pub m_nHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCNotificationObserver() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCNotificationObserver> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCNotificationObserver>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCNotificationObserver))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCNotificationObserver>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCNotificationObserver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_target) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_selector) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_object) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nHandler) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCNotificationObserver),
            "::",
            stringify!(m_nHandler)
        )
    );
}
extern "thiscall" {
    #[doc = " Invokes the callback function of this observer"]
    #[link_name = "\u{1}?performSelector@CCNotificationObserver@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCNotificationObserver_performSelector(
        this: *mut cocos2d_CCNotificationObserver,
        obj: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " @brief CCNotificationObserver constructor\n  @param target The target which wants to observer notification events.\n  @param selector The callback function which will be invoked when the specified notification event was posted.\n  @param name The name of this notification.\n  @param obj The extra parameter which will be passed to the callback function."]
    #[link_name = "\u{1}??0CCNotificationObserver@cocos2d@@QAE@PAVCCObject@1@P821@AEX0@ZPBD0@Z"]
    pub fn cocos2d_CCNotificationObserver_CCNotificationObserver(
        this: *mut cocos2d_CCNotificationObserver,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    );
}
impl cocos2d_CCNotificationObserver {
    #[inline]
    pub unsafe fn performSelector(&mut self, obj: *mut cocos2d_CCObject) {
        cocos2d_CCNotificationObserver_performSelector(self, obj)
    }
    #[inline]
    pub unsafe fn new(
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
        name: *const ::std::os::raw::c_char,
        obj: *mut cocos2d_CCObject,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCNotificationObserver_CCNotificationObserver(
            __bindgen_tmp.as_mut_ptr(),
            target,
            selector,
            name,
            obj,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " CCNotificationObserver destructor function"]
    #[link_name = "\u{1}??1CCNotificationObserver@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCNotificationObserver_CCNotificationObserver_destructor(
        this: *mut cocos2d_CCNotificationObserver,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getTarget@CCNotificationObserver@cocos2d@@UAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCNotificationObserver_getTarget(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?getSelector@CCNotificationObserver@cocos2d@@UAEP8CCObject@2@AEXPAV32@@ZXZ"]
    pub fn cocos2d_CCNotificationObserver_getSelector(
        this: *mut ::std::os::raw::c_void,
    ) -> cocos2d_SEL_CallFuncO;
}
extern "thiscall" {
    #[link_name = "\u{1}?getName@CCNotificationObserver@cocos2d@@UAEPADXZ"]
    pub fn cocos2d_CCNotificationObserver_getName(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?getObject@CCNotificationObserver@cocos2d@@UAEPAVCCObject@2@XZ"]
    pub fn cocos2d_CCNotificationObserver_getObject(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?getHandler@CCNotificationObserver@cocos2d@@UAEHXZ"]
    pub fn cocos2d_CCNotificationObserver_getHandler(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setHandler@CCNotificationObserver@cocos2d@@UAEXH@Z"]
    pub fn cocos2d_CCNotificationObserver_setHandler(
        this: *mut ::std::os::raw::c_void,
        var: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Calculates distance between point an origin\n@return float\n@since v0.7.2"]
    #[link_name = "\u{1}?ccpLength@cocos2d@@YAMABVCCPoint@1@@Z"]
    pub fn cocos2d_ccpLength(v: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Calculates the distance between two points\n@return float\n@since v0.7.2"]
    #[link_name = "\u{1}?ccpDistance@cocos2d@@YAMABVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpDistance(v1: *const cocos2d_CCPoint, v2: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Returns point multiplied to a length of 1.\n@return CCPoint\n@since v0.7.2"]
    #[link_name = "\u{1}?ccpNormalize@cocos2d@@YA?AVCCPoint@1@ABV21@@Z"]
    pub fn cocos2d_ccpNormalize(v: *const cocos2d_CCPoint) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts radians to a normalized vector.\n@return CCPoint\n@since v0.7.2"]
    #[link_name = "\u{1}?ccpForAngle@cocos2d@@YA?AVCCPoint@1@M@Z"]
    pub fn cocos2d_ccpForAngle(a: f32) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Converts a vector to radians.\n@return float\n@since v0.7.2"]
    #[link_name = "\u{1}?ccpToAngle@cocos2d@@YAMABVCCPoint@1@@Z"]
    pub fn cocos2d_ccpToAngle(v: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Clamp a value between from and to.\n@since v0.99.1"]
    #[link_name = "\u{1}?clampf@cocos2d@@YAMMMM@Z"]
    pub fn cocos2d_clampf(value: f32, min_inclusive: f32, max_inclusive: f32) -> f32;
}
extern "C" {
    #[doc = " Clamp a point between from and to.\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpClamp@cocos2d@@YA?AVCCPoint@1@ABV21@00@Z"]
    pub fn cocos2d_ccpClamp(
        p: *const cocos2d_CCPoint,
        from: *const cocos2d_CCPoint,
        to: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Quickly convert CCSize to a CCPoint\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpFromSize@cocos2d@@YA?AVCCPoint@1@ABVCCSize@1@@Z"]
    pub fn cocos2d_ccpFromSize(s: *const cocos2d_CCSize) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Run a math operation function on each point component\n absf, fllorf, ceilf, roundf\n any function that has the signature: float func(float);\n For example: let's try to take the floor of x,y\n ccpCompOp(p,floorf);\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpCompOp@cocos2d@@YA?AVCCPoint@1@ABV21@P6AMM@Z@Z"]
    pub fn cocos2d_ccpCompOp(
        p: *const cocos2d_CCPoint,
        opFunc: ::std::option::Option<unsafe extern "C" fn(arg1: f32) -> f32>,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " Linear Interpolation between two points a and b\n@returns\nalpha == 0 ? a\nalpha == 1 ? b\notherwise a value between a..b\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpLerp@cocos2d@@YA?AVCCPoint@1@ABV21@0M@Z"]
    pub fn cocos2d_ccpLerp(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
        alpha: f32,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " @returns if points have fuzzy equality which means equal with some degree of variance.\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpFuzzyEqual@cocos2d@@YA_NABVCCPoint@1@0M@Z"]
    pub fn cocos2d_ccpFuzzyEqual(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
        variance: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Multiplies a and b components, a.x*b.x, a.y*b.y\n@returns a component-wise multiplication\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpCompMult@cocos2d@@YA?AVCCPoint@1@ABV21@0@Z"]
    pub fn cocos2d_ccpCompMult(
        a: *const cocos2d_CCPoint,
        b: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " @returns the signed angle in radians between two vector directions\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpAngleSigned@cocos2d@@YAMABVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpAngleSigned(a: *const cocos2d_CCPoint, b: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " @returns the angle in radians between two vector directions\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpAngle@cocos2d@@YAMABVCCPoint@1@0@Z"]
    pub fn cocos2d_ccpAngle(a: *const cocos2d_CCPoint, b: *const cocos2d_CCPoint) -> f32;
}
extern "C" {
    #[doc = " Rotates a point counter clockwise by the angle around a pivot\n@param v is the point to rotate\n@param pivot is the pivot, naturally\n@param angle is the angle of rotation cw in radians\n@returns the rotated point\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpRotateByAngle@cocos2d@@YA?AVCCPoint@1@ABV21@0M@Z"]
    pub fn cocos2d_ccpRotateByAngle(
        v: *const cocos2d_CCPoint,
        pivot: *const cocos2d_CCPoint,
        angle: f32,
    ) -> cocos2d_CCPoint;
}
extern "C" {
    #[doc = " A general line-line intersection test\n@param p1\nis the startpoint for the first line P1 = (p1 - p2)\n@param p2\nis the endpoint for the first line P1 = (p1 - p2)\n@param p3\nis the startpoint for the second line P2 = (p3 - p4)\n@param p4\nis the endpoint for the second line P2 = (p3 - p4)\n@param s\nis the range for a hitpoint in P1 (pa = p1 + s*(p2 - p1))\n@param t\nis the range for a hitpoint in P3 (pa = p2 + t*(p4 - p3))\n@return bool\nindicating successful intersection of a line\nnote that to truly test intersection for segments we have to make\nsure that s & t lie within [0..1] and for rays, make sure s & t > 0\nthe hit point is        p3 + t * (p4 - p3);\nthe hit point also is    p1 + s * (p2 - p1);\n@since v0.99.1"]
    #[link_name = "\u{1}?ccpLineIntersect@cocos2d@@YA_NABVCCPoint@1@000PAM1@Z"]
    pub fn cocos2d_ccpLineIntersect(
        p1: *const cocos2d_CCPoint,
        p2: *const cocos2d_CCPoint,
        p3: *const cocos2d_CCPoint,
        p4: *const cocos2d_CCPoint,
        s: *mut f32,
        t: *mut f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccpSegmentIntersect@cocos2d@@YA_NABVCCPoint@1@000@Z"]
    pub fn cocos2d_ccpSegmentIntersect(
        A: *const cocos2d_CCPoint,
        B: *const cocos2d_CCPoint,
        C: *const cocos2d_CCPoint,
        D: *const cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ccpIntersectPoint@cocos2d@@YA?AVCCPoint@1@ABV21@000@Z"]
    pub fn cocos2d_ccpIntersectPoint(
        A: *const cocos2d_CCPoint,
        B: *const cocos2d_CCPoint,
        C: *const cocos2d_CCPoint,
        D: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
#[doc = " CCProfiler\ncocos2d builtin profiler.\n\nTo use it, enable set the CC_ENABLE_PROFILERS=1 in the ccConfig.h file\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProfiler {
    pub _base: cocos2d_CCObject,
    pub m_pActiveTimers: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProfiler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCProfiler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProfiler>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCProfiler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProfiler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProfiler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pActiveTimers) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfiler),
            "::",
            stringify!(m_pActiveTimers)
        )
    );
}
extern "thiscall" {
    #[doc = " display the timers"]
    #[link_name = "\u{1}?displayTimers@CCProfiler@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCProfiler_displayTimers(this: *mut cocos2d_CCProfiler);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCProfiler@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCProfiler_init(this: *mut cocos2d_CCProfiler) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?sharedProfiler@CCProfiler@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCProfiler_sharedProfiler() -> *mut cocos2d_CCProfiler;
}
extern "thiscall" {
    #[doc = " Creates and adds a new timer"]
    #[link_name = "\u{1}?createAndAddTimerWithName@CCProfiler@cocos2d@@QAEPAVCCProfilingTimer@2@PBD@Z"]
    pub fn cocos2d_CCProfiler_createAndAddTimerWithName(
        this: *mut cocos2d_CCProfiler,
        timerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCProfilingTimer;
}
extern "thiscall" {
    #[doc = " releases a timer"]
    #[link_name = "\u{1}?releaseTimer@CCProfiler@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCProfiler_releaseTimer(
        this: *mut cocos2d_CCProfiler,
        timerName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " releases all timers"]
    #[link_name = "\u{1}?releaseAllTimers@CCProfiler@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCProfiler_releaseAllTimers(this: *mut cocos2d_CCProfiler);
}
impl cocos2d_CCProfiler {
    #[inline]
    pub unsafe fn displayTimers(&mut self) {
        cocos2d_CCProfiler_displayTimers(self)
    }
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCProfiler_init(self)
    }
    #[inline]
    pub unsafe fn sharedProfiler() -> *mut cocos2d_CCProfiler {
        cocos2d_CCProfiler_sharedProfiler()
    }
    #[inline]
    pub unsafe fn createAndAddTimerWithName(
        &mut self,
        timerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCProfilingTimer {
        cocos2d_CCProfiler_createAndAddTimerWithName(self, timerName)
    }
    #[inline]
    pub unsafe fn releaseTimer(&mut self, timerName: *const ::std::os::raw::c_char) {
        cocos2d_CCProfiler_releaseTimer(self, timerName)
    }
    #[inline]
    pub unsafe fn releaseAllTimers(&mut self) {
        cocos2d_CCProfiler_releaseAllTimers(self)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCProfiler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCProfiler_CCProfiler_destructor(this: *mut cocos2d_CCProfiler);
}
#[doc = " @addtogroup global\n @{"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCProfilingTimer {
    pub _base: cocos2d_CCObject,
    pub m_NameStr: std_string,
    pub numberOfCalls: ::std::os::raw::c_int,
    pub m_dAverageTime1: ::std::os::raw::c_int,
    pub m_dAverageTime2: ::std::os::raw::c_int,
    pub totalTime: ::std::os::raw::c_longlong,
    pub minTime: ::std::os::raw::c_int,
    pub maxTime: ::std::os::raw::c_int,
    pub m_sStartTime: cocos2d_cc_timeval,
}
#[test]
fn bindgen_test_layout_cocos2d_CCProfilingTimer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCProfilingTimer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCProfilingTimer>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCProfilingTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCProfilingTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cocos2d_CCProfilingTimer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_NameStr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_NameStr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numberOfCalls) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(numberOfCalls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dAverageTime1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_dAverageTime1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dAverageTime2) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_dAverageTime2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalTime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(totalTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minTime) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(minTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTime) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(maxTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sStartTime) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCProfilingTimer),
            "::",
            stringify!(m_sStartTime)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?initWithName@CCProfilingTimer@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCProfilingTimer_initWithName(
        this: *mut cocos2d_CCProfilingTimer,
        timerName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?description@CCProfilingTimer@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCProfilingTimer_description(
        this: *mut cocos2d_CCProfilingTimer,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = " resets the timer properties"]
    #[link_name = "\u{1}?reset@CCProfilingTimer@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCProfilingTimer_reset(this: *mut cocos2d_CCProfilingTimer);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCProfilingTimer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCProfilingTimer_CCProfilingTimer(this: *mut cocos2d_CCProfilingTimer);
}
impl cocos2d_CCProfilingTimer {
    #[inline]
    pub unsafe fn initWithName(&mut self, timerName: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCProfilingTimer_initWithName(self, timerName)
    }
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCProfilingTimer_description(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        cocos2d_CCProfilingTimer_reset(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCProfilingTimer_CCProfilingTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCProfilingTimer@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCProfilingTimer_CCProfilingTimer_destructor(
        this: *mut cocos2d_CCProfilingTimer,
    );
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingBeginTimingBlock@cocos2d@@YAXPBD@Z"]
    pub fn cocos2d_CCProfilingBeginTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingEndTimingBlock@cocos2d@@YAXPBD@Z"]
    pub fn cocos2d_CCProfilingEndTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?CCProfilingResetTimingBlock@cocos2d@@YAXPBD@Z"]
    pub fn cocos2d_CCProfilingResetTimingBlock(timerName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategorySprite@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategorySprite: bool;
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategoryBatchSprite@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategoryBatchSprite: bool;
}
extern "C" {
    #[link_name = "\u{1}?kCCProfilerCategoryParticles@cocos2d@@3_NA"]
    pub static mut cocos2d_kCCProfilerCategoryParticles: bool;
}
#[doc = " CCUserDefault acts as a tiny database. You can save and get base type values by it.\n For example, setBoolForKey(\"played\", true) will add a bool value true into the database.\n Its key is \"played\". You can get the value of the key by getBoolForKey(\"played\").\n\n It supports the following base types:\n bool, int, float, double, string"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCUserDefault {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}?m_spUserDefault@CCUserDefault@cocos2d@@0PAV12@A"]
    pub static mut cocos2d_CCUserDefault_m_spUserDefault: *mut cocos2d_CCUserDefault;
}
extern "C" {
    #[link_name = "\u{1}?m_sFilePath@CCUserDefault@cocos2d@@0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A"]
    pub static mut cocos2d_CCUserDefault_m_sFilePath: std_string;
}
extern "C" {
    #[link_name = "\u{1}?m_sbIsFilePathInitialized@CCUserDefault@cocos2d@@0_NA"]
    pub static mut cocos2d_CCUserDefault_m_sbIsFilePathInitialized: bool;
}
#[test]
fn bindgen_test_layout_cocos2d_CCUserDefault() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCUserDefault>(),
        1usize,
        concat!("Size of: ", stringify!(cocos2d_CCUserDefault))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCUserDefault>(),
        1usize,
        concat!("Alignment of ", stringify!(cocos2d_CCUserDefault))
    );
}
extern "thiscall" {
    #[doc = "@brief Get bool value by key, if the key doesn't exist, a default value will return.\nYou can set the default value, or it is false."]
    #[link_name = "\u{1}?getBoolForKey@CCUserDefault@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCUserDefault_getBoolForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getBoolForKey@CCUserDefault@cocos2d@@QAE_NPBD_N@Z"]
    pub fn cocos2d_CCUserDefault_getBoolForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief Get integer value by key, if the key doesn't exist, a default value will return.\nYou can set the default value, or it is 0."]
    #[link_name = "\u{1}?getIntegerForKey@CCUserDefault@cocos2d@@QAEHPBD@Z"]
    pub fn cocos2d_CCUserDefault_getIntegerForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?getIntegerForKey@CCUserDefault@cocos2d@@QAEHPBDH@Z"]
    pub fn cocos2d_CCUserDefault_getIntegerForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[doc = "@brief Get float value by key, if the key doesn't exist, a default value will return.\nYou can set the default value, or it is 0.0f."]
    #[link_name = "\u{1}?getFloatForKey@CCUserDefault@cocos2d@@QAEMPBD@Z"]
    pub fn cocos2d_CCUserDefault_getFloatForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?getFloatForKey@CCUserDefault@cocos2d@@QAEMPBDM@Z"]
    pub fn cocos2d_CCUserDefault_getFloatForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f32,
    ) -> f32;
}
extern "thiscall" {
    #[doc = "@brief Get double value by key, if the key doesn't exist, a default value will return.\nYou can set the default value, or it is 0.0."]
    #[link_name = "\u{1}?getDoubleForKey@CCUserDefault@cocos2d@@QAENPBD@Z"]
    pub fn cocos2d_CCUserDefault_getDoubleForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDoubleForKey@CCUserDefault@cocos2d@@QAENPBDN@Z"]
    pub fn cocos2d_CCUserDefault_getDoubleForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64;
}
extern "thiscall" {
    #[doc = "@brief Get string value by key, if the key doesn't exist, a default value will return.\nYou can set the default value, or it is \"\"."]
    #[link_name = "\u{1}?getStringForKey@CCUserDefault@cocos2d@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z"]
    pub fn cocos2d_CCUserDefault_getStringForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?getStringForKey@CCUserDefault@cocos2d@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDABV34@@Z"]
    pub fn cocos2d_CCUserDefault_getStringForKey1(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: *const std_string,
    ) -> std_string;
}
extern "thiscall" {
    #[doc = "@brief Set bool value by key."]
    #[link_name = "\u{1}?setBoolForKey@CCUserDefault@cocos2d@@QAEXPBD_N@Z"]
    pub fn cocos2d_CCUserDefault_setBoolForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: bool,
    );
}
extern "thiscall" {
    #[doc = "@brief Set integer value by key."]
    #[link_name = "\u{1}?setIntegerForKey@CCUserDefault@cocos2d@@QAEXPBDH@Z"]
    pub fn cocos2d_CCUserDefault_setIntegerForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = "@brief Set float value by key."]
    #[link_name = "\u{1}?setFloatForKey@CCUserDefault@cocos2d@@QAEXPBDM@Z"]
    pub fn cocos2d_CCUserDefault_setFloatForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: f32,
    );
}
extern "thiscall" {
    #[doc = "@brief Set double value by key."]
    #[link_name = "\u{1}?setDoubleForKey@CCUserDefault@cocos2d@@QAEXPBDN@Z"]
    pub fn cocos2d_CCUserDefault_setDoubleForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: f64,
    );
}
extern "thiscall" {
    #[doc = "@brief Set string value by key."]
    #[link_name = "\u{1}?setStringForKey@CCUserDefault@cocos2d@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn cocos2d_CCUserDefault_setStringForKey(
        this: *mut cocos2d_CCUserDefault,
        pKey: *const ::std::os::raw::c_char,
        value: *const std_string,
    );
}
extern "thiscall" {
    #[doc = "@brief Save content to xml file"]
    #[link_name = "\u{1}?flush@CCUserDefault@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCUserDefault_flush(this: *mut cocos2d_CCUserDefault);
}
extern "C" {
    #[link_name = "\u{1}?sharedUserDefault@CCUserDefault@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCUserDefault_sharedUserDefault() -> *mut cocos2d_CCUserDefault;
}
extern "C" {
    #[link_name = "\u{1}?purgeSharedUserDefault@CCUserDefault@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCUserDefault_purgeSharedUserDefault();
}
extern "C" {
    #[link_name = "\u{1}?getXMLFilePath@CCUserDefault@cocos2d@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn cocos2d_CCUserDefault_getXMLFilePath() -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}?isXMLFileExist@CCUserDefault@cocos2d@@SA_NXZ"]
    pub fn cocos2d_CCUserDefault_isXMLFileExist() -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCUserDefault@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCUserDefault_CCUserDefault_destructor(this: *mut cocos2d_CCUserDefault);
}
impl cocos2d_CCUserDefault {
    #[inline]
    pub unsafe fn getBoolForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCUserDefault_getBoolForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getBoolForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: bool,
    ) -> bool {
        cocos2d_CCUserDefault_getBoolForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getIntegerForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCUserDefault_getIntegerForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getIntegerForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        cocos2d_CCUserDefault_getIntegerForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getFloatForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> f32 {
        cocos2d_CCUserDefault_getFloatForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getFloatForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f32,
    ) -> f32 {
        cocos2d_CCUserDefault_getFloatForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getDoubleForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> f64 {
        cocos2d_CCUserDefault_getDoubleForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getDoubleForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: f64,
    ) -> f64 {
        cocos2d_CCUserDefault_getDoubleForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn getStringForKey(&mut self, pKey: *const ::std::os::raw::c_char) -> std_string {
        cocos2d_CCUserDefault_getStringForKey(self, pKey)
    }
    #[inline]
    pub unsafe fn getStringForKey1(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        defaultValue: *const std_string,
    ) -> std_string {
        cocos2d_CCUserDefault_getStringForKey1(self, pKey, defaultValue)
    }
    #[inline]
    pub unsafe fn setBoolForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: bool) {
        cocos2d_CCUserDefault_setBoolForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setIntegerForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) {
        cocos2d_CCUserDefault_setIntegerForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setFloatForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: f32) {
        cocos2d_CCUserDefault_setFloatForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setDoubleForKey(&mut self, pKey: *const ::std::os::raw::c_char, value: f64) {
        cocos2d_CCUserDefault_setDoubleForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn setStringForKey(
        &mut self,
        pKey: *const ::std::os::raw::c_char,
        value: *const std_string,
    ) {
        cocos2d_CCUserDefault_setStringForKey(self, pKey, value)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        cocos2d_CCUserDefault_flush(self)
    }
    #[inline]
    pub unsafe fn sharedUserDefault() -> *mut cocos2d_CCUserDefault {
        cocos2d_CCUserDefault_sharedUserDefault()
    }
    #[inline]
    pub unsafe fn purgeSharedUserDefault() {
        cocos2d_CCUserDefault_purgeSharedUserDefault()
    }
    #[inline]
    pub unsafe fn getXMLFilePath() -> *const std_string {
        cocos2d_CCUserDefault_getXMLFilePath()
    }
    #[inline]
    pub unsafe fn isXMLFileExist() -> bool {
        cocos2d_CCUserDefault_isXMLFileExist()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCUserDefault_CCUserDefault_destructor(self)
    }
}
extern "C" {
    #[doc = " converts a line to a polygon"]
    #[link_name = "\u{1}?ccVertexLineToPolygon@cocos2d@@YAXPAVCCPoint@1@MPAU_ccVertex2F@1@II@Z"]
    pub fn cocos2d_ccVertexLineToPolygon(
        points: *mut cocos2d_CCPoint,
        stroke: f32,
        vertices: *mut cocos2d_ccVertex2F,
        offset: ::std::os::raw::c_uint,
        nuPoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " returns whether or not the line intersects"]
    #[link_name = "\u{1}?ccVertexLineIntersect@cocos2d@@YA_NMMMMMMMMPAM@Z"]
    pub fn cocos2d_ccVertexLineIntersect(
        Ax: f32,
        Ay: f32,
        Bx: f32,
        By: f32,
        Cx: f32,
        Cy: f32,
        Dx: f32,
        Dy: f32,
        T: *mut f32,
    ) -> bool;
}
#[doc = " @addtogroup input\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCIMEKeyboardNotificationInfo {
    pub begin: cocos2d_CCRect,
    pub end: cocos2d_CCRect,
    pub duration: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEKeyboardNotificationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCIMEKeyboardNotificationInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEKeyboardNotificationInfo>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEKeyboardNotificationInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEKeyboardNotificationInfo),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
pub struct cocos2d_CCIMEDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = "@brief    Input method editor delegate.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCIMEDelegate {
    pub vtable_: *const cocos2d_CCIMEDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCIMEDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCIMEDelegate))
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCIMEDelegate@cocos2d@@IAE@XZ"]
    pub fn cocos2d_CCIMEDelegate_CCIMEDelegate(this: *mut cocos2d_CCIMEDelegate);
}
impl cocos2d_CCIMEDelegate {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCIMEDelegate_CCIMEDelegate(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCIMEDelegate@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCIMEDelegate_CCIMEDelegate_destructor(this: *mut cocos2d_CCIMEDelegate);
}
extern "thiscall" {
    #[link_name = "\u{1}?attachWithIME@CCIMEDelegate@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCIMEDelegate_attachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?detachWithIME@CCIMEDelegate@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCIMEDelegate_detachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
#[doc = "@brief    Input Method Edit Message Dispatcher.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCIMEDispatcher {
    pub m_pImpl: *mut cocos2d_CCIMEDispatcher_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCIMEDispatcher_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_cocos2d_CCIMEDispatcher() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCIMEDispatcher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCIMEDispatcher>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCIMEDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCIMEDispatcher>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCIMEDispatcher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pImpl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCIMEDispatcher),
            "::",
            stringify!(m_pImpl)
        )
    );
}
extern "C" {
    #[doc = "@brief Returns the shared CCIMEDispatcher object for the system."]
    #[link_name = "\u{1}?sharedDispatcher@CCIMEDispatcher@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCIMEDispatcher_sharedDispatcher() -> *mut cocos2d_CCIMEDispatcher;
}
extern "thiscall" {
    #[doc = "@brief Dispatches the input text from IME."]
    #[link_name = "\u{1}?dispatchInsertText@CCIMEDispatcher@cocos2d@@QAEXPBDHW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchInsertText(
        this: *mut cocos2d_CCIMEDispatcher,
        pText: *const ::std::os::raw::c_char,
        nLen: ::std::os::raw::c_int,
        keyCode: cocos2d_enumKeyCodes,
    );
}
extern "thiscall" {
    #[doc = "@brief Dispatches the delete-backward operation."]
    #[link_name = "\u{1}?dispatchDeleteBackward@CCIMEDispatcher@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCIMEDispatcher_dispatchDeleteBackward(this: *mut cocos2d_CCIMEDispatcher);
}
extern "thiscall" {
    #[doc = "@brief Get the content text from CCIMEDelegate, retrieved previously from IME."]
    #[link_name = "\u{1}?getContentText@CCIMEDispatcher@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCIMEDispatcher_getContentText(
        this: *mut cocos2d_CCIMEDispatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchKeyboardWillShow@CCIMEDispatcher@cocos2d@@QAEXAAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardWillShow(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchKeyboardDidShow@CCIMEDispatcher@cocos2d@@QAEXAAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardDidShow(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchKeyboardWillHide@CCIMEDispatcher@cocos2d@@QAEXAAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardWillHide(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchKeyboardDidHide@CCIMEDispatcher@cocos2d@@QAEXAAUCCIMEKeyboardNotificationInfo@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_dispatchKeyboardDidHide(
        this: *mut cocos2d_CCIMEDispatcher,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    );
}
extern "thiscall" {
    #[doc = "@brief Add delegate to receive IME messages."]
    #[link_name = "\u{1}?addDelegate@CCIMEDispatcher@cocos2d@@IAEXPAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_addDelegate(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    );
}
extern "thiscall" {
    #[doc = "@brief Attach the pDelegate to the IME.\n@return If the old delegate can detach from the IME, and the new delegate\ncan attach to the IME, return true, otherwise false."]
    #[link_name = "\u{1}?attachDelegateWithIME@CCIMEDispatcher@cocos2d@@IAE_NPAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_attachDelegateWithIME(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?detachDelegateWithIME@CCIMEDispatcher@cocos2d@@IAE_NPAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_detachDelegateWithIME(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "@brief Remove the delegate from the delegates which receive IME messages."]
    #[link_name = "\u{1}?removeDelegate@CCIMEDispatcher@cocos2d@@IAEXPAVCCIMEDelegate@2@@Z"]
    pub fn cocos2d_CCIMEDispatcher_removeDelegate(
        this: *mut cocos2d_CCIMEDispatcher,
        pDelegate: *mut cocos2d_CCIMEDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCIMEDispatcher@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCIMEDispatcher_CCIMEDispatcher_destructor(this: *mut cocos2d_CCIMEDispatcher);
}
impl cocos2d_CCIMEDispatcher {
    #[inline]
    pub unsafe fn sharedDispatcher() -> *mut cocos2d_CCIMEDispatcher {
        cocos2d_CCIMEDispatcher_sharedDispatcher()
    }
    #[inline]
    pub unsafe fn dispatchInsertText(
        &mut self,
        pText: *const ::std::os::raw::c_char,
        nLen: ::std::os::raw::c_int,
        keyCode: cocos2d_enumKeyCodes,
    ) {
        cocos2d_CCIMEDispatcher_dispatchInsertText(self, pText, nLen, keyCode)
    }
    #[inline]
    pub unsafe fn dispatchDeleteBackward(&mut self) {
        cocos2d_CCIMEDispatcher_dispatchDeleteBackward(self)
    }
    #[inline]
    pub unsafe fn getContentText(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCIMEDispatcher_getContentText(self)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardWillShow(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardWillShow(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardDidShow(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardDidShow(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardWillHide(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardWillHide(self, info)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardDidHide(
        &mut self,
        info: *mut cocos2d_CCIMEKeyboardNotificationInfo,
    ) {
        cocos2d_CCIMEDispatcher_dispatchKeyboardDidHide(self, info)
    }
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) {
        cocos2d_CCIMEDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn attachDelegateWithIME(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) -> bool {
        cocos2d_CCIMEDispatcher_attachDelegateWithIME(self, pDelegate)
    }
    #[inline]
    pub unsafe fn detachDelegateWithIME(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) -> bool {
        cocos2d_CCIMEDispatcher_detachDelegateWithIME(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCIMEDelegate) {
        cocos2d_CCIMEDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        cocos2d_CCIMEDispatcher_CCIMEDispatcher_destructor(self)
    }
}
#[repr(C)]
pub struct cocos2d_CCTextFieldDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @addtogroup input\n @{\n @js NA\n @lua NA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextFieldDelegate {
    pub vtable_: *const cocos2d_CCTextFieldDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextFieldDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextFieldDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextFieldDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextFieldDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextFieldDelegate))
    );
}
#[doc = "@brief    A simple text input field with TTF font.\n@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextFieldTTF {
    pub _base: cocos2d_CCLabelTTF,
    pub _base_1: cocos2d_CCIMEDelegate,
    pub m_pDelegate: *mut cocos2d_CCTextFieldDelegate,
    pub m_nCharCount: ::std::os::raw::c_int,
    pub m_pInputText: *mut std_string,
    pub m_pPlaceHolder: *mut std_string,
    pub m_ColorSpaceHolder: cocos2d_ccColor3B,
    pub m_bSecureTextEntry: bool,
    pub m_pLens: *mut cocos2d_CCTextFieldTTF_LengthStack,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCTextFieldTTF_LengthStack {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextFieldTTF() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTextFieldTTF> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextFieldTTF>(),
        624usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextFieldTTF))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextFieldTTF>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextFieldTTF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_pDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nCharCount) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_nCharCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pInputText) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_pInputText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPlaceHolder) as usize - ptr as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_pPlaceHolder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ColorSpaceHolder) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_ColorSpaceHolder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSecureTextEntry) as usize - ptr as usize },
        619usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_bSecureTextEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLens) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextFieldTTF),
            "::",
            stringify!(m_pLens)
        )
    );
}
extern "C" {
    #[doc = " creates a CCTextFieldTTF from a fontname, alignment, dimension and font size"]
    #[link_name = "\u{1}?textFieldWithPlaceHolder@CCTextFieldTTF@cocos2d@@SAPAV12@PBDABVCCSize@2@W4CCTextAlignment@2@0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder(
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF;
}
extern "C" {
    #[doc = " creates a CCLabelTTF from a fontname and font size"]
    #[link_name = "\u{1}?textFieldWithPlaceHolder@CCTextFieldTTF@cocos2d@@SAPAV12@PBD0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder1(
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF;
}
extern "thiscall" {
    #[doc = " initializes the CCTextFieldTTF with a font name, alignment, dimension and font size"]
    #[link_name = "\u{1}?initWithPlaceHolder@CCTextFieldTTF@cocos2d@@QAE_NPBDABVCCSize@2@W4CCTextAlignment@2@0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_initWithPlaceHolder(
        this: *mut cocos2d_CCTextFieldTTF,
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes the CCTextFieldTTF with a font name and font size"]
    #[link_name = "\u{1}?initWithPlaceHolder@CCTextFieldTTF@cocos2d@@QAE_NPBD0M@Z"]
    pub fn cocos2d_CCTextFieldTTF_initWithPlaceHolder1(
        this: *mut cocos2d_CCTextFieldTTF,
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??0CCTextFieldTTF@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTextFieldTTF_CCTextFieldTTF(this: *mut cocos2d_CCTextFieldTTF);
}
impl cocos2d_CCTextFieldTTF {
    #[inline]
    pub unsafe fn textFieldWithPlaceHolder(
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF {
        cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder(
            placeholder,
            dimensions,
            alignment,
            fontName,
            fontSize,
        )
    }
    #[inline]
    pub unsafe fn textFieldWithPlaceHolder1(
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> *mut cocos2d_CCTextFieldTTF {
        cocos2d_CCTextFieldTTF_textFieldWithPlaceHolder1(placeholder, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn initWithPlaceHolder(
        &mut self,
        placeholder: *const ::std::os::raw::c_char,
        dimensions: *const cocos2d_CCSize,
        alignment: cocos2d_CCTextAlignment,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTextFieldTTF_initWithPlaceHolder(
            self,
            placeholder,
            dimensions,
            alignment,
            fontName,
            fontSize,
        )
    }
    #[inline]
    pub unsafe fn initWithPlaceHolder1(
        &mut self,
        placeholder: *const ::std::os::raw::c_char,
        fontName: *const ::std::os::raw::c_char,
        fontSize: f32,
    ) -> bool {
        cocos2d_CCTextFieldTTF_initWithPlaceHolder1(self, placeholder, fontName, fontSize)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextFieldTTF_CCTextFieldTTF(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}??1CCTextFieldTTF@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTextFieldTTF_CCTextFieldTTF_destructor(this: *mut cocos2d_CCTextFieldTTF);
}
extern "thiscall" {
    #[doc = "@brief    Open keyboard and receive input text."]
    #[link_name = "\u{1}?attachWithIME@CCTextFieldTTF@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_attachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "@brief    End text input and close keyboard."]
    #[link_name = "\u{1}?detachWithIME@CCTextFieldTTF@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_detachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getColorSpaceHolder@CCTextFieldTTF@cocos2d@@UAEABU_ccColor3B@2@XZ"]
    pub fn cocos2d_CCTextFieldTTF_getColorSpaceHolder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const cocos2d_ccColor3B;
}
extern "thiscall" {
    #[link_name = "\u{1}?setColorSpaceHolder@CCTextFieldTTF@cocos2d@@UAEXABU_ccColor3B@2@@Z"]
    pub fn cocos2d_CCTextFieldTTF_setColorSpaceHolder(
        this: *mut ::std::os::raw::c_void,
        color: *const cocos2d_ccColor3B,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setString@CCTextFieldTTF@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCTextFieldTTF_setString(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getString@CCTextFieldTTF@cocos2d@@UAEPBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getString(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setPlaceHolder@CCTextFieldTTF@cocos2d@@UAEXPBD@Z"]
    pub fn cocos2d_CCTextFieldTTF_setPlaceHolder(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getPlaceHolder@CCTextFieldTTF@cocos2d@@UAEPBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getPlaceHolder(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSecureTextEntry@CCTextFieldTTF@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCTextFieldTTF_setSecureTextEntry(
        this: *mut ::std::os::raw::c_void,
        value: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isSecureTextEntry@CCTextFieldTTF@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_isSecureTextEntry(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?draw@CCTextFieldTTF@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTextFieldTTF_draw(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?canAttachWithIME@CCTextFieldTTF@cocos2d@@MAE_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_canAttachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?canDetachWithIME@CCTextFieldTTF@cocos2d@@MAE_NXZ"]
    pub fn cocos2d_CCTextFieldTTF_canDetachWithIME(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?insertText@CCTextFieldTTF@cocos2d@@MAEXPBDHW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCTextFieldTTF_insertText(
        this: *mut ::std::os::raw::c_void,
        text: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        keyCode: cocos2d_enumKeyCodes,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?deleteBackward@CCTextFieldTTF@cocos2d@@MAEXXZ"]
    pub fn cocos2d_CCTextFieldTTF_deleteBackward(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?getContentText@CCTextFieldTTF@cocos2d@@MAEPBDXZ"]
    pub fn cocos2d_CCTextFieldTTF_getContentText(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCLock {
    _unused: [u8; 0],
}
#[doc = " @brief Singleton that handles the loading of textures\n Once the texture is loaded, the next time it will return\n a reference of the previously loaded texture reducing GPU & CPU memory"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTextureCache {
    pub _base: cocos2d_CCObject,
    pub m_pTextures: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTextureCache() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTextureCache> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTextureCache>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCTextureCache))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTextureCache>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTextureCache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTextures) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTextureCache),
            "::",
            stringify!(m_pTextures)
        )
    );
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?description@CCTextureCache@cocos2d@@QAEPBDXZ"]
    pub fn cocos2d_CCTextureCache_description(
        this: *mut cocos2d_CCTextureCache,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?snapshotTextures@CCTextureCache@cocos2d@@QAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTextureCache_snapshotTextures(
        this: *mut cocos2d_CCTextureCache,
    ) -> *mut cocos2d_CCDictionary;
}
extern "C" {
    #[doc = " Returns the shared instance of the cache\n  @js getInstance"]
    #[link_name = "\u{1}?sharedTextureCache@CCTextureCache@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCTextureCache_sharedTextureCache() -> *mut cocos2d_CCTextureCache;
}
extern "C" {
    #[doc = " purges the cache. It releases the retained instance.\n@since v0.99.0"]
    #[link_name = "\u{1}?purgeSharedTextureCache@CCTextureCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCTextureCache_purgeSharedTextureCache();
}
extern "thiscall" {
    #[link_name = "\u{1}?addImage@CCTextureCache@cocos2d@@QAEPAVCCTexture2D@2@PBD_N@Z"]
    pub fn cocos2d_CCTextureCache_addImage(
        this: *mut cocos2d_CCTextureCache,
        fileimage: *const ::std::os::raw::c_char,
        arg1: bool,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[link_name = "\u{1}?addImageAsync@CCTextureCache@cocos2d@@QAEXPBDPAVCCObject@2@P832@AEX1@Z@Z"]
    pub fn cocos2d_CCTextureCache_addImageAsync(
        this: *mut cocos2d_CCTextureCache,
        path: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
    );
}
extern "thiscall" {
    #[doc = " Returns a Texture2D object given an UIImage image\n If the image was not previously loaded, it will create a new CCTexture2D object and it will return it.\n Otherwise it will return a reference of a previously loaded image\n The \"key\" parameter will be used as the \"key\" for the cache.\n If \"key\" is nil, then a new texture will be created each time."]
    #[link_name = "\u{1}?addUIImage@CCTextureCache@cocos2d@@QAEPAVCCTexture2D@2@PAVCCImage@2@PBD@Z"]
    pub fn cocos2d_CCTextureCache_addUIImage(
        this: *mut cocos2d_CCTextureCache,
        image: *mut cocos2d_CCImage,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " Returns an already created texture. Returns nil if the texture doesn't exist.\n@since v0.99.5"]
    #[link_name = "\u{1}?textureForKey@CCTextureCache@cocos2d@@QAEPAVCCTexture2D@2@PBD@Z"]
    pub fn cocos2d_CCTextureCache_textureForKey(
        this: *mut cocos2d_CCTextureCache,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " Reload texture from the image file\n If the file image hasn't loaded before, load it.\n Otherwise the texture will be reloaded from the file image.\n The \"filenName\" parameter is the related/absolute path of the file image.\n Return true if the reloading is succeed, otherwise return false."]
    #[link_name = "\u{1}?reloadTexture@CCTextureCache@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTextureCache_reloadTexture(
        this: *mut cocos2d_CCTextureCache,
        fileName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Purges the dictionary of loaded textures.\n Call this method if you receive the \"Memory Warning\"\n In the short term: it will free some resources preventing your app from being killed\n In the medium term: it will allocate more resources\n In the long term: it will be the same"]
    #[link_name = "\u{1}?removeAllTextures@CCTextureCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTextureCache_removeAllTextures(this: *mut cocos2d_CCTextureCache);
}
extern "thiscall" {
    #[doc = " Removes unused textures\n Textures that have a retain count of 1 will be deleted\n It is convenient to call this method after when starting a new Scene\n @since v0.8"]
    #[link_name = "\u{1}?removeUnusedTextures@CCTextureCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTextureCache_removeUnusedTextures(this: *mut cocos2d_CCTextureCache);
}
extern "thiscall" {
    #[doc = " Deletes a texture from the cache given a texture"]
    #[link_name = "\u{1}?removeTexture@CCTextureCache@cocos2d@@QAEXPAVCCTexture2D@2@@Z"]
    pub fn cocos2d_CCTextureCache_removeTexture(
        this: *mut cocos2d_CCTextureCache,
        texture: *mut cocos2d_CCTexture2D,
    );
}
extern "thiscall" {
    #[doc = " Deletes a texture from the cache given a its key name\n@since v0.99.4"]
    #[link_name = "\u{1}?removeTextureForKey@CCTextureCache@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCTextureCache_removeTextureForKey(
        this: *mut cocos2d_CCTextureCache,
        textureKeyName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " Output to CCLOG the current contents of this CCTextureCache\n This will attempt to calculate the size of each texture, and the total texture memory in use\n\n @since v1.0"]
    #[link_name = "\u{1}?dumpCachedTextureInfo@CCTextureCache@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTextureCache_dumpCachedTextureInfo(this: *mut cocos2d_CCTextureCache);
}
extern "thiscall" {
    #[doc = " Returns a Texture2D object given an PVR filename\n If the file image was not previously loaded, it will create a new CCTexture2D\n  object and it will return it. Otherwise it will return a reference of a previously loaded image"]
    #[link_name = "\u{1}?addPVRImage@CCTextureCache@cocos2d@@QAEPAVCCTexture2D@2@PBD@Z"]
    pub fn cocos2d_CCTextureCache_addPVRImage(
        this: *mut cocos2d_CCTextureCache,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "thiscall" {
    #[doc = " Returns a Texture2D object given an ETC filename\n If the file image was not previously loaded, it will create a new CCTexture2D\n  object and it will return it. Otherwise it will return a reference of a previously loaded image\n  @lua NA"]
    #[link_name = "\u{1}?addETCImage@CCTextureCache@cocos2d@@QAEPAVCCTexture2D@2@PBD@Z"]
    pub fn cocos2d_CCTextureCache_addETCImage(
        this: *mut cocos2d_CCTextureCache,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D;
}
extern "C" {
    #[doc = " Reload all textures\nIt's only useful when the value of CC_ENABLE_CACHE_TEXTURE_DATA is 1"]
    #[link_name = "\u{1}?reloadAllTextures@CCTextureCache@cocos2d@@SAXXZ"]
    pub fn cocos2d_CCTextureCache_reloadAllTextures();
}
extern "thiscall" {
    #[doc = "  @js ctor\n  @lua NA"]
    #[link_name = "\u{1}??0CCTextureCache@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTextureCache_CCTextureCache(this: *mut cocos2d_CCTextureCache);
}
impl cocos2d_CCTextureCache {
    #[inline]
    pub unsafe fn description(&mut self) -> *const ::std::os::raw::c_char {
        cocos2d_CCTextureCache_description(self)
    }
    #[inline]
    pub unsafe fn snapshotTextures(&mut self) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTextureCache_snapshotTextures(self)
    }
    #[inline]
    pub unsafe fn sharedTextureCache() -> *mut cocos2d_CCTextureCache {
        cocos2d_CCTextureCache_sharedTextureCache()
    }
    #[inline]
    pub unsafe fn purgeSharedTextureCache() {
        cocos2d_CCTextureCache_purgeSharedTextureCache()
    }
    #[inline]
    pub unsafe fn addImage(
        &mut self,
        fileimage: *const ::std::os::raw::c_char,
        arg1: bool,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addImage(self, fileimage, arg1)
    }
    #[inline]
    pub unsafe fn addImageAsync(
        &mut self,
        path: *const ::std::os::raw::c_char,
        target: *mut cocos2d_CCObject,
        selector: cocos2d_SEL_CallFuncO,
    ) {
        cocos2d_CCTextureCache_addImageAsync(self, path, target, selector)
    }
    #[inline]
    pub unsafe fn addUIImage(
        &mut self,
        image: *mut cocos2d_CCImage,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addUIImage(self, image, key)
    }
    #[inline]
    pub unsafe fn textureForKey(
        &mut self,
        key: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_textureForKey(self, key)
    }
    #[inline]
    pub unsafe fn reloadTexture(&mut self, fileName: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTextureCache_reloadTexture(self, fileName)
    }
    #[inline]
    pub unsafe fn removeAllTextures(&mut self) {
        cocos2d_CCTextureCache_removeAllTextures(self)
    }
    #[inline]
    pub unsafe fn removeUnusedTextures(&mut self) {
        cocos2d_CCTextureCache_removeUnusedTextures(self)
    }
    #[inline]
    pub unsafe fn removeTexture(&mut self, texture: *mut cocos2d_CCTexture2D) {
        cocos2d_CCTextureCache_removeTexture(self, texture)
    }
    #[inline]
    pub unsafe fn removeTextureForKey(&mut self, textureKeyName: *const ::std::os::raw::c_char) {
        cocos2d_CCTextureCache_removeTextureForKey(self, textureKeyName)
    }
    #[inline]
    pub unsafe fn dumpCachedTextureInfo(&mut self) {
        cocos2d_CCTextureCache_dumpCachedTextureInfo(self)
    }
    #[inline]
    pub unsafe fn addPVRImage(
        &mut self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addPVRImage(self, filename)
    }
    #[inline]
    pub unsafe fn addETCImage(
        &mut self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexture2D {
        cocos2d_CCTextureCache_addETCImage(self, filename)
    }
    #[inline]
    pub unsafe fn reloadAllTextures() {
        cocos2d_CCTextureCache_reloadAllTextures()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTextureCache_CCTextureCache(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCTextureCache@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTextureCache_CCTextureCache_destructor(this: *mut cocos2d_CCTextureCache);
}
#[doc = "@brief Structure which can tell where mipmap begins and how long is it"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCPVRMipmap {
    pub address: *mut ::std::os::raw::c_uchar,
    pub len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCPVRMipmap() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCPVRMipmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCPVRMipmap>(),
        8usize,
        concat!("Size of: ", stringify!(cocos2d_CCPVRMipmap))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCPVRMipmap>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCPVRMipmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPVRMipmap),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCPVRMipmap),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__ccPVRTexturePixelFormatInfo {
    pub internalFormat: GLenum,
    pub format: GLenum,
    pub type_: GLenum,
    pub bpp: u32,
    pub compressed: bool,
    pub alpha: bool,
    pub ccPixelFormat: cocos2d_CCTexture2DPixelFormat,
}
#[test]
fn bindgen_test_layout_cocos2d__ccPVRTexturePixelFormatInfo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d__ccPVRTexturePixelFormatInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d__ccPVRTexturePixelFormatInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d__ccPVRTexturePixelFormatInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internalFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(internalFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(compressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ccPixelFormat) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d__ccPVRTexturePixelFormatInfo),
            "::",
            stringify!(ccPixelFormat)
        )
    );
}
pub type cocos2d_ccPVRTexturePixelFormatInfo = cocos2d__ccPVRTexturePixelFormatInfo;
pub const CC_PVRMIPMAP_MAX: cocos2d__bindgen_ty_12 = 16;
#[doc = "@brief Determine how many mipmaps can we have.\nIts same as define but it respects namespaces"]
pub type cocos2d__bindgen_ty_12 = ::std::os::raw::c_int;
#[doc = " CCTexturePVR\n\nObject that loads PVR images.\n\nSupported PVR formats:\n- RGBA8888\n- BGRA8888\n- RGBA4444\n- RGBA5551\n- RGB565\n- A8\n- I8\n- AI88\n- PVRTC 4BPP\n- PVRTC 2BPP\n\nLimitations:\nPre-generated mipmaps, such as PVR textures with mipmap levels embedded in file,\nare only supported if all individual sprites are of _square_ size.\nTo use mipmaps with non-square textures, instead call CCTexture2D#generateMipmap on the sheet texture itself\n(and to save space, save the PVR sprite sheet without mip maps included).\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTexturePVR {
    pub _base: cocos2d_CCObject,
    pub m_asMipmaps: [cocos2d_CCPVRMipmap; 16usize],
    pub m_uNumberOfMipmaps: ::std::os::raw::c_uint,
    pub m_uWidth: ::std::os::raw::c_uint,
    pub m_uHeight: ::std::os::raw::c_uint,
    pub m_uName: GLuint,
    pub m_bHasAlpha: bool,
    pub m_bHasPremultipliedAlpha: bool,
    pub m_bForcePremultipliedAlpha: bool,
    pub m_bRetainName: bool,
    pub m_eFormat: cocos2d_CCTexture2DPixelFormat,
    pub m_pPixelFormatInfo: *const cocos2d_ccPVRTexturePixelFormatInfo,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTexturePVR() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTexturePVR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTexturePVR>(),
        208usize,
        concat!("Size of: ", stringify!(cocos2d_CCTexturePVR))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTexturePVR>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTexturePVR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_asMipmaps) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_asMipmaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uNumberOfMipmaps) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uNumberOfMipmaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uWidth) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uHeight) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uName) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_uName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasAlpha) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bHasAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bHasPremultipliedAlpha) as usize - ptr as usize },
        197usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bHasPremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bForcePremultipliedAlpha) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bForcePremultipliedAlpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRetainName) as usize - ptr as usize },
        199usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_bRetainName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eFormat) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_eFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPixelFormatInfo) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTexturePVR),
            "::",
            stringify!(m_pPixelFormatInfo)
        )
    );
}
extern "thiscall" {
    #[doc = " initializes a CCTexturePVR with a path"]
    #[link_name = "\u{1}?initWithContentsOfFile@CCTexturePVR@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTexturePVR_initWithContentsOfFile(
        this: *mut cocos2d_CCTexturePVR,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " creates and initializes a CCTexturePVR with a path"]
    #[link_name = "\u{1}?create@CCTexturePVR@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCTexturePVR_create(
        path: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTexturePVR;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCTexturePVR@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTexturePVR_CCTexturePVR(this: *mut cocos2d_CCTexturePVR);
}
impl cocos2d_CCTexturePVR {
    #[inline]
    pub unsafe fn initWithContentsOfFile(&mut self, path: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTexturePVR_initWithContentsOfFile(self, path)
    }
    #[inline]
    pub unsafe fn create(path: *const ::std::os::raw::c_char) -> *mut cocos2d_CCTexturePVR {
        cocos2d_CCTexturePVR_create(path)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTexturePVR_CCTexturePVR(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTexturePVR@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTexturePVR_CCTexturePVR_destructor(this: *mut cocos2d_CCTexturePVR);
}
#[doc = " @brief CCParallaxNode: A node that simulates a parallax scroller\n\nThe children will be moved faster / slower than the parent according the the parallax ratio."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCParallaxNode {
    pub _base: cocos2d_CCNode,
    #[doc = " array that holds the offset / ratio of the children"]
    pub m_pParallaxArray: *mut cocos2d__ccArray,
    pub m_tLastPosition: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCParallaxNode() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCParallaxNode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCParallaxNode>(),
        276usize,
        concat!("Size of: ", stringify!(cocos2d_CCParallaxNode))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCParallaxNode>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCParallaxNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pParallaxArray) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParallaxNode),
            "::",
            stringify!(m_pParallaxArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tLastPosition) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCParallaxNode),
            "::",
            stringify!(m_tLastPosition)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCParallaxNode@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCParallaxNode_create() -> *mut cocos2d_CCParallaxNode;
}
extern "thiscall" {
    #[doc = " Adds a child to the container with a z-order, a parallax ratio and a position offset\nIt returns self, so you can chain several addChilds.\n@since v0.8\n@js ctor"]
    #[link_name = "\u{1}??0CCParallaxNode@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCParallaxNode_CCParallaxNode(this: *mut cocos2d_CCParallaxNode);
}
impl cocos2d_CCParallaxNode {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCParallaxNode {
        cocos2d_CCParallaxNode_create()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCParallaxNode_CCParallaxNode(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCParallaxNode@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCParallaxNode_CCParallaxNode_destructor(this: *mut cocos2d_CCParallaxNode);
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCParallaxNode@cocos2d@@UAEXPAVCCNode@2@IABVCCPoint@2@1@Z"]
    pub fn cocos2d_CCParallaxNode_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        z: ::std::os::raw::c_uint,
        parallaxRatio: *const cocos2d_CCPoint,
        positionOffset: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addChild@CCParallaxNode@cocos2d@@UAEXPAVCCNode@2@IH@Z"]
    pub fn cocos2d_CCParallaxNode_addChild1(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_uint,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeChild@CCParallaxNode@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCParallaxNode_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAllChildrenWithCleanup@CCParallaxNode@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCParallaxNode_removeAllChildrenWithCleanup(
        this: *mut ::std::os::raw::c_void,
        cleanup: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCParallaxNode@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCParallaxNode_visit(this: *mut ::std::os::raw::c_void);
}
#[doc = " @brief CCTMXObjectGroup represents the TMX object group.\n@since v0.99.0"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXObjectGroup {
    pub _base: cocos2d_CCObject,
    #[doc = " offset position of child objects"]
    pub m_tPositionOffset: cocos2d_CCPoint,
    #[doc = " list of properties stored in a dictionary"]
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = " array of the objects"]
    pub m_pObjects: *mut cocos2d_CCArray,
    #[doc = " name of the group"]
    pub m_sGroupName: std_string,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXObjectGroup() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXObjectGroup> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXObjectGroup>(),
        92usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXObjectGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXObjectGroup>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXObjectGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tPositionOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_tPositionOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProperties) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pObjects) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_pObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sGroupName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXObjectGroup),
            "::",
            stringify!(m_sGroupName)
        )
    );
}
extern "thiscall" {
    #[doc = " return the value for the specific property name"]
    #[link_name = "\u{1}?propertyNamed@CCTMXObjectGroup@cocos2d@@QAEPAVCCString@2@PBD@Z"]
    pub fn cocos2d_CCTMXObjectGroup_propertyNamed(
        this: *mut cocos2d_CCTMXObjectGroup,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " return the dictionary for the specific object name.\nIt will return the 1st object found on the array for the given name."]
    #[link_name = "\u{1}?objectNamed@CCTMXObjectGroup@cocos2d@@QAEPAVCCDictionary@2@PBD@Z"]
    pub fn cocos2d_CCTMXObjectGroup_objectNamed(
        this: *mut cocos2d_CCTMXObjectGroup,
        objectName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTMXObjectGroup@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_CCTMXObjectGroup(this: *mut cocos2d_CCTMXObjectGroup);
}
impl cocos2d_CCTMXObjectGroup {
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXObjectGroup_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn objectNamed(
        &mut self,
        objectName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXObjectGroup_objectNamed(self, objectName)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXObjectGroup_CCTMXObjectGroup(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " list of properties stored in a dictionary"]
    #[link_name = "\u{1}?getProperties@CCTMXObjectGroup@cocos2d@@UAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " list of properties stored in a dictionary"]
    #[link_name = "\u{1}?setProperties@CCTMXObjectGroup@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXObjectGroup_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = " array of the objects"]
    #[link_name = "\u{1}?getObjects@CCTMXObjectGroup@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_getObjects(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " array of the objects"]
    #[link_name = "\u{1}?setObjects@CCTMXObjectGroup@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXObjectGroup_setObjects(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTMXObjectGroup@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXObjectGroup_CCTMXObjectGroup_destructor(
        this: *mut cocos2d_CCTMXObjectGroup,
    );
}
pub const TMXLayerAttribNone: cocos2d__bindgen_ty_13 = 1;
pub const TMXLayerAttribBase64: cocos2d__bindgen_ty_13 = 2;
pub const TMXLayerAttribGzip: cocos2d__bindgen_ty_13 = 4;
pub const TMXLayerAttribZlib: cocos2d__bindgen_ty_13 = 8;
#[doc = " @addtogroup tilemap_parallax_nodes\n @{"]
pub type cocos2d__bindgen_ty_13 = ::std::os::raw::c_int;
pub const TMXPropertyNone: cocos2d__bindgen_ty_14 = 0;
pub const TMXPropertyMap: cocos2d__bindgen_ty_14 = 1;
pub const TMXPropertyLayer: cocos2d__bindgen_ty_14 = 2;
pub const TMXPropertyObjectGroup: cocos2d__bindgen_ty_14 = 3;
pub const TMXPropertyObject: cocos2d__bindgen_ty_14 = 4;
pub const TMXPropertyTile: cocos2d__bindgen_ty_14 = 5;
pub type cocos2d__bindgen_ty_14 = ::std::os::raw::c_int;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileHorizontalFlag: cocos2d_ccTMXTileFlags_ = -2147483648;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileVerticalFlag: cocos2d_ccTMXTileFlags_ = 1073741824;
pub const cocos2d_ccTMXTileFlags__kCCTMXTileDiagonalFlag: cocos2d_ccTMXTileFlags_ = 536870912;
pub const cocos2d_ccTMXTileFlags__kCCFlipedAll: cocos2d_ccTMXTileFlags_ = -536870912;
pub const cocos2d_ccTMXTileFlags__kCCFlippedMask: cocos2d_ccTMXTileFlags_ = 536870911;
pub type cocos2d_ccTMXTileFlags_ = ::std::os::raw::c_int;
pub use self::cocos2d_ccTMXTileFlags_ as cocos2d_ccTMXTileFlags;
#[doc = " @brief CCTMXLayerInfo contains the information about the layers like:\n- Layer name\n- Layer size\n- Layer opacity at creation time (it can be modified at runtime)\n- Whether the layer is visible (if it's not visible, then the CocosNode won't be created)\n\nThis information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXLayerInfo {
    pub _base: cocos2d_CCObject,
    pub m_pProperties: *mut cocos2d_CCDictionary,
    pub m_sName: std_string,
    pub m_tLayerSize: cocos2d_CCSize,
    pub m_pTiles: *mut ::std::os::raw::c_uint,
    pub m_bVisible: bool,
    pub m_cOpacity: ::std::os::raw::c_uchar,
    pub m_bOwnTiles: bool,
    pub m_uMinGID: ::std::os::raw::c_uint,
    pub m_uMaxGID: ::std::os::raw::c_uint,
    pub m_tOffset: cocos2d_CCPoint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXLayerInfo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXLayerInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXLayerInfo>(),
        112usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXLayerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXLayerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXLayerInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProperties) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_sName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tLayerSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_tLayerSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTiles) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_pTiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bVisible) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_bVisible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOpacity) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_cOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bOwnTiles) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_bOwnTiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMinGID) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_uMinGID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMaxGID) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_uMaxGID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tOffset) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayerInfo),
            "::",
            stringify!(m_tOffset)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCTMXLayerInfo@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXLayerInfo_CCTMXLayerInfo(this: *mut cocos2d_CCTMXLayerInfo);
}
impl cocos2d_CCTMXLayerInfo {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXLayerInfo_CCTMXLayerInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}?getProperties@CCTMXLayerInfo@cocos2d@@UAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXLayerInfo_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[link_name = "\u{1}?setProperties@CCTMXLayerInfo@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXLayerInfo_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTMXLayerInfo@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXLayerInfo_CCTMXLayerInfo_destructor(this: *mut cocos2d_CCTMXLayerInfo);
}
#[doc = " @brief CCTMXTilesetInfo contains the information about the tilesets like:\n- Tileset name\n- Tileset spacing\n- Tileset margin\n- size of the tiles\n- Image used for the tiles\n- Image size\n\nThis information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXTilesetInfo {
    pub _base: cocos2d_CCObject,
    pub m_sName: std_string,
    pub m_uFirstGid: ::std::os::raw::c_uint,
    pub m_tTileSize: cocos2d_CCSize,
    pub m_uSpacing: ::std::os::raw::c_uint,
    pub m_uMargin: ::std::os::raw::c_uint,
    #[doc = "! filename containing the tiles (should be spritesheet / texture atlas)"]
    pub m_sSourceImage: std_string,
    #[doc = "! size in pixels of the image"]
    pub m_tImageSize: cocos2d_CCSize,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXTilesetInfo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXTilesetInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXTilesetInfo>(),
        128usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXTilesetInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXTilesetInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXTilesetInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sName) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_sName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uFirstGid) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uFirstGid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tTileSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_tTileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uSpacing) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uSpacing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMargin) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_uMargin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sSourceImage) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_sSourceImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tImageSize) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTilesetInfo),
            "::",
            stringify!(m_tImageSize)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?rectForGID@CCTMXTilesetInfo@cocos2d@@QAE?AVCCRect@2@I@Z"]
    pub fn cocos2d_CCTMXTilesetInfo_rectForGID(
        this: *mut cocos2d_CCTMXTilesetInfo,
        gid: ::std::os::raw::c_uint,
    ) -> cocos2d_CCRect;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCTMXTilesetInfo@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo(this: *mut cocos2d_CCTMXTilesetInfo);
}
impl cocos2d_CCTMXTilesetInfo {
    #[inline]
    pub unsafe fn rectForGID(&mut self, gid: ::std::os::raw::c_uint) -> cocos2d_CCRect {
        cocos2d_CCTMXTilesetInfo_rectForGID(self, gid)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTMXTilesetInfo@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXTilesetInfo_CCTMXTilesetInfo_destructor(
        this: *mut cocos2d_CCTMXTilesetInfo,
    );
}
#[doc = " @brief CCTMXMapInfo contains the information about the map like:\n- Map orientation (hexagonal, isometric or orthogonal)\n- Tile size\n- Map size\n\nAnd it also contains:\n- Layers (an array of TMXLayerInfo objects)\n- Tilesets (an array of TMXTilesetInfo objects)\n- ObjectGroups (an array of TMXObjectGroupInfo objects)\n\nThis information is obtained from the TMX file."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXMapInfo {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_CCSAXDelegator,
    #[doc = " map orientation"]
    pub m_nOrientation: ::std::os::raw::c_int,
    #[doc = " map width & height"]
    pub m_tMapSize: cocos2d_CCSize,
    #[doc = " tiles width & height"]
    pub m_tTileSize: cocos2d_CCSize,
    #[doc = " Layers"]
    pub m_pLayers: *mut cocos2d_CCArray,
    #[doc = " tilesets"]
    pub m_pTilesets: *mut cocos2d_CCArray,
    #[doc = " ObjectGroups"]
    pub m_pObjectGroups: *mut cocos2d_CCArray,
    #[doc = " parent element"]
    pub m_nParentElement: ::std::os::raw::c_int,
    #[doc = " parent GID"]
    pub m_uParentGID: ::std::os::raw::c_uint,
    #[doc = " layer attribs"]
    pub m_nLayerAttribs: ::std::os::raw::c_int,
    #[doc = " is storing characters?"]
    pub m_bStoringCharacters: bool,
    #[doc = " properties"]
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! tmx filename"]
    pub m_sTMXFileName: std_string,
    pub m_sResources: std_string,
    #[doc = "! current string"]
    pub m_sCurrentString: std_string,
    #[doc = "! tile properties"]
    pub m_pTileProperties: *mut cocos2d_CCDictionary,
    pub m_uCurrentFirstGID: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXMapInfo() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXMapInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXMapInfo>(),
        188usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXMapInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXMapInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXMapInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nOrientation) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_nOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tMapSize) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_tMapSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tTileSize) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_tTileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pLayers) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_pLayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTilesets) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_pTilesets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pObjectGroups) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_pObjectGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nParentElement) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_nParentElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uParentGID) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_uParentGID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nLayerAttribs) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_nLayerAttribs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bStoringCharacters) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_bStoringCharacters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProperties) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sTMXFileName) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_sTMXFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sResources) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_sResources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sCurrentString) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_sCurrentString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTileProperties) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_pTileProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uCurrentFirstGID) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXMapInfo),
            "::",
            stringify!(m_uCurrentFirstGID)
        )
    );
}
extern "C" {
    #[doc = " creates a TMX Format with a tmx file"]
    #[link_name = "\u{1}?formatWithTMXFile@CCTMXMapInfo@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_formatWithTMXFile(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo;
}
extern "C" {
    #[doc = " creates a TMX Format with an XML string and a TMX resource path"]
    #[link_name = "\u{1}?formatWithXML@CCTMXMapInfo@cocos2d@@SAPAV12@PBD0@Z"]
    pub fn cocos2d_CCTMXMapInfo_formatWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo;
}
extern "thiscall" {
    #[doc = " initializes a TMX format with a  tmx file\n @lua NA"]
    #[link_name = "\u{1}?initWithTMXFile@CCTMXMapInfo@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_initWithTMXFile(
        this: *mut cocos2d_CCTMXMapInfo,
        tmxFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a TMX format with an XML string and a TMX resource path\n @lua NA"]
    #[link_name = "\u{1}?initWithXML@CCTMXMapInfo@cocos2d@@QAE_NPBD0@Z"]
    pub fn cocos2d_CCTMXMapInfo_initWithXML(
        this: *mut cocos2d_CCTMXMapInfo,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file"]
    #[link_name = "\u{1}?parseXMLFile@CCTMXMapInfo@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_parseXMLFile(
        this: *mut cocos2d_CCTMXMapInfo,
        xmlFilename: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?parseXMLString@CCTMXMapInfo@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_parseXMLString(
        this: *mut cocos2d_CCTMXMapInfo,
        xmlString: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getTileProperties@CCTMXMapInfo@cocos2d@@QAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getTileProperties(
        this: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[link_name = "\u{1}?setTileProperties@CCTMXMapInfo@cocos2d@@QAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setTileProperties(
        this: *mut cocos2d_CCTMXMapInfo,
        tileProperties: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = " @js  ctor\n @lua NA"]
    #[link_name = "\u{1}??0CCTMXMapInfo@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXMapInfo_CCTMXMapInfo(this: *mut cocos2d_CCTMXMapInfo);
}
impl cocos2d_CCTMXMapInfo {
    #[inline]
    pub unsafe fn formatWithTMXFile(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo {
        cocos2d_CCTMXMapInfo_formatWithTMXFile(tmxFile)
    }
    #[inline]
    pub unsafe fn formatWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXMapInfo {
        cocos2d_CCTMXMapInfo_formatWithXML(tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn initWithTMXFile(&mut self, tmxFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_initWithTMXFile(self, tmxFile)
    }
    #[inline]
    pub unsafe fn initWithXML(
        &mut self,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCTMXMapInfo_initWithXML(self, tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn parseXMLFile(&mut self, xmlFilename: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_parseXMLFile(self, xmlFilename)
    }
    #[inline]
    pub unsafe fn parseXMLString(&mut self, xmlString: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXMapInfo_parseXMLString(self, xmlString)
    }
    #[inline]
    pub unsafe fn getTileProperties(&mut self) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXMapInfo_getTileProperties(self)
    }
    #[inline]
    pub unsafe fn setTileProperties(&mut self, tileProperties: *mut cocos2d_CCDictionary) {
        cocos2d_CCTMXMapInfo_setTileProperties(self, tileProperties)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXMapInfo_CCTMXMapInfo(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " Layers"]
    #[link_name = "\u{1}?getLayers@CCTMXMapInfo@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getLayers(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " Layers"]
    #[link_name = "\u{1}?setLayers@CCTMXMapInfo@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setLayers(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " tilesets"]
    #[link_name = "\u{1}?getTilesets@CCTMXMapInfo@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getTilesets(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " tilesets"]
    #[link_name = "\u{1}?setTilesets@CCTMXMapInfo@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setTilesets(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " ObjectGroups"]
    #[link_name = "\u{1}?getObjectGroups@CCTMXMapInfo@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getObjectGroups(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " ObjectGroups"]
    #[link_name = "\u{1}?setObjectGroups@CCTMXMapInfo@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setObjectGroups(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " properties"]
    #[link_name = "\u{1}?getProperties@CCTMXMapInfo@cocos2d@@UAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXMapInfo_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " properties"]
    #[link_name = "\u{1}?setProperties@CCTMXMapInfo@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXMapInfo_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTMXMapInfo@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXMapInfo_CCTMXMapInfo_destructor(this: *mut cocos2d_CCTMXMapInfo);
}
extern "thiscall" {
    #[doc = " implement pure virtual methods of CCSAXDelegator\n  @js NA"]
    #[link_name = "\u{1}?startElement@CCTMXMapInfo@cocos2d@@UAEXPAXPBDPAPBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_startElement(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        atts: *mut *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = "  @js NA"]
    #[link_name = "\u{1}?endElement@CCTMXMapInfo@cocos2d@@UAEXPAXPBD@Z"]
    pub fn cocos2d_CCTMXMapInfo_endElement(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[doc = " @js NA"]
    #[link_name = "\u{1}?textHandler@CCTMXMapInfo@cocos2d@@UAEXPAXPBDH@Z"]
    pub fn cocos2d_CCTMXMapInfo_textHandler(
        this: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        ch: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
#[doc = " @brief CCTMXLayer represents the TMX layer.\n\nIt is a subclass of CCSpriteBatchNode. By default the tiles are rendered using a CCTextureAtlas.\nIf you modify a tile on runtime, then, that tile will become a CCSprite, otherwise no CCSprite objects are created.\nThe benefits of using CCSprite objects as tiles are:\n- tiles (CCSprite) can be rotated/scaled/moved with a nice API\n\nIf the layer contains a property named \"cc_vertexz\" with an integer (in can be positive or negative),\nthen all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth.\n\nOn the other hand, if the \"cc_vertexz\" property has the \"automatic\" value, then the tiles will use an automatic vertex Z value.\nAlso before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:\n\nglAlphaFunc( GL_GREATER, value )\n\n\"value\" by default is 0, but you can change it from Tiled by adding the \"cc_alpha_func\" property to the layer.\nThe value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different\nvalue, like 0.5.\n\nFor further information, please see the programming guide:\n\nhttp://www.cocos2d-iphone.org/wiki/doku.php/prog_guide:tiled_maps\n\n@since v0.8.1\nTiles can have tile flags for additional properties. At the moment only flip horizontal and flip vertical are used. These bit flags are defined in CCTMXXMLParser.h.\n\n@since 1.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXLayer {
    pub _base: cocos2d_CCSpriteBatchNode,
    #[doc = " size of the layer in tiles"]
    pub m_tLayerSize: cocos2d_CCSize,
    #[doc = " size of the map's tile (could be different from the tile's size)"]
    pub m_tMapTileSize: cocos2d_CCSize,
    #[doc = " pointer to the map of tiles"]
    pub m_pTiles: *mut ::std::os::raw::c_uint,
    #[doc = " Tileset information for the layer"]
    pub m_pTileSet: *mut cocos2d_CCTMXTilesetInfo,
    #[doc = " Layer orientation, which is the same as the map orientation"]
    pub m_uLayerOrientation: ::std::os::raw::c_uint,
    #[doc = " properties from the layer. They can be added using Tiled"]
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! name of the layer"]
    pub m_sLayerName: std_string,
    #[doc = "! TMX Layer supports opacity"]
    pub m_cOpacity: ::std::os::raw::c_uchar,
    pub m_uMinGID: ::std::os::raw::c_uint,
    pub m_uMaxGID: ::std::os::raw::c_uint,
    #[doc = "! Only used when vertexZ is used"]
    pub m_nVertexZvalue: ::std::os::raw::c_int,
    pub m_bUseAutomaticVertexZ: bool,
    #[doc = "! used for optimization"]
    pub m_pReusedTile: *mut cocos2d_CCSprite,
    pub m_pAtlasIndexArray: *mut cocos2d_ccCArray,
    pub m_fContentScaleFactor: f32,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXLayer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXLayer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXLayer>(),
        376usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXLayer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXLayer>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXLayer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tLayerSize) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_tLayerSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tMapTileSize) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_tMapTileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTiles) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pTiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTileSet) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pTileSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uLayerOrientation) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uLayerOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProperties) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sLayerName) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_sLayerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cOpacity) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_cOpacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMinGID) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uMinGID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uMaxGID) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_uMaxGID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nVertexZvalue) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_nVertexZvalue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUseAutomaticVertexZ) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_bUseAutomaticVertexZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pReusedTile) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pReusedTile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pAtlasIndexArray) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_pAtlasIndexArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fContentScaleFactor) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXLayer),
            "::",
            stringify!(m_fContentScaleFactor)
        )
    );
}
extern "C" {
    #[doc = " creates a CCTMXLayer with an tileset info, a layer info and a map info"]
    #[link_name = "\u{1}?create@CCTMXLayer@cocos2d@@SAPAV12@PAVCCTMXTilesetInfo@2@PAVCCTMXLayerInfo@2@PAVCCTMXMapInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_create(
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCTMXLayer;
}
extern "thiscall" {
    #[doc = " initializes a CCTMXLayer with a tileset info, a layer info and a map info\n @lua NA"]
    #[link_name = "\u{1}?initWithTilesetInfo@CCTMXLayer@cocos2d@@QAE_NPAVCCTMXTilesetInfo@2@PAVCCTMXLayerInfo@2@PAVCCTMXMapInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_initWithTilesetInfo(
        this: *mut cocos2d_CCTMXLayer,
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " dealloc the map that contains the tile position from memory.\nUnless you want to know at runtime the tiles positions, you can safely call this method.\nIf you are going to call layer->tileGIDAt() then, don't release the map"]
    #[link_name = "\u{1}?releaseMap@CCTMXLayer@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTMXLayer_releaseMap(this: *mut cocos2d_CCTMXLayer);
}
extern "thiscall" {
    #[doc = " returns the tile (CCSprite) at a given a tile coordinate.\nThe returned CCSprite will be already added to the CCTMXLayer. Don't add it again.\nThe CCSprite can be treated like any other CCSprite: rotated, scaled, translated, opacity, color, etc.\nYou can remove either by calling:\n- layer->removeChild(sprite, cleanup);\n- or layer->removeTileAt(ccp(x,y));\n@js getTileGIDAt"]
    #[link_name = "\u{1}?tileAt@CCTMXLayer@cocos2d@@QAEPAVCCSprite@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCSprite;
}
extern "thiscall" {
    #[doc = " returns the tile gid at a given tile coordinate.\nif it returns 0, it means that the tile is empty.\nThis method requires the the tile map has not been previously released (eg. don't call layer->releaseMap())\n@js tileGIDAt"]
    #[link_name = "\u{1}?tileGIDAt@CCTMXLayer@cocos2d@@QAEIABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileGIDAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " returns the tile gid at a given tile coordinate. It also returns the tile flags.\nThis method requires the the tile map has not been previously released (eg. don't call [layer releaseMap])\n@js tileGIDAt\n@lua NA"]
    #[link_name = "\u{1}?tileGIDAt@CCTMXLayer@cocos2d@@QAEIABVCCPoint@2@PAW4ccTMXTileFlags_@2@@Z"]
    pub fn cocos2d_CCTMXLayer_tileGIDAt1(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: *mut cocos2d_ccTMXTileFlags,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " sets the tile gid (gid = tile global id) at a given tile coordinate.\nThe Tile GID can be obtained by using the method \"tileGIDAt\" or by using the TMX editor -> Tileset Mgr +1.\nIf a tile is already placed at that position, then it will be removed."]
    #[link_name = "\u{1}?setTileGID@CCTMXLayer@cocos2d@@QAEXIABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileGID(
        this: *mut cocos2d_CCTMXLayer,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " sets the tile gid (gid = tile global id) at a given tile coordinate.\nThe Tile GID can be obtained by using the method \"tileGIDAt\" or by using the TMX editor -> Tileset Mgr +1.\nIf a tile is already placed at that position, then it will be removed.\n\nUse withFlags if the tile flags need to be changed as well"]
    #[link_name = "\u{1}?setTileGID@CCTMXLayer@cocos2d@@QAEXIABVCCPoint@2@W4ccTMXTileFlags_@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileGID1(
        this: *mut cocos2d_CCTMXLayer,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: cocos2d_ccTMXTileFlags,
    );
}
extern "thiscall" {
    #[doc = " removes a tile at given tile coordinate"]
    #[link_name = "\u{1}?removeTileAt@CCTMXLayer@cocos2d@@QAEXABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTMXLayer_removeTileAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " returns the position in points of a given tile coordinate\n @js getPositionAt"]
    #[link_name = "\u{1}?positionAt@CCTMXLayer@cocos2d@@QAE?AVCCPoint@2@ABV32@@Z"]
    pub fn cocos2d_CCTMXLayer_positionAt(
        this: *mut cocos2d_CCTMXLayer,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[doc = " return the value for the specific property name\n  @js getProperty"]
    #[link_name = "\u{1}?propertyNamed@CCTMXLayer@cocos2d@@QAEPAVCCString@2@PBD@Z"]
    pub fn cocos2d_CCTMXLayer_propertyNamed(
        this: *mut cocos2d_CCTMXLayer,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " Creates the tiles"]
    #[link_name = "\u{1}?setupTiles@CCTMXLayer@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTMXLayer_setupTiles(this: *mut cocos2d_CCTMXLayer);
}
extern "thiscall" {
    #[doc = " @js ctor\n @lua NA"]
    #[link_name = "\u{1}??0CCTMXLayer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXLayer_CCTMXLayer(this: *mut cocos2d_CCTMXLayer);
}
impl cocos2d_CCTMXLayer {
    #[inline]
    pub unsafe fn create(
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> *mut cocos2d_CCTMXLayer {
        cocos2d_CCTMXLayer_create(tilesetInfo, layerInfo, mapInfo)
    }
    #[inline]
    pub unsafe fn initWithTilesetInfo(
        &mut self,
        tilesetInfo: *mut cocos2d_CCTMXTilesetInfo,
        layerInfo: *mut cocos2d_CCTMXLayerInfo,
        mapInfo: *mut cocos2d_CCTMXMapInfo,
    ) -> bool {
        cocos2d_CCTMXLayer_initWithTilesetInfo(self, tilesetInfo, layerInfo, mapInfo)
    }
    #[inline]
    pub unsafe fn releaseMap(&mut self) {
        cocos2d_CCTMXLayer_releaseMap(self)
    }
    #[inline]
    pub unsafe fn tileAt(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> *mut cocos2d_CCSprite {
        cocos2d_CCTMXLayer_tileAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn tileGIDAt(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTMXLayer_tileGIDAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn tileGIDAt1(
        &mut self,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: *mut cocos2d_ccTMXTileFlags,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCTMXLayer_tileGIDAt1(self, tileCoordinate, flags)
    }
    #[inline]
    pub unsafe fn setTileGID(
        &mut self,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
    ) {
        cocos2d_CCTMXLayer_setTileGID(self, gid, tileCoordinate)
    }
    #[inline]
    pub unsafe fn setTileGID1(
        &mut self,
        gid: ::std::os::raw::c_uint,
        tileCoordinate: *const cocos2d_CCPoint,
        flags: cocos2d_ccTMXTileFlags,
    ) {
        cocos2d_CCTMXLayer_setTileGID1(self, gid, tileCoordinate, flags)
    }
    #[inline]
    pub unsafe fn removeTileAt(&mut self, tileCoordinate: *const cocos2d_CCPoint) {
        cocos2d_CCTMXLayer_removeTileAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn positionAt(&mut self, tileCoordinate: *const cocos2d_CCPoint) -> cocos2d_CCPoint {
        cocos2d_CCTMXLayer_positionAt(self, tileCoordinate)
    }
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXLayer_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn setupTiles(&mut self) {
        cocos2d_CCTMXLayer_setupTiles(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXLayer_CCTMXLayer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " Tileset information for the layer"]
    #[link_name = "\u{1}?getTileSet@CCTMXLayer@cocos2d@@UAEPAVCCTMXTilesetInfo@2@XZ"]
    pub fn cocos2d_CCTMXLayer_getTileSet(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCTMXTilesetInfo;
}
extern "thiscall" {
    #[doc = " Tileset information for the layer"]
    #[link_name = "\u{1}?setTileSet@CCTMXLayer@cocos2d@@UAEXPAVCCTMXTilesetInfo@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setTileSet(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCTMXTilesetInfo,
    );
}
extern "thiscall" {
    #[doc = " properties from the layer. They can be added using Tiled"]
    #[link_name = "\u{1}?getProperties@CCTMXLayer@cocos2d@@UAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXLayer_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " properties from the layer. They can be added using Tiled"]
    #[link_name = "\u{1}?setProperties@CCTMXLayer@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXLayer_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTMXLayer@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXLayer_CCTMXLayer_destructor(this: *mut cocos2d_CCTMXLayer);
}
extern "thiscall" {
    #[doc = " CCTMXLayer doesn't support adding a CCSprite manually.\n  @warning addchild(z, tag); is not supported on CCTMXLayer. Instead of setTileGID.\n  @lua NA"]
    #[link_name = "\u{1}?addChild@CCTMXLayer@cocos2d@@UAEXPAVCCNode@2@HH@Z"]
    pub fn cocos2d_CCTMXLayer_addChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        zOrder: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " super method\n  @lua NA"]
    #[link_name = "\u{1}?removeChild@CCTMXLayer@cocos2d@@UAEXPAVCCNode@2@_N@Z"]
    pub fn cocos2d_CCTMXLayer_removeChild(
        this: *mut ::std::os::raw::c_void,
        child: *mut cocos2d_CCNode,
        cleanup: bool,
    );
}
#[doc = " Orthogonal orientation"]
pub const CCTMXOrientationOrtho: cocos2d__bindgen_ty_15 = 0;
#[doc = " Hexagonal orientation"]
pub const CCTMXOrientationHex: cocos2d__bindgen_ty_15 = 1;
#[doc = " Isometric orientation"]
pub const CCTMXOrientationIso: cocos2d__bindgen_ty_15 = 2;
#[doc = " Possible orientations of the TMX map"]
pub type cocos2d__bindgen_ty_15 = ::std::os::raw::c_int;
#[doc = " @brief CCTMXTiledMap knows how to parse and render a TMX map.\n\nIt adds support for the TMX tiled map format used by http://www.mapeditor.org\nIt supports isometric, hexagonal and orthogonal tiles.\nIt also supports object groups, objects, and properties.\n\nFeatures:\n- Each tile will be treated as an CCSprite\n- The sprites are created on demand. They will be created only when you call \"layer->tileAt(position)\"\n- Each tile can be rotated / moved / scaled / tinted / \"opaqued\", since each tile is a CCSprite\n- Tiles can be added/removed in runtime\n- The z-order of the tiles can be modified in runtime\n- Each tile has an anchorPoint of (0,0)\n- The anchorPoint of the TMXTileMap is (0,0)\n- The TMX layers will be added as a child\n- The TMX layers will be aliased by default\n- The tileset image will be loaded using the CCTextureCache\n- Each tile will have a unique tag\n- Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z\n- Each object group will be treated as an CCMutableArray\n- Object class which will contain all the properties in a dictionary\n- Properties can be assigned to the Map, Layer, Object Group, and Object\n\nLimitations:\n- It only supports one tileset per layer.\n- Embedded images are not supported\n- It only supports the XML format (the JSON format is not supported)\n\nTechnical description:\nEach layer is created using an CCTMXLayer (subclass of CCSpriteBatchNode). If you have 5 layers, then 5 CCTMXLayer will be created,\nunless the layer visibility is off. In that case, the layer won't be created at all.\nYou can obtain the layers (CCTMXLayer objects) at runtime by:\n- map->getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...\n- map->layerNamed(name_of_the_layer);\n\nEach object group is created using a CCTMXObjectGroup which is a subclass of CCMutableArray.\nYou can obtain the object groups at runtime by:\n- map->objectGroupNamed(name_of_the_object_group);\n\nEach object is a CCTMXObject.\n\nEach property is stored as a key-value pair in an CCMutableDictionary.\nYou can obtain the properties at runtime by:\n\nmap->propertyNamed(name_of_the_property);\nlayer->propertyNamed(name_of_the_property);\nobjectGroup->propertyNamed(name_of_the_property);\nobject->propertyNamed(name_of_the_property);\n\n@since v0.8.1"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTMXTiledMap {
    pub _base: cocos2d_CCNode,
    #[doc = " the map's size property measured in tiles"]
    pub m_tMapSize: cocos2d_CCSize,
    #[doc = " the tiles's size property measured in pixels"]
    pub m_tTileSize: cocos2d_CCSize,
    #[doc = " map orientation"]
    pub m_nMapOrientation: ::std::os::raw::c_int,
    #[doc = " object groups"]
    pub m_pObjectGroups: *mut cocos2d_CCArray,
    #[doc = " properties"]
    pub m_pProperties: *mut cocos2d_CCDictionary,
    #[doc = "! tile properties"]
    pub m_pTileProperties: *mut cocos2d_CCDictionary,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTMXTiledMap() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTMXTiledMap> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTMXTiledMap>(),
        296usize,
        concat!("Size of: ", stringify!(cocos2d_CCTMXTiledMap))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTMXTiledMap>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTMXTiledMap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tMapSize) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_tMapSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tTileSize) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_tTileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nMapOrientation) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_nMapOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pObjectGroups) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pObjectGroups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pProperties) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTileProperties) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTMXTiledMap),
            "::",
            stringify!(m_pTileProperties)
        )
    );
}
extern "C" {
    #[doc = " creates a TMX Tiled Map with a TMX file."]
    #[link_name = "\u{1}?create@CCTMXTiledMap@cocos2d@@SAPAV12@PBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_create(
        tmxFile: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap;
}
extern "C" {
    #[doc = " initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources"]
    #[link_name = "\u{1}?createWithXML@CCTMXTiledMap@cocos2d@@SAPAV12@PBD0@Z"]
    pub fn cocos2d_CCTMXTiledMap_createWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap;
}
extern "thiscall" {
    #[doc = " initializes a TMX Tiled Map with a TMX file"]
    #[link_name = "\u{1}?initWithTMXFile@CCTMXTiledMap@cocos2d@@QAE_NPBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_initWithTMXFile(
        this: *mut cocos2d_CCTMXTiledMap,
        tmxFile: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources"]
    #[link_name = "\u{1}?initWithXML@CCTMXTiledMap@cocos2d@@QAE_NPBD0@Z"]
    pub fn cocos2d_CCTMXTiledMap_initWithXML(
        this: *mut cocos2d_CCTMXTiledMap,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " return the TMXLayer for the specific layer\n  @js getLayer"]
    #[link_name = "\u{1}?layerNamed@CCTMXTiledMap@cocos2d@@QAEPAVCCTMXLayer@2@PBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_layerNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        layerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXLayer;
}
extern "thiscall" {
    #[doc = " return the TMXObjectGroup for the specific group\n  @js getObjectGroup"]
    #[link_name = "\u{1}?objectGroupNamed@CCTMXTiledMap@cocos2d@@QAEPAVCCTMXObjectGroup@2@PBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_objectGroupNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        groupName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXObjectGroup;
}
extern "thiscall" {
    #[doc = " return the value for the specific property name\n  @js getProperty"]
    #[link_name = "\u{1}?propertyNamed@CCTMXTiledMap@cocos2d@@QAEPAVCCString@2@PBD@Z"]
    pub fn cocos2d_CCTMXTiledMap_propertyNamed(
        this: *mut cocos2d_CCTMXTiledMap,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString;
}
extern "thiscall" {
    #[doc = " return properties dictionary for tile GID"]
    #[link_name = "\u{1}?propertiesForGID@CCTMXTiledMap@cocos2d@@QAEPAVCCDictionary@2@H@Z"]
    pub fn cocos2d_CCTMXTiledMap_propertiesForGID(
        this: *mut cocos2d_CCTMXTiledMap,
        GID: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTMXTiledMap@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTMXTiledMap_CCTMXTiledMap(this: *mut cocos2d_CCTMXTiledMap);
}
impl cocos2d_CCTMXTiledMap {
    #[inline]
    pub unsafe fn create(tmxFile: *const ::std::os::raw::c_char) -> *mut cocos2d_CCTMXTiledMap {
        cocos2d_CCTMXTiledMap_create(tmxFile)
    }
    #[inline]
    pub unsafe fn createWithXML(
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXTiledMap {
        cocos2d_CCTMXTiledMap_createWithXML(tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn initWithTMXFile(&mut self, tmxFile: *const ::std::os::raw::c_char) -> bool {
        cocos2d_CCTMXTiledMap_initWithTMXFile(self, tmxFile)
    }
    #[inline]
    pub unsafe fn initWithXML(
        &mut self,
        tmxString: *const ::std::os::raw::c_char,
        resourcePath: *const ::std::os::raw::c_char,
    ) -> bool {
        cocos2d_CCTMXTiledMap_initWithXML(self, tmxString, resourcePath)
    }
    #[inline]
    pub unsafe fn layerNamed(
        &mut self,
        layerName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXLayer {
        cocos2d_CCTMXTiledMap_layerNamed(self, layerName)
    }
    #[inline]
    pub unsafe fn objectGroupNamed(
        &mut self,
        groupName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCTMXObjectGroup {
        cocos2d_CCTMXTiledMap_objectGroupNamed(self, groupName)
    }
    #[inline]
    pub unsafe fn propertyNamed(
        &mut self,
        propertyName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCString {
        cocos2d_CCTMXTiledMap_propertyNamed(self, propertyName)
    }
    #[inline]
    pub unsafe fn propertiesForGID(
        &mut self,
        GID: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCDictionary {
        cocos2d_CCTMXTiledMap_propertiesForGID(self, GID)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTMXTiledMap_CCTMXTiledMap(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " object groups"]
    #[link_name = "\u{1}?getObjectGroups@CCTMXTiledMap@cocos2d@@UAEPAVCCArray@2@XZ"]
    pub fn cocos2d_CCTMXTiledMap_getObjectGroups(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[doc = " object groups"]
    #[link_name = "\u{1}?setObjectGroups@CCTMXTiledMap@cocos2d@@UAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTMXTiledMap_setObjectGroups(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[doc = " properties"]
    #[link_name = "\u{1}?getProperties@CCTMXTiledMap@cocos2d@@UAEPAVCCDictionary@2@XZ"]
    pub fn cocos2d_CCTMXTiledMap_getProperties(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[doc = " properties"]
    #[link_name = "\u{1}?setProperties@CCTMXTiledMap@cocos2d@@UAEXPAVCCDictionary@2@@Z"]
    pub fn cocos2d_CCTMXTiledMap_setProperties(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTMXTiledMap@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTMXTiledMap_CCTMXTiledMap_destructor(this: *mut cocos2d_CCTMXTiledMap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_sImageTGA {
    _unused: [u8; 0],
}
#[doc = " @brief CCTileMapAtlas is a subclass of CCAtlasNode.\n\nIt knows how to render a map based of tiles.\nThe tiles must be in a .PNG format while the map must be a .TGA file.\n\nFor more information regarding the format, please see this post:\nhttp://www.cocos2d-iphone.org/archives/27\n\nAll features from CCAtlasNode are valid in CCTileMapAtlas\n\nIMPORTANT:\nThis class is deprecated. It is maintained for compatibility reasons only.\nYou SHOULD not use this class.\nInstead, use the newer TMX file format: CCTMXTiledMap"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTileMapAtlas {
    pub _base: cocos2d_CCAtlasNode,
    #[doc = " TileMap info"]
    pub m_pTGAInfo: *mut cocos2d_sImageTGA,
    #[doc = "! x,y to atlas dictionary"]
    pub m_pPosToAtlasIndex: *mut cocos2d_CCDictionary,
    #[doc = "! numbers of tiles to render"]
    pub m_nItemsToRender: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTileMapAtlas() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTileMapAtlas> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTileMapAtlas>(),
        344usize,
        concat!("Size of: ", stringify!(cocos2d_CCTileMapAtlas))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTileMapAtlas>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTileMapAtlas))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTGAInfo) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_pTGAInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPosToAtlasIndex) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_pPosToAtlasIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nItemsToRender) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTileMapAtlas),
            "::",
            stringify!(m_nItemsToRender)
        )
    );
}
extern "C" {
    #[doc = " creates a CCTileMap with a tile file (atlas) with a map file and the width and height of each tile in points.\nThe tile file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?create@CCTileMapAtlas@cocos2d@@SAPAV12@PBD0HH@Z"]
    pub fn cocos2d_CCTileMapAtlas_create(
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTileMapAtlas;
}
extern "thiscall" {
    #[doc = " initializes a CCTileMap with a tile file (atlas) with a map file and the width and height of each tile in points.\nThe file will be loaded using the TextureMgr."]
    #[link_name = "\u{1}?initWithTileFile@CCTileMapAtlas@cocos2d@@QAE_NPBD0HH@Z"]
    pub fn cocos2d_CCTileMapAtlas_initWithTileFile(
        this: *mut cocos2d_CCTileMapAtlas,
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " returns a tile from position x,y.\nFor the moment only channel R is used\n@js getTileAt"]
    #[link_name = "\u{1}?tileAt@CCTileMapAtlas@cocos2d@@QAE?AU_ccColor3B@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_tileAt(
        this: *mut cocos2d_CCTileMapAtlas,
        position: *const cocos2d_CCPoint,
    ) -> cocos2d_ccColor3B;
}
extern "thiscall" {
    #[doc = " sets a tile at position x,y.\nFor the moment only channel R is used"]
    #[link_name = "\u{1}?setTile@CCTileMapAtlas@cocos2d@@QAEXABU_ccColor3B@2@ABVCCPoint@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_setTile(
        this: *mut cocos2d_CCTileMapAtlas,
        tile: *const cocos2d_ccColor3B,
        position: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[doc = " dealloc the map from memory"]
    #[link_name = "\u{1}?releaseMap@CCTileMapAtlas@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTileMapAtlas_releaseMap(this: *mut cocos2d_CCTileMapAtlas);
}
extern "thiscall" {
    #[doc = " @js ctor"]
    #[link_name = "\u{1}??0CCTileMapAtlas@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTileMapAtlas_CCTileMapAtlas(this: *mut cocos2d_CCTileMapAtlas);
}
impl cocos2d_CCTileMapAtlas {
    #[inline]
    pub unsafe fn create(
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTileMapAtlas {
        cocos2d_CCTileMapAtlas_create(tile, mapFile, tileWidth, tileHeight)
    }
    #[inline]
    pub unsafe fn initWithTileFile(
        &mut self,
        tile: *const ::std::os::raw::c_char,
        mapFile: *const ::std::os::raw::c_char,
        tileWidth: ::std::os::raw::c_int,
        tileHeight: ::std::os::raw::c_int,
    ) -> bool {
        cocos2d_CCTileMapAtlas_initWithTileFile(self, tile, mapFile, tileWidth, tileHeight)
    }
    #[inline]
    pub unsafe fn tileAt(&mut self, position: *const cocos2d_CCPoint) -> cocos2d_ccColor3B {
        cocos2d_CCTileMapAtlas_tileAt(self, position)
    }
    #[inline]
    pub unsafe fn setTile(
        &mut self,
        tile: *const cocos2d_ccColor3B,
        position: *const cocos2d_CCPoint,
    ) {
        cocos2d_CCTileMapAtlas_setTile(self, tile, position)
    }
    #[inline]
    pub unsafe fn releaseMap(&mut self) {
        cocos2d_CCTileMapAtlas_releaseMap(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTileMapAtlas_CCTileMapAtlas(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " TileMap info"]
    #[link_name = "\u{1}?getTGAInfo@CCTileMapAtlas@cocos2d@@UAEPAUsImageTGA@2@XZ"]
    pub fn cocos2d_CCTileMapAtlas_getTGAInfo(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut cocos2d_sImageTGA;
}
extern "thiscall" {
    #[doc = " TileMap info"]
    #[link_name = "\u{1}?setTGAInfo@CCTileMapAtlas@cocos2d@@UAEXPAUsImageTGA@2@@Z"]
    pub fn cocos2d_CCTileMapAtlas_setTGAInfo(
        this: *mut ::std::os::raw::c_void,
        var: *mut cocos2d_sImageTGA,
    );
}
extern "thiscall" {
    #[doc = " @js NA\n @lua NA"]
    #[link_name = "\u{1}??1CCTileMapAtlas@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTileMapAtlas_CCTileMapAtlas_destructor(this: *mut cocos2d_CCTileMapAtlas);
}
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorBeganBit: cocos2d_ccTouchSelectorFlag = 1;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorMovedBit: cocos2d_ccTouchSelectorFlag = 2;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorEndedBit: cocos2d_ccTouchSelectorFlag = 4;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorCancelledBit: cocos2d_ccTouchSelectorFlag = 8;
pub const cocos2d_ccTouchSelectorFlag_ccTouchSelectorAllBits: cocos2d_ccTouchSelectorFlag = 15;
#[doc = " @addtogroup input\n @{"]
pub type cocos2d_ccTouchSelectorFlag = ::std::os::raw::c_int;
pub const CCTOUCHBEGAN: cocos2d__bindgen_ty_16 = 0;
pub const CCTOUCHMOVED: cocos2d__bindgen_ty_16 = 1;
pub const CCTOUCHENDED: cocos2d__bindgen_ty_16 = 2;
pub const CCTOUCHCANCELLED: cocos2d__bindgen_ty_16 = 3;
pub const ccTouchMax: cocos2d__bindgen_ty_16 = 4;
pub type cocos2d__bindgen_ty_16 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_ccTouchHandlerHelperData {
    pub m_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_ccTouchHandlerHelperData() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_ccTouchHandlerHelperData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_ccTouchHandlerHelperData>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_ccTouchHandlerHelperData))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_ccTouchHandlerHelperData>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_ccTouchHandlerHelperData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_ccTouchHandlerHelperData),
            "::",
            stringify!(m_type)
        )
    );
}
#[repr(C)]
pub struct cocos2d_EGLTouchDelegate__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_EGLTouchDelegate {
    pub vtable_: *const cocos2d_EGLTouchDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_EGLTouchDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_EGLTouchDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_EGLTouchDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_EGLTouchDelegate>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_EGLTouchDelegate))
    );
}
#[doc = " @brief CCTouchDispatcher.\nSingleton that handles all the touch events.\nThe dispatcher dispatches events to the registered TouchHandlers.\nThere are 2 different type of touch handlers:\n- Standard Touch Handlers\n- Targeted Touch Handlers\n\nThe Standard Touch Handlers work like the CocoaTouch touch handler: a set of touches is passed to the delegate.\nOn the other hand, the Targeted Touch Handlers only receive 1 touch at the time, and they can \"swallow\" touches (avoid the propagation of the event).\n\nFirstly, the dispatcher sends the received touches to the targeted touches.\nThese touches can be swallowed by the Targeted Touch Handlers. If there are still remaining touches, then the remaining touches will be sent\nto the Standard Touch Handlers.\n\n@since v0.8.0\n@js NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchDispatcher {
    pub _base: cocos2d_CCObject,
    pub _base_1: cocos2d_EGLTouchDelegate,
    pub m_pTargetedHandlers: *mut cocos2d_CCArray,
    pub m_pStandardHandlers: *mut cocos2d_CCArray,
    pub m_bLocked: bool,
    pub m_bToAdd: bool,
    pub m_bToRemove: bool,
    pub m_pHandlersToAdd: *mut cocos2d_CCArray,
    pub m_pHandlersToRemove: *mut cocos2d__ccCArray,
    pub m_bToQuit: bool,
    pub m_bDispatchEvents: bool,
    pub m_sHandlerHelperData: [cocos2d_ccTouchHandlerHelperData; 4usize],
    pub m_bForcePrio: bool,
    pub m_nTargetPrio: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchDispatcher() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTouchDispatcher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchDispatcher>(),
        104usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchDispatcher>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchDispatcher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTargetedHandlers) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_pTargetedHandlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pStandardHandlers) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_pStandardHandlers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bLocked) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bToAdd) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bToAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bToRemove) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bToRemove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHandlersToAdd) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_pHandlersToAdd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHandlersToRemove) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_pHandlersToRemove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bToQuit) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bToQuit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bDispatchEvents) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bDispatchEvents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sHandlerHelperData) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_sHandlerHelperData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bForcePrio) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_bForcePrio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nTargetPrio) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchDispatcher),
            "::",
            stringify!(m_nTargetPrio)
        )
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?init@CCTouchDispatcher@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCTouchDispatcher_init(this: *mut cocos2d_CCTouchDispatcher) -> bool;
}
extern "thiscall" {
    #[doc = " Whether or not the events are going to be dispatched. Default: true"]
    #[link_name = "\u{1}?isDispatchEvents@CCTouchDispatcher@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCTouchDispatcher_isDispatchEvents(this: *mut cocos2d_CCTouchDispatcher)
        -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDispatchEvents@CCTouchDispatcher@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCTouchDispatcher_setDispatchEvents(
        this: *mut cocos2d_CCTouchDispatcher,
        bDispatchEvents: bool,
    );
}
extern "thiscall" {
    #[doc = " Adds a standard touch delegate to the dispatcher's list.\n See StandardTouchDelegate description.\n IMPORTANT: The delegate will be retained.\n @lua NA"]
    #[link_name = "\u{1}?addStandardDelegate@CCTouchDispatcher@cocos2d@@QAEXPAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchDispatcher_addStandardDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " Adds a targeted touch delegate to the dispatcher's list.\n See TargetedTouchDelegate description.\n IMPORTANT: The delegate will be retained.\n @lua NA"]
    #[link_name = "\u{1}?addTargetedDelegate@CCTouchDispatcher@cocos2d@@QAEXPAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTouchDispatcher_addTargetedDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    );
}
extern "thiscall" {
    #[doc = " Removes a touch delegate.\n The delegate will be released\n @lua NA"]
    #[link_name = "\u{1}?removeDelegate@CCTouchDispatcher@cocos2d@@QAEXPAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_removeDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "thiscall" {
    #[doc = " Removes all touch delegates, releasing all the delegates\n @lua NA"]
    #[link_name = "\u{1}?removeAllDelegates@CCTouchDispatcher@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCTouchDispatcher_removeAllDelegates(this: *mut cocos2d_CCTouchDispatcher);
}
extern "thiscall" {
    #[doc = " Changes the priority of a previously added delegate. The lower the number,\n the higher the priority\n @lua NA"]
    #[link_name = "\u{1}?setPriority@CCTouchDispatcher@cocos2d@@QAEXHPAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_setPriority(
        this: *mut cocos2d_CCTouchDispatcher,
        nPriority: ::std::os::raw::c_int,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touches@CCTouchDispatcher@cocos2d@@QAEXPAVCCSet@2@PAVCCEvent@2@I@Z"]
    pub fn cocos2d_CCTouchDispatcher_touches(
        this: *mut cocos2d_CCTouchDispatcher,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
        uIndex: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?findHandler@CCTouchDispatcher@cocos2d@@QAEPAVCCTouchHandler@2@PAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_findHandler(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler;
}
extern "thiscall" {
    #[link_name = "\u{1}?incrementForcePrio@CCTouchDispatcher@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCTouchDispatcher_incrementForcePrio(
        this: *mut cocos2d_CCTouchDispatcher,
        priority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?decrementForcePrio@CCTouchDispatcher@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCTouchDispatcher_decrementForcePrio(
        this: *mut cocos2d_CCTouchDispatcher,
        priority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCTouchDispatcher@cocos2d@@IAEXPAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCTouchDispatcher,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceAddHandler@CCTouchDispatcher@cocos2d@@IAEXPAVCCTouchHandler@2@PAVCCArray@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_forceAddHandler(
        this: *mut cocos2d_CCTouchDispatcher,
        pHandler: *mut cocos2d_CCTouchHandler,
        pArray: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceRemoveAllDelegates@CCTouchDispatcher@cocos2d@@IAEXXZ"]
    pub fn cocos2d_CCTouchDispatcher_forceRemoveAllDelegates(this: *mut cocos2d_CCTouchDispatcher);
}
extern "thiscall" {
    #[link_name = "\u{1}?rearrangeHandlers@CCTouchDispatcher@cocos2d@@IAEXPAVCCArray@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_rearrangeHandlers(
        this: *mut cocos2d_CCTouchDispatcher,
        pArray: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?findHandler@CCTouchDispatcher@cocos2d@@IAEPAVCCTouchHandler@2@PAVCCArray@2@PAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_findHandler1(
        this: *mut cocos2d_CCTouchDispatcher,
        pArray: *mut cocos2d_CCArray,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler;
}
impl cocos2d_CCTouchDispatcher {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        cocos2d_CCTouchDispatcher_init(self)
    }
    #[inline]
    pub unsafe fn isDispatchEvents(&mut self) -> bool {
        cocos2d_CCTouchDispatcher_isDispatchEvents(self)
    }
    #[inline]
    pub unsafe fn setDispatchEvents(&mut self, bDispatchEvents: bool) {
        cocos2d_CCTouchDispatcher_setDispatchEvents(self, bDispatchEvents)
    }
    #[inline]
    pub unsafe fn addStandardDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) {
        cocos2d_CCTouchDispatcher_addStandardDelegate(self, pDelegate, nPriority)
    }
    #[inline]
    pub unsafe fn addTargetedDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallowsTouches: bool,
    ) {
        cocos2d_CCTouchDispatcher_addTargetedDelegate(self, pDelegate, nPriority, bSwallowsTouches)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeAllDelegates(&mut self) {
        cocos2d_CCTouchDispatcher_removeAllDelegates(self)
    }
    #[inline]
    pub unsafe fn setPriority(
        &mut self,
        nPriority: ::std::os::raw::c_int,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) {
        cocos2d_CCTouchDispatcher_setPriority(self, nPriority, pDelegate)
    }
    #[inline]
    pub unsafe fn touches(
        &mut self,
        pTouches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
        uIndex: ::std::os::raw::c_uint,
    ) {
        cocos2d_CCTouchDispatcher_touches(self, pTouches, pEvent, uIndex)
    }
    #[inline]
    pub unsafe fn findHandler(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchDispatcher_findHandler(self, pDelegate)
    }
    #[inline]
    pub unsafe fn incrementForcePrio(&mut self, priority: ::std::os::raw::c_int) {
        cocos2d_CCTouchDispatcher_incrementForcePrio(self, priority)
    }
    #[inline]
    pub unsafe fn decrementForcePrio(&mut self, priority: ::std::os::raw::c_int) {
        cocos2d_CCTouchDispatcher_decrementForcePrio(self, priority)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddHandler(
        &mut self,
        pHandler: *mut cocos2d_CCTouchHandler,
        pArray: *mut cocos2d_CCArray,
    ) {
        cocos2d_CCTouchDispatcher_forceAddHandler(self, pHandler, pArray)
    }
    #[inline]
    pub unsafe fn forceRemoveAllDelegates(&mut self) {
        cocos2d_CCTouchDispatcher_forceRemoveAllDelegates(self)
    }
    #[inline]
    pub unsafe fn rearrangeHandlers(&mut self, pArray: *mut cocos2d_CCArray) {
        cocos2d_CCTouchDispatcher_rearrangeHandlers(self, pArray)
    }
    #[inline]
    pub unsafe fn findHandler1(
        &mut self,
        pArray: *mut cocos2d_CCArray,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchDispatcher_findHandler1(self, pArray, pDelegate)
    }
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}??1CCTouchDispatcher@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTouchDispatcher_CCTouchDispatcher_destructor(
        this: *mut cocos2d_CCTouchDispatcher,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesBegan@CCTouchDispatcher@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesBegan(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesMoved@CCTouchDispatcher@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesMoved(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesEnded@CCTouchDispatcher@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesEnded(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
extern "thiscall" {
    #[doc = " @lua NA"]
    #[link_name = "\u{1}?touchesCancelled@CCTouchDispatcher@cocos2d@@UAEXPAVCCSet@2@PAVCCEvent@2@@Z"]
    pub fn cocos2d_CCTouchDispatcher_touchesCancelled(
        this: *mut ::std::os::raw::c_void,
        touches: *mut cocos2d_CCSet,
        pEvent: *mut cocos2d_CCEvent,
    );
}
#[doc = "CCTouchHandler\nObject than contains the delegate and priority of the event handler.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTouchHandler {
    pub _base: cocos2d_CCObject,
    pub m_pDelegate: *mut cocos2d_CCTouchDelegate,
    pub m_nPriority: ::std::os::raw::c_int,
    pub m_nEnabledSelectors: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTouchHandler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTouchHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTouchHandler>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTouchHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTouchHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_pDelegate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nPriority) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_nPriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nEnabledSelectors) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTouchHandler),
            "::",
            stringify!(m_nEnabledSelectors)
        )
    );
}
extern "thiscall" {
    #[doc = " delegate"]
    #[link_name = "\u{1}?getDelegate@CCTouchHandler@cocos2d@@QAEPAVCCTouchDelegate@2@XZ"]
    pub fn cocos2d_CCTouchHandler_getDelegate(
        this: *mut cocos2d_CCTouchHandler,
    ) -> *mut cocos2d_CCTouchDelegate;
}
extern "thiscall" {
    #[link_name = "\u{1}?setDelegate@CCTouchHandler@cocos2d@@QAEXPAVCCTouchDelegate@2@@Z"]
    pub fn cocos2d_CCTouchHandler_setDelegate(
        this: *mut cocos2d_CCTouchHandler,
        pDelegate: *mut cocos2d_CCTouchDelegate,
    );
}
extern "thiscall" {
    #[doc = " priority"]
    #[link_name = "\u{1}?getPriority@CCTouchHandler@cocos2d@@QAEHXZ"]
    pub fn cocos2d_CCTouchHandler_getPriority(
        this: *mut cocos2d_CCTouchHandler,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setPriority@CCTouchHandler@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCTouchHandler_setPriority(
        this: *mut cocos2d_CCTouchHandler,
        nPriority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " enabled selectors"]
    #[link_name = "\u{1}?getEnabledSelectors@CCTouchHandler@cocos2d@@QAEHXZ"]
    pub fn cocos2d_CCTouchHandler_getEnabledSelectors(
        this: *mut cocos2d_CCTouchHandler,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEnalbedSelectors@CCTouchHandler@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCTouchHandler_setEnalbedSelectors(
        this: *mut cocos2d_CCTouchHandler,
        nValue: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " allocates a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?handlerWithDelegate@CCTouchHandler@cocos2d@@SAPAV12@PAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTouchHandler;
}
impl cocos2d_CCTouchHandler {
    #[inline]
    pub unsafe fn getDelegate(&mut self) -> *mut cocos2d_CCTouchDelegate {
        cocos2d_CCTouchHandler_getDelegate(self)
    }
    #[inline]
    pub unsafe fn setDelegate(&mut self, pDelegate: *mut cocos2d_CCTouchDelegate) {
        cocos2d_CCTouchHandler_setDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn getPriority(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCTouchHandler_getPriority(self)
    }
    #[inline]
    pub unsafe fn setPriority(&mut self, nPriority: ::std::os::raw::c_int) {
        cocos2d_CCTouchHandler_setPriority(self, nPriority)
    }
    #[inline]
    pub unsafe fn getEnabledSelectors(&mut self) -> ::std::os::raw::c_int {
        cocos2d_CCTouchHandler_getEnabledSelectors(self)
    }
    #[inline]
    pub unsafe fn setEnalbedSelectors(&mut self, nValue: ::std::os::raw::c_int) {
        cocos2d_CCTouchHandler_setEnalbedSelectors(self, nValue)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCTouchHandler {
        cocos2d_CCTouchHandler_handlerWithDelegate(pDelegate, nPriority)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTouchHandler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTouchHandler_CCTouchHandler_destructor(this: *mut cocos2d_CCTouchHandler);
}
extern "thiscall" {
    #[doc = " initializes a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?initWithDelegate@CCTouchHandler@cocos2d@@UAE_NPAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCTouchHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = " CCStandardTouchHandler\nIt forwards each event to the delegate.\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCStandardTouchHandler {
    pub _base: cocos2d_CCTouchHandler,
}
#[test]
fn bindgen_test_layout_cocos2d_CCStandardTouchHandler() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCStandardTouchHandler>(),
        64usize,
        concat!("Size of: ", stringify!(cocos2d_CCStandardTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCStandardTouchHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCStandardTouchHandler))
    );
}
extern "C" {
    #[doc = " allocates a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?handlerWithDelegate@CCStandardTouchHandler@cocos2d@@SAPAV12@PAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCStandardTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCStandardTouchHandler;
}
impl cocos2d_CCStandardTouchHandler {
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCStandardTouchHandler {
        cocos2d_CCStandardTouchHandler_handlerWithDelegate(pDelegate, nPriority)
    }
}
extern "thiscall" {
    #[doc = " initializes a TouchHandler with a delegate and a priority"]
    #[link_name = "\u{1}?initWithDelegate@CCStandardTouchHandler@cocos2d@@UAE_NPAVCCTouchDelegate@2@H@Z"]
    pub fn cocos2d_CCStandardTouchHandler_initWithDelegate(
        this: *mut ::std::os::raw::c_void,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = "CCTargetedTouchHandler\nObject than contains the claimed touches and if it swallows touches.\nUsed internally by TouchDispatcher\n@js NA\n@lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCTargetedTouchHandler {
    pub _base: cocos2d_CCTouchHandler,
    pub m_bSwallowsTouches: bool,
    pub m_pClaimedTouches: *mut cocos2d_CCSet,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTargetedTouchHandler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTargetedTouchHandler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTargetedTouchHandler>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCTargetedTouchHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTargetedTouchHandler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTargetedTouchHandler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bSwallowsTouches) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedTouchHandler),
            "::",
            stringify!(m_bSwallowsTouches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pClaimedTouches) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTargetedTouchHandler),
            "::",
            stringify!(m_pClaimedTouches)
        )
    );
}
extern "thiscall" {
    #[doc = " whether or not the touches are swallowed"]
    #[link_name = "\u{1}?isSwallowsTouches@CCTargetedTouchHandler@cocos2d@@QAE_NXZ"]
    pub fn cocos2d_CCTargetedTouchHandler_isSwallowsTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setSwallowsTouches@CCTargetedTouchHandler@cocos2d@@QAEX_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_setSwallowsTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
        bSwallowsTouches: bool,
    );
}
extern "thiscall" {
    #[doc = " MutableSet that contains the claimed touches"]
    #[link_name = "\u{1}?getClaimedTouches@CCTargetedTouchHandler@cocos2d@@QAEPAVCCSet@2@XZ"]
    pub fn cocos2d_CCTargetedTouchHandler_getClaimedTouches(
        this: *mut cocos2d_CCTargetedTouchHandler,
    ) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = " initializes a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not"]
    #[link_name = "\u{1}?initWithDelegate@CCTargetedTouchHandler@cocos2d@@QAE_NPAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_initWithDelegate(
        this: *mut cocos2d_CCTargetedTouchHandler,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " allocates a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not"]
    #[link_name = "\u{1}?handlerWithDelegate@CCTargetedTouchHandler@cocos2d@@SAPAV12@PAVCCTouchDelegate@2@H_N@Z"]
    pub fn cocos2d_CCTargetedTouchHandler_handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> *mut cocos2d_CCTargetedTouchHandler;
}
impl cocos2d_CCTargetedTouchHandler {
    #[inline]
    pub unsafe fn isSwallowsTouches(&mut self) -> bool {
        cocos2d_CCTargetedTouchHandler_isSwallowsTouches(self)
    }
    #[inline]
    pub unsafe fn setSwallowsTouches(&mut self, bSwallowsTouches: bool) {
        cocos2d_CCTargetedTouchHandler_setSwallowsTouches(self, bSwallowsTouches)
    }
    #[inline]
    pub unsafe fn getClaimedTouches(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCTargetedTouchHandler_getClaimedTouches(self)
    }
    #[inline]
    pub unsafe fn initWithDelegate(
        &mut self,
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> bool {
        cocos2d_CCTargetedTouchHandler_initWithDelegate(self, pDelegate, nPriority, bSwallow)
    }
    #[inline]
    pub unsafe fn handlerWithDelegate(
        pDelegate: *mut cocos2d_CCTouchDelegate,
        nPriority: ::std::os::raw::c_int,
        bSwallow: bool,
    ) -> *mut cocos2d_CCTargetedTouchHandler {
        cocos2d_CCTargetedTouchHandler_handlerWithDelegate(pDelegate, nPriority, bSwallow)
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCTargetedTouchHandler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCTargetedTouchHandler_CCTargetedTouchHandler_destructor(
        this: *mut cocos2d_CCTargetedTouchHandler,
    );
}
#[doc = " @brief Light-weight timer"]
#[repr(C)]
pub struct cocos2d_CCTimer {
    pub _base: cocos2d_CCObject,
    pub m_pTarget: *mut cocos2d_CCObject,
    pub m_fElapsed: f32,
    pub m_bRunForever: bool,
    pub m_bUseDelay: bool,
    pub m_uTimesExecuted: ::std::os::raw::c_uint,
    pub m_uRepeat: ::std::os::raw::c_uint,
    pub m_fDelay: f32,
    pub m_fInterval: f32,
    pub m_pfnSelector: cocos2d_SEL_SCHEDULE,
    pub m_nScriptHandler: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cocos2d_CCTimer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCTimer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCTimer>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCTimer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pTarget) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_pTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fElapsed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fElapsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bRunForever) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_bRunForever)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUseDelay) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_bUseDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uTimesExecuted) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_uTimesExecuted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uRepeat) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_uRepeat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fDelay) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fDelay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fInterval) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_fInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pfnSelector) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_pfnSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nScriptHandler) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCTimer),
            "::",
            stringify!(m_nScriptHandler)
        )
    );
}
extern "thiscall" {
    #[doc = " get interval in seconds"]
    #[link_name = "\u{1}?getInterval@CCTimer@cocos2d@@QBEMXZ"]
    pub fn cocos2d_CCTimer_getInterval(this: *const cocos2d_CCTimer) -> f32;
}
extern "thiscall" {
    #[doc = " set interval in seconds"]
    #[link_name = "\u{1}?setInterval@CCTimer@cocos2d@@QAEXM@Z"]
    pub fn cocos2d_CCTimer_setInterval(this: *mut cocos2d_CCTimer, fInterval: f32);
}
extern "thiscall" {
    #[doc = "  @lua NA"]
    #[link_name = "\u{1}?getSelector@CCTimer@cocos2d@@QBEP8CCObject@2@AEXM@ZXZ"]
    pub fn cocos2d_CCTimer_getSelector(this: *const cocos2d_CCTimer) -> cocos2d_SEL_SCHEDULE;
}
extern "thiscall" {
    #[doc = " Initializes a timer with a target and a selector.\n  @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCTimer@cocos2d@@QAE_NPAVCCObject@2@P832@AEXM@Z@Z"]
    pub fn cocos2d_CCTimer_initWithTarget(
        this: *mut cocos2d_CCTimer,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a timer with a target, a selector and an interval in seconds, repeat in number of times to repeat, delay in seconds.\n  @lua NA"]
    #[link_name = "\u{1}?initWithTarget@CCTimer@cocos2d@@QAE_NPAVCCObject@2@P832@AEXM@ZMIM@Z"]
    pub fn cocos2d_CCTimer_initWithTarget1(
        this: *mut cocos2d_CCTimer,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
        nRepeat: ::std::os::raw::c_uint,
        fDelay: f32,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Initializes a timer with a script callback function and an interval in seconds."]
    #[link_name = "\u{1}?initWithScriptHandler@CCTimer@cocos2d@@QAE_NHM@Z"]
    pub fn cocos2d_CCTimer_initWithScriptHandler(
        this: *mut cocos2d_CCTimer,
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " Allocates a timer with a target and a selector.\n  @lua NA"]
    #[link_name = "\u{1}?timerWithTarget@CCTimer@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEXM@Z@Z"]
    pub fn cocos2d_CCTimer_timerWithTarget(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> *mut cocos2d_CCTimer;
}
extern "C" {
    #[doc = " Allocates a timer with a target, a selector and an interval in seconds.\n  @lua NA"]
    #[link_name = "\u{1}?timerWithTarget@CCTimer@cocos2d@@SAPAV12@PAVCCObject@2@P832@AEXM@ZM@Z"]
    pub fn cocos2d_CCTimer_timerWithTarget1(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer;
}
extern "C" {
    #[doc = " Allocates a timer with a script callback function and an interval in seconds."]
    #[link_name = "\u{1}?timerWithScriptHandler@CCTimer@cocos2d@@SAPAV12@HM@Z"]
    pub fn cocos2d_CCTimer_timerWithScriptHandler(
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer;
}
extern "thiscall" {
    #[doc = "  @js  ctor\n  @lua NA"]
    #[link_name = "\u{1}??0CCTimer@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCTimer_CCTimer(this: *mut cocos2d_CCTimer);
}
impl cocos2d_CCTimer {
    #[inline]
    pub unsafe fn getInterval(&self) -> f32 {
        cocos2d_CCTimer_getInterval(self)
    }
    #[inline]
    pub unsafe fn setInterval(&mut self, fInterval: f32) {
        cocos2d_CCTimer_setInterval(self, fInterval)
    }
    #[inline]
    pub unsafe fn getSelector(&self) -> cocos2d_SEL_SCHEDULE {
        cocos2d_CCTimer_getSelector(self)
    }
    #[inline]
    pub unsafe fn initWithTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> bool {
        cocos2d_CCTimer_initWithTarget(self, pTarget, pfnSelector)
    }
    #[inline]
    pub unsafe fn initWithTarget1(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
        nRepeat: ::std::os::raw::c_uint,
        fDelay: f32,
    ) -> bool {
        cocos2d_CCTimer_initWithTarget1(self, pTarget, pfnSelector, fSeconds, nRepeat, fDelay)
    }
    #[inline]
    pub unsafe fn initWithScriptHandler(
        &mut self,
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> bool {
        cocos2d_CCTimer_initWithScriptHandler(self, nHandler, fSeconds)
    }
    #[inline]
    pub unsafe fn timerWithTarget(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithTarget(pTarget, pfnSelector)
    }
    #[inline]
    pub unsafe fn timerWithTarget1(
        pTarget: *mut cocos2d_CCObject,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithTarget1(pTarget, pfnSelector, fSeconds)
    }
    #[inline]
    pub unsafe fn timerWithScriptHandler(
        nHandler: ::std::os::raw::c_int,
        fSeconds: f32,
    ) -> *mut cocos2d_CCTimer {
        cocos2d_CCTimer_timerWithScriptHandler(nHandler, fSeconds)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCTimer_CCTimer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = " triggers the timer"]
    #[link_name = "\u{1}?update@CCTimer@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCTimer_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__listEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashSelectorEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d__hashUpdateEntry {
    _unused: [u8; 0],
}
#[doc = " @brief Scheduler is responsible for triggering the scheduled callbacks.\nYou should not use NSTimer. Instead use this class.\n\nThere are 2 different types of callbacks (selectors):\n\n- update selector: the 'update' selector will be called every frame. You can customize the priority.\n- custom selector: A custom selector will be called every frame, or with a custom interval of time\n\nThe 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'."]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCScheduler {
    pub _base: cocos2d_CCObject,
    pub m_fTimeScale: f32,
    pub m_pUpdatesNegList: *mut cocos2d__listEntry,
    pub m_pUpdates0List: *mut cocos2d__listEntry,
    pub m_pUpdatesPosList: *mut cocos2d__listEntry,
    pub m_pHashForUpdates: *mut cocos2d__hashUpdateEntry,
    pub m_pHashForTimers: *mut cocos2d__hashSelectorEntry,
    pub m_pCurrentTarget: *mut cocos2d__hashSelectorEntry,
    pub m_bCurrentTargetSalvaged: bool,
    pub m_bUpdateHashLocked: bool,
    pub m_pScriptHandlerEntries: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCScheduler() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCScheduler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCScheduler>(),
        88usize,
        concat!("Size of: ", stringify!(cocos2d_CCScheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCScheduler>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCScheduler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fTimeScale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_fTimeScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUpdatesNegList) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdatesNegList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUpdates0List) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdates0List)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUpdatesPosList) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pUpdatesPosList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHashForUpdates) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pHashForUpdates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pHashForTimers) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pHashForTimers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pCurrentTarget) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pCurrentTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCurrentTargetSalvaged) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_bCurrentTargetSalvaged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUpdateHashLocked) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_bUpdateHashLocked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pScriptHandlerEntries) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCScheduler),
            "::",
            stringify!(m_pScriptHandlerEntries)
        )
    );
}
extern "thiscall" {
    #[doc = " The scheduled method will be called every 'interval' seconds.\nIf paused is YES, then it won't be called until it is resumed.\nIf 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdateForTarget:' instead.\nIf the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.\nrepeat let the action be repeated repeat + 1 times, use kCCRepeatForever to let the action run continuously\ndelay is the amount of time the action will wait before it'll start\n\n@since v0.99.3, repeat and delay added in v1.1\n@js  NA\n@lua NA"]
    #[link_name = "\u{1}?scheduleSelector@CCScheduler@cocos2d@@QAEXP8CCObject@2@AEXM@ZPAV32@MIM_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleSelector(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
        bPaused: bool,
    );
}
extern "thiscall" {
    #[doc = " calls scheduleSelector with kCCRepeatForever and a 0 delay\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?scheduleSelector@CCScheduler@cocos2d@@QAEXP8CCObject@2@AEXM@ZPAV32@M_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleSelector1(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        bPaused: bool,
    );
}
extern "thiscall" {
    #[doc = " Schedules the 'update' selector for a given target with a given priority.\nThe 'update' selector will be called every frame.\nThe lower the priority, the earlier it is called.\n@since v0.99.3\n@lua NA"]
    #[link_name = "\u{1}?scheduleUpdateForTarget@CCScheduler@cocos2d@@QAEXPAVCCObject@2@H_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleUpdateForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
        nPriority: ::std::os::raw::c_int,
        bPaused: bool,
    );
}
extern "thiscall" {
    #[doc = " Unschedule a selector for a given target.\nIf you want to unschedule the \"update\", use unscheudleUpdateForTarget.\n@since v0.99.3\n@lua NA"]
    #[link_name = "\u{1}?unscheduleSelector@CCScheduler@cocos2d@@QAEXP8CCObject@2@AEXM@ZPAV32@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleSelector(
        this: *mut cocos2d_CCScheduler,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Unschedules the update selector for a given target\n@since v0.99.3\n@lua NA"]
    #[link_name = "\u{1}?unscheduleUpdateForTarget@CCScheduler@cocos2d@@QAEXPBVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleUpdateForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *const cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Unschedules all selectors for a given target.\nThis also includes the \"update\" selector.\n@since v0.99.3\n@js  unscheduleCallbackForTarget\n@lua NA"]
    #[link_name = "\u{1}?unscheduleAllForTarget@CCScheduler@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_unscheduleAllForTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Unschedules all selectors from all targets.\nYou should NEVER call this method, unless you know what you are doing.\n\n@since v0.99.3\n@js unscheduleAllCallbacks\n@lua NA"]
    #[link_name = "\u{1}?unscheduleAll@CCScheduler@cocos2d@@QAEXXZ"]
    pub fn cocos2d_CCScheduler_unscheduleAll(this: *mut cocos2d_CCScheduler);
}
extern "thiscall" {
    #[doc = " Unschedules all selectors from all targets with a minimum priority.\nYou should only call this with kCCPriorityNonSystemMin or higher.\n@since v2.0.0\n@js unscheduleAllCallbacksWithMinPriority\n@lua NA"]
    #[link_name = "\u{1}?unscheduleAllWithMinPriority@CCScheduler@cocos2d@@QAEXH@Z"]
    pub fn cocos2d_CCScheduler_unscheduleAllWithMinPriority(
        this: *mut cocos2d_CCScheduler,
        nMinPriority: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[doc = " The scheduled script callback will be called every 'interval' seconds.\nIf paused is YES, then it won't be called until it is resumed.\nIf 'interval' is 0, it will be called every frame.\nreturn schedule script entry ID, used for unscheduleScriptFunc().\n@js NA"]
    #[link_name = "\u{1}?scheduleScriptFunc@CCScheduler@cocos2d@@QAEIIM_N@Z"]
    pub fn cocos2d_CCScheduler_scheduleScriptFunc(
        this: *mut cocos2d_CCScheduler,
        nHandler: ::std::os::raw::c_uint,
        fInterval: f32,
        bPaused: bool,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[doc = " Unschedule a script entry.\n  @js NA"]
    #[link_name = "\u{1}?unscheduleScriptEntry@CCScheduler@cocos2d@@QAEXI@Z"]
    pub fn cocos2d_CCScheduler_unscheduleScriptEntry(
        this: *mut cocos2d_CCScheduler,
        uScheduleScriptEntryID: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[doc = " Pauses the target.\nAll scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.\nIf the target is not present, nothing happens.\n@since v0.99.3\n@lua NA"]
    #[link_name = "\u{1}?pauseTarget@CCScheduler@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_pauseTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Resumes the target.\nThe 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.\nIf the target is not present, nothing happens.\n@since v0.99.3\n@lua NA"]
    #[link_name = "\u{1}?resumeTarget@CCScheduler@cocos2d@@QAEXPAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_resumeTarget(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[doc = " Returns whether or not the target is paused\n@since v1.0.0\n@lua NA"]
    #[link_name = "\u{1}?isTargetPaused@CCScheduler@cocos2d@@QAE_NPAVCCObject@2@@Z"]
    pub fn cocos2d_CCScheduler_isTargetPaused(
        this: *mut cocos2d_CCScheduler,
        pTarget: *mut cocos2d_CCObject,
    ) -> bool;
}
extern "thiscall" {
    #[doc = " Pause all selectors from all targets.\nYou should NEVER call this method, unless you know what you are doing.\n@since v2.0.0\n@lua NA"]
    #[link_name = "\u{1}?pauseAllTargets@CCScheduler@cocos2d@@QAEPAVCCSet@2@XZ"]
    pub fn cocos2d_CCScheduler_pauseAllTargets(
        this: *mut cocos2d_CCScheduler,
    ) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = " Pause all selectors from all targets with a minimum priority.\nYou should only call this with kCCPriorityNonSystemMin or higher.\n@since v2.0.0\n@lua NA"]
    #[link_name = "\u{1}?pauseAllTargetsWithMinPriority@CCScheduler@cocos2d@@QAEPAVCCSet@2@H@Z"]
    pub fn cocos2d_CCScheduler_pauseAllTargetsWithMinPriority(
        this: *mut cocos2d_CCScheduler,
        nMinPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSet;
}
extern "thiscall" {
    #[doc = " Resume selectors on a set of targets.\nThis can be useful for undoing a call to pauseAllSelectors.\n@since v2.0.0\n@lua NA"]
    #[link_name = "\u{1}?resumeTargets@CCScheduler@cocos2d@@QAEXPAVCCSet@2@@Z"]
    pub fn cocos2d_CCScheduler_resumeTargets(
        this: *mut cocos2d_CCScheduler,
        targetsToResume: *mut cocos2d_CCSet,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCScheduler@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCScheduler_CCScheduler(this: *mut cocos2d_CCScheduler);
}
impl cocos2d_CCScheduler {
    #[inline]
    pub unsafe fn scheduleSelector(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        repeat: ::std::os::raw::c_uint,
        delay: f32,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleSelector(
            self,
            pfnSelector,
            pTarget,
            fInterval,
            repeat,
            delay,
            bPaused,
        )
    }
    #[inline]
    pub unsafe fn scheduleSelector1(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
        fInterval: f32,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleSelector1(self, pfnSelector, pTarget, fInterval, bPaused)
    }
    #[inline]
    pub unsafe fn scheduleUpdateForTarget(
        &mut self,
        pTarget: *mut cocos2d_CCObject,
        nPriority: ::std::os::raw::c_int,
        bPaused: bool,
    ) {
        cocos2d_CCScheduler_scheduleUpdateForTarget(self, pTarget, nPriority, bPaused)
    }
    #[inline]
    pub unsafe fn unscheduleSelector(
        &mut self,
        pfnSelector: cocos2d_SEL_SCHEDULE,
        pTarget: *mut cocos2d_CCObject,
    ) {
        cocos2d_CCScheduler_unscheduleSelector(self, pfnSelector, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleUpdateForTarget(&mut self, pTarget: *const cocos2d_CCObject) {
        cocos2d_CCScheduler_unscheduleUpdateForTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleAllForTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_unscheduleAllForTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn unscheduleAll(&mut self) {
        cocos2d_CCScheduler_unscheduleAll(self)
    }
    #[inline]
    pub unsafe fn unscheduleAllWithMinPriority(&mut self, nMinPriority: ::std::os::raw::c_int) {
        cocos2d_CCScheduler_unscheduleAllWithMinPriority(self, nMinPriority)
    }
    #[inline]
    pub unsafe fn scheduleScriptFunc(
        &mut self,
        nHandler: ::std::os::raw::c_uint,
        fInterval: f32,
        bPaused: bool,
    ) -> ::std::os::raw::c_uint {
        cocos2d_CCScheduler_scheduleScriptFunc(self, nHandler, fInterval, bPaused)
    }
    #[inline]
    pub unsafe fn unscheduleScriptEntry(&mut self, uScheduleScriptEntryID: ::std::os::raw::c_uint) {
        cocos2d_CCScheduler_unscheduleScriptEntry(self, uScheduleScriptEntryID)
    }
    #[inline]
    pub unsafe fn pauseTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_pauseTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn resumeTarget(&mut self, pTarget: *mut cocos2d_CCObject) {
        cocos2d_CCScheduler_resumeTarget(self, pTarget)
    }
    #[inline]
    pub unsafe fn isTargetPaused(&mut self, pTarget: *mut cocos2d_CCObject) -> bool {
        cocos2d_CCScheduler_isTargetPaused(self, pTarget)
    }
    #[inline]
    pub unsafe fn pauseAllTargets(&mut self) -> *mut cocos2d_CCSet {
        cocos2d_CCScheduler_pauseAllTargets(self)
    }
    #[inline]
    pub unsafe fn pauseAllTargetsWithMinPriority(
        &mut self,
        nMinPriority: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCSet {
        cocos2d_CCScheduler_pauseAllTargetsWithMinPriority(self, nMinPriority)
    }
    #[inline]
    pub unsafe fn resumeTargets(&mut self, targetsToResume: *mut cocos2d_CCSet) {
        cocos2d_CCScheduler_resumeTargets(self, targetsToResume)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCScheduler_CCScheduler(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCScheduler@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCScheduler_CCScheduler_destructor(this: *mut cocos2d_CCScheduler);
}
extern "thiscall" {
    #[doc = " 'update' the scheduler.\n  You should NEVER call this method, unless you know what you are doing.\n  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?update@CCScheduler@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCScheduler_update(this: *mut ::std::os::raw::c_void, dt: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCComponent {
    pub _base: cocos2d_CCObject,
    pub m_pOwner: *mut cocos2d_CCNode,
    pub m_strName: std_string,
    pub m_bEnabled: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCComponent() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCComponent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCComponent>(),
        84usize,
        concat!("Size of: ", stringify!(cocos2d_CCComponent))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCComponent>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCComponent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOwner) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_pOwner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_strName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_strName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bEnabled) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponent),
            "::",
            stringify!(m_bEnabled)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?create@CCComponent@cocos2d@@SAPAV12@XZ"]
    pub fn cocos2d_CCComponent_create() -> *mut cocos2d_CCComponent;
}
extern "thiscall" {
    #[link_name = "\u{1}?getName@CCComponent@cocos2d@@QBEPBDXZ"]
    pub fn cocos2d_CCComponent_getName(
        this: *const cocos2d_CCComponent,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?setName@CCComponent@cocos2d@@QAEXPBD@Z"]
    pub fn cocos2d_CCComponent_setName(
        this: *mut cocos2d_CCComponent,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setOwner@CCComponent@cocos2d@@QAEXPAVCCNode@2@@Z"]
    pub fn cocos2d_CCComponent_setOwner(
        this: *mut cocos2d_CCComponent,
        pOwner: *mut cocos2d_CCNode,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?getOwner@CCComponent@cocos2d@@QBEPAVCCNode@2@XZ"]
    pub fn cocos2d_CCComponent_getOwner(this: *const cocos2d_CCComponent) -> *mut cocos2d_CCNode;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCComponent@cocos2d@@IAE@XZ"]
    pub fn cocos2d_CCComponent_CCComponent(this: *mut cocos2d_CCComponent);
}
impl cocos2d_CCComponent {
    #[inline]
    pub unsafe fn create() -> *mut cocos2d_CCComponent {
        cocos2d_CCComponent_create()
    }
    #[inline]
    pub unsafe fn getName(&self) -> *const ::std::os::raw::c_char {
        cocos2d_CCComponent_getName(self)
    }
    #[inline]
    pub unsafe fn setName(&mut self, pName: *const ::std::os::raw::c_char) {
        cocos2d_CCComponent_setName(self, pName)
    }
    #[inline]
    pub unsafe fn setOwner(&mut self, pOwner: *mut cocos2d_CCNode) {
        cocos2d_CCComponent_setOwner(self, pOwner)
    }
    #[inline]
    pub unsafe fn getOwner(&self) -> *mut cocos2d_CCNode {
        cocos2d_CCComponent_getOwner(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCComponent_CCComponent(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}??1CCComponent@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCComponent_CCComponent_destructor(this: *mut cocos2d_CCComponent);
}
extern "thiscall" {
    #[link_name = "\u{1}?init@CCComponent@cocos2d@@UAE_NXZ"]
    pub fn cocos2d_CCComponent_init(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onEnter@CCComponent@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCComponent_onEnter(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[doc = "  @js NA\n  @lua NA"]
    #[link_name = "\u{1}?onExit@CCComponent@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCComponent_onExit(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?update@CCComponent@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCComponent_update(this: *mut ::std::os::raw::c_void, delta: f32);
}
extern "thiscall" {
    #[link_name = "\u{1}?serialize@CCComponent@cocos2d@@UAE_NPAX@Z"]
    pub fn cocos2d_CCComponent_serialize(
        this: *mut ::std::os::raw::c_void,
        r: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?isEnabled@CCComponent@cocos2d@@UBE_NXZ"]
    pub fn cocos2d_CCComponent_isEnabled(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?setEnabled@CCComponent@cocos2d@@UAEX_N@Z"]
    pub fn cocos2d_CCComponent_setEnabled(this: *mut ::std::os::raw::c_void, b: bool);
}
#[repr(C)]
pub struct cocos2d_CCComponentContainer__bindgen_vtable(::std::os::raw::c_void);
#[doc = "  @js NA\n  @lua NA"]
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCComponentContainer {
    pub vtable_: *const cocos2d_CCComponentContainer__bindgen_vtable,
    #[doc = "< Dictionary of components"]
    pub m_pComponents: *mut cocos2d_CCDictionary,
    pub m_pOwner: *mut cocos2d_CCNode,
}
#[test]
fn bindgen_test_layout_cocos2d_CCComponentContainer() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCComponentContainer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCComponentContainer>(),
        12usize,
        concat!("Size of: ", stringify!(cocos2d_CCComponentContainer))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCComponentContainer>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCComponentContainer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pComponents) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponentContainer),
            "::",
            stringify!(m_pComponents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pOwner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCComponentContainer),
            "::",
            stringify!(m_pOwner)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?isEmpty@CCComponentContainer@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCComponentContainer_isEmpty(this: *const cocos2d_CCComponentContainer) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCComponentContainer@cocos2d@@IAE@PAVCCNode@1@@Z"]
    pub fn cocos2d_CCComponentContainer_CCComponentContainer(
        this: *mut cocos2d_CCComponentContainer,
        pNode: *mut cocos2d_CCNode,
    );
}
impl cocos2d_CCComponentContainer {
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        cocos2d_CCComponentContainer_isEmpty(self)
    }
    #[inline]
    pub unsafe fn new(pNode: *mut cocos2d_CCNode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCComponentContainer_CCComponentContainer(__bindgen_tmp.as_mut_ptr(), pNode);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCComponentContainer@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCComponentContainer_CCComponentContainer_destructor(
        this: *mut cocos2d_CCComponentContainer,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?get@CCComponentContainer@cocos2d@@UBEPAVCCComponent@2@PBD@Z"]
    pub fn cocos2d_CCComponentContainer_get(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCComponent;
}
extern "thiscall" {
    #[link_name = "\u{1}?add@CCComponentContainer@cocos2d@@UAE_NPAVCCComponent@2@@Z"]
    pub fn cocos2d_CCComponentContainer_add(
        this: *mut ::std::os::raw::c_void,
        pCom: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove@CCComponentContainer@cocos2d@@UAE_NPBD@Z"]
    pub fn cocos2d_CCComponentContainer_remove(
        this: *mut ::std::os::raw::c_void,
        pName: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove@CCComponentContainer@cocos2d@@UAE_NPAVCCComponent@2@@Z"]
    pub fn cocos2d_CCComponentContainer_remove1(
        this: *mut ::std::os::raw::c_void,
        pCom: *mut cocos2d_CCComponent,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAll@CCComponentContainer@cocos2d@@UAEXXZ"]
    pub fn cocos2d_CCComponentContainer_removeAll(this: *mut ::std::os::raw::c_void);
}
extern "thiscall" {
    #[link_name = "\u{1}?visit@CCComponentContainer@cocos2d@@UAEXM@Z"]
    pub fn cocos2d_CCComponentContainer_visit(this: *mut ::std::os::raw::c_void, fDelta: f32);
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCKeyboardDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
    pub m_bUnknown24: bool,
    pub m_bUnknown25: bool,
    pub pad47: [::std::os::raw::c_char; 2usize],
    pub m_pUnknown28: *mut cocos2d_ccCArray,
    pub m_pUnknown2c: *mut cocos2d_ccCArray,
    pub m_bShiftPressed: bool,
    pub m_bControlPressed: bool,
    pub m_bAltPressed: bool,
    pub m_bCommandPressed: bool,
}
#[test]
fn bindgen_test_layout_cocos2d_CCKeyboardDispatcher() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCKeyboardDispatcher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCKeyboardDispatcher>(),
        72usize,
        concat!("Size of: ", stringify!(cocos2d_CCKeyboardDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCKeyboardDispatcher>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCKeyboardDispatcher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegates) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUnknown24) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bUnknown24)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bUnknown25) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bUnknown25)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad47) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(pad47)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUnknown28) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_pUnknown28)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUnknown2c) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_pUnknown2c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bShiftPressed) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bShiftPressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bControlPressed) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bControlPressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bAltPressed) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bAltPressed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_bCommandPressed) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCKeyboardDispatcher),
            "::",
            stringify!(m_bCommandPressed)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addDelegate@CCKeyboardDispatcher@cocos2d@@QAEXPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_addDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeDelegate@CCKeyboardDispatcher@cocos2d@@QAEXPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_removeDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceAddDelegate@CCKeyboardDispatcher@cocos2d@@QAEXPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCKeyboardDispatcher@cocos2d@@QAEXPAVCCKeyboardDelegate@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCKeyboardDispatcher,
        pDelegate: *mut cocos2d_CCKeyboardDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?convertKeyCode@CCKeyboardDispatcher@cocos2d@@QAE?AW4enumKeyCodes@2@W432@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_convertKeyCode(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
    ) -> cocos2d_enumKeyCodes;
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchKeyboardMSG@CCKeyboardDispatcher@cocos2d@@QAE_NW4enumKeyCodes@2@_N@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_dispatchKeyboardMSG(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
        arg1: bool,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getAltKeyPressed@CCKeyboardDispatcher@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getAltKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getCommandKeyPressed@CCKeyboardDispatcher@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getCommandKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getControlKeyPressed@CCKeyboardDispatcher@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getControlKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getShiftKeyPressed@CCKeyboardDispatcher@cocos2d@@QBE_NXZ"]
    pub fn cocos2d_CCKeyboardDispatcher_getShiftKeyPressed(
        this: *const cocos2d_CCKeyboardDispatcher,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?keyToString@CCKeyboardDispatcher@cocos2d@@QAEPBDW4enumKeyCodes@2@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_keyToString(
        this: *mut cocos2d_CCKeyboardDispatcher,
        key: cocos2d_enumKeyCodes,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}?updateModifierKeys@CCKeyboardDispatcher@cocos2d@@QAEX_N000@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_updateModifierKeys(
        this: *mut cocos2d_CCKeyboardDispatcher,
        shft: bool,
        ctrl: bool,
        alt: bool,
        cmd: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardDispatcher@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher(
        this: *mut cocos2d_CCKeyboardDispatcher,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCKeyboardDispatcher@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher1(
        this: *mut cocos2d_CCKeyboardDispatcher,
        arg1: *const cocos2d_CCKeyboardDispatcher,
    );
}
impl cocos2d_CCKeyboardDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCKeyboardDelegate) {
        cocos2d_CCKeyboardDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn convertKeyCode(&mut self, key: cocos2d_enumKeyCodes) -> cocos2d_enumKeyCodes {
        cocos2d_CCKeyboardDispatcher_convertKeyCode(self, key)
    }
    #[inline]
    pub unsafe fn dispatchKeyboardMSG(&mut self, key: cocos2d_enumKeyCodes, arg1: bool) -> bool {
        cocos2d_CCKeyboardDispatcher_dispatchKeyboardMSG(self, key, arg1)
    }
    #[inline]
    pub unsafe fn getAltKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getAltKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getCommandKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getCommandKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getControlKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getControlKeyPressed(self)
    }
    #[inline]
    pub unsafe fn getShiftKeyPressed(&self) -> bool {
        cocos2d_CCKeyboardDispatcher_getShiftKeyPressed(self)
    }
    #[inline]
    pub unsafe fn keyToString(
        &mut self,
        key: cocos2d_enumKeyCodes,
    ) -> *const ::std::os::raw::c_char {
        cocos2d_CCKeyboardDispatcher_keyToString(self, key)
    }
    #[inline]
    pub unsafe fn updateModifierKeys(&mut self, shft: bool, ctrl: bool, alt: bool, cmd: bool) {
        cocos2d_CCKeyboardDispatcher_updateModifierKeys(self, shft, ctrl, alt, cmd)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCKeyboardDispatcher) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCKeyboardDispatcher@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCKeyboardDispatcher_CCKeyboardDispatcher_destructor(
        this: *mut cocos2d_CCKeyboardDispatcher,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cocos2d_CCMouseDispatcher {
    pub _base: cocos2d_CCObject,
    pub m_pDelegates: *mut cocos2d_CCArray,
}
#[test]
fn bindgen_test_layout_cocos2d_CCMouseDispatcher() {
    const UNINIT: ::std::mem::MaybeUninit<cocos2d_CCMouseDispatcher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCMouseDispatcher>(),
        56usize,
        concat!("Size of: ", stringify!(cocos2d_CCMouseDispatcher))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCMouseDispatcher>(),
        4usize,
        concat!("Alignment of ", stringify!(cocos2d_CCMouseDispatcher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pDelegates) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cocos2d_CCMouseDispatcher),
            "::",
            stringify!(m_pDelegates)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addDelegate@CCMouseDispatcher@cocos2d@@QAEXPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_addDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?removeDelegate@CCMouseDispatcher@cocos2d@@QAEXPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_removeDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceAddDelegate@CCMouseDispatcher@cocos2d@@QAEXPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_forceAddDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?forceRemoveDelegate@CCMouseDispatcher@cocos2d@@QAEXPAVCCMouseDelegate@2@@Z"]
    pub fn cocos2d_CCMouseDispatcher_forceRemoveDelegate(
        this: *mut cocos2d_CCMouseDispatcher,
        pDelegate: *mut cocos2d_CCMouseDelegate,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?dispatchScrollMSG@CCMouseDispatcher@cocos2d@@QAE_NMM@Z"]
    pub fn cocos2d_CCMouseDispatcher_dispatchScrollMSG(
        this: *mut cocos2d_CCMouseDispatcher,
        x: f32,
        y: f32,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseDispatcher@cocos2d@@QAE@XZ"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher(this: *mut cocos2d_CCMouseDispatcher);
}
extern "thiscall" {
    #[link_name = "\u{1}??0CCMouseDispatcher@cocos2d@@QAE@ABV01@@Z"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher1(
        this: *mut cocos2d_CCMouseDispatcher,
        arg1: *const cocos2d_CCMouseDispatcher,
    );
}
impl cocos2d_CCMouseDispatcher {
    #[inline]
    pub unsafe fn addDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_addDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn removeDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_removeDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceAddDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_forceAddDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn forceRemoveDelegate(&mut self, pDelegate: *mut cocos2d_CCMouseDelegate) {
        cocos2d_CCMouseDispatcher_forceRemoveDelegate(self, pDelegate)
    }
    #[inline]
    pub unsafe fn dispatchScrollMSG(&mut self, x: f32, y: f32) -> bool {
        cocos2d_CCMouseDispatcher_dispatchScrollMSG(self, x, y)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDispatcher_CCMouseDispatcher(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const cocos2d_CCMouseDispatcher) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        cocos2d_CCMouseDispatcher_CCMouseDispatcher1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1CCMouseDispatcher@cocos2d@@UAE@XZ"]
    pub fn cocos2d_CCMouseDispatcher_CCMouseDispatcher_destructor(
        this: *mut cocos2d_CCMouseDispatcher,
    );
}
#[repr(C)]
pub struct cocos2d_CCSceneTransitionDelegate__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cocos2d_CCSceneTransitionDelegate {
    pub vtable_: *const cocos2d_CCSceneTransitionDelegate__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_cocos2d_CCSceneTransitionDelegate() {
    assert_eq!(
        ::std::mem::size_of::<cocos2d_CCSceneTransitionDelegate>(),
        4usize,
        concat!("Size of: ", stringify!(cocos2d_CCSceneTransitionDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<cocos2d_CCSceneTransitionDelegate>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cocos2d_CCSceneTransitionDelegate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}?cocos2dVersion@cocos2d@@YAPBDXZ"]
    pub fn cocos2d_cocos2dVersion() -> *const ::std::os::raw::c_char;
}
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type UINT_PTR = ::std::os::raw::c_uint;
pub type LONG_PTR = ::std::os::raw::c_long;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPCWSTR = *const WCHAR;
pub type LONGLONG = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
    const UNINIT: ::std::mem::MaybeUninit<HINSTANCE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HINSTANCE__>(),
        4usize,
        concat!("Size of: ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HINSTANCE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HINSTANCE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
    const UNINIT: ::std::mem::MaybeUninit<HWND__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWND__>(),
        4usize,
        concat!("Size of: ", stringify!(HWND__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWND__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWND__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWND__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HACCEL__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HACCEL__() {
    const UNINIT: ::std::mem::MaybeUninit<HACCEL__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HACCEL__>(),
        4usize,
        concat!("Size of: ", stringify!(HACCEL__))
    );
    assert_eq!(
        ::std::mem::align_of::<HACCEL__>(),
        4usize,
        concat!("Alignment of ", stringify!(HACCEL__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HACCEL__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type GLenum = ::std::os::raw::c_uint;
pub type GLbitfield = ::std::os::raw::c_uint;
pub type GLuint = ::std::os::raw::c_uint;
pub type GLint = ::std::os::raw::c_int;
pub type GLsizei = ::std::os::raw::c_int;
pub type GLshort = ::std::os::raw::c_short;
pub type GLubyte = ::std::os::raw::c_uchar;
pub type GLushort = ::std::os::raw::c_ushort;
pub type GLfloat = f32;
pub type GLclampf = f32;
pub type GLvoid = ::std::os::raw::c_void;
pub type GLchar = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmMat4 {
    pub mat: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_kmMat4() {
    const UNINIT: ::std::mem::MaybeUninit<kmMat4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<kmMat4>(),
        64usize,
        concat!("Size of: ", stringify!(kmMat4))
    );
    assert_eq!(
        ::std::mem::align_of::<kmMat4>(),
        4usize,
        concat!("Alignment of ", stringify!(kmMat4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmMat4),
            "::",
            stringify!(mat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_bucket {
    pub hh_head: *mut UT_hash_handle,
    pub count: ::std::os::raw::c_uint,
    pub expand_mult: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_UT_hash_bucket() {
    const UNINIT: ::std::mem::MaybeUninit<UT_hash_bucket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UT_hash_bucket>(),
        12usize,
        concat!("Size of: ", stringify!(UT_hash_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_bucket>(),
        4usize,
        concat!("Alignment of ", stringify!(UT_hash_bucket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh_head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(hh_head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expand_mult) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_bucket),
            "::",
            stringify!(expand_mult)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_table {
    pub buckets: *mut UT_hash_bucket,
    pub num_buckets: ::std::os::raw::c_uint,
    pub log2_num_buckets: ::std::os::raw::c_uint,
    pub num_items: ::std::os::raw::c_uint,
    pub tail: *mut UT_hash_handle,
    pub hho: isize,
    pub ideal_chain_maxlen: ::std::os::raw::c_uint,
    pub nonideal_items: ::std::os::raw::c_uint,
    pub ineff_expands: ::std::os::raw::c_uint,
    pub noexpand: ::std::os::raw::c_uint,
    pub signature: u32,
}
#[test]
fn bindgen_test_layout_UT_hash_table() {
    const UNINIT: ::std::mem::MaybeUninit<UT_hash_table> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UT_hash_table>(),
        44usize,
        concat!("Size of: ", stringify!(UT_hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_table>(),
        4usize,
        concat!("Alignment of ", stringify!(UT_hash_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buckets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(buckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_buckets) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(num_buckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_num_buckets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(log2_num_buckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_items) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(num_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hho) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(hho)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ideal_chain_maxlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(ideal_chain_maxlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonideal_items) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(nonideal_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ineff_expands) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(ineff_expands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noexpand) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(noexpand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_table),
            "::",
            stringify!(signature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UT_hash_handle {
    pub tbl: *mut UT_hash_table,
    pub prev: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub hh_prev: *mut UT_hash_handle,
    pub hh_next: *mut UT_hash_handle,
    pub key: *mut ::std::os::raw::c_void,
    pub keylen: ::std::os::raw::c_uint,
    pub hashv: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_UT_hash_handle() {
    const UNINIT: ::std::mem::MaybeUninit<UT_hash_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<UT_hash_handle>(),
        32usize,
        concat!("Size of: ", stringify!(UT_hash_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<UT_hash_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(UT_hash_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tbl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh_prev) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hh_prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hh_next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hh_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashv) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UT_hash_handle),
            "::",
            stringify!(hashv)
        )
    );
}
pub const ResolutionPolicy_kResolutionExactFit: ResolutionPolicy = 0;
pub const ResolutionPolicy_kResolutionNoBorder: ResolutionPolicy = 1;
pub const ResolutionPolicy_kResolutionShowAll: ResolutionPolicy = 2;
pub const ResolutionPolicy_kResolutionFixedHeight: ResolutionPolicy = 3;
pub const ResolutionPolicy_kResolutionFixedWidth: ResolutionPolicy = 4;
pub const ResolutionPolicy_kResolutionUnKnown: ResolutionPolicy = 5;
pub type ResolutionPolicy = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWmonitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWwindow {
    _unused: [u8; 0],
}
pub type pugi_char_t = ::std::os::raw::c_char;
pub type pugi_string_t = [u32; 6usize];
pub const pugi_xml_node_type_node_null: pugi_xml_node_type = 0;
pub const pugi_xml_node_type_node_document: pugi_xml_node_type = 1;
pub const pugi_xml_node_type_node_element: pugi_xml_node_type = 2;
pub const pugi_xml_node_type_node_pcdata: pugi_xml_node_type = 3;
pub const pugi_xml_node_type_node_cdata: pugi_xml_node_type = 4;
pub const pugi_xml_node_type_node_comment: pugi_xml_node_type = 5;
pub const pugi_xml_node_type_node_pi: pugi_xml_node_type = 6;
pub const pugi_xml_node_type_node_declaration: pugi_xml_node_type = 7;
pub const pugi_xml_node_type_node_doctype: pugi_xml_node_type = 8;
pub type pugi_xml_node_type = ::std::os::raw::c_int;
pub const pugi_xml_encoding_encoding_auto: pugi_xml_encoding = 0;
pub const pugi_xml_encoding_encoding_utf8: pugi_xml_encoding = 1;
pub const pugi_xml_encoding_encoding_utf16_le: pugi_xml_encoding = 2;
pub const pugi_xml_encoding_encoding_utf16_be: pugi_xml_encoding = 3;
pub const pugi_xml_encoding_encoding_utf16: pugi_xml_encoding = 4;
pub const pugi_xml_encoding_encoding_utf32_le: pugi_xml_encoding = 5;
pub const pugi_xml_encoding_encoding_utf32_be: pugi_xml_encoding = 6;
pub const pugi_xml_encoding_encoding_utf32: pugi_xml_encoding = 7;
pub const pugi_xml_encoding_encoding_wchar: pugi_xml_encoding = 8;
pub const pugi_xml_encoding_encoding_latin1: pugi_xml_encoding = 9;
pub type pugi_xml_encoding = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_object_range<It> {
    pub _begin: It,
    pub _end: It,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<It>>,
}
pub type pugi_xml_object_range_const_iterator<It> = It;
#[repr(C)]
pub struct pugi_xml_writer__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_writer {
    pub vtable_: *const pugi_xml_writer__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_pugi_xml_writer() {
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_writer>(),
        4usize,
        concat!("Size of: ", stringify!(pugi_xml_writer))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_writer>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_writer))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute {
    pub _attr: *mut pugi_xml_attribute_struct,
}
pub type pugi_xml_attribute_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_attribute)>;
#[test]
fn bindgen_test_layout_pugi_xml_attribute() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_attribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_attribute>(),
        4usize,
        concat!("Size of: ", stringify!(pugi_xml_attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_attribute>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_attribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute),
            "::",
            stringify!(_attr)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?empty@xml_attribute@pugi@@QBE_NXZ"]
    pub fn pugi_xml_attribute_empty(this: *const pugi_xml_attribute) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?name@xml_attribute@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_attribute_name(this: *const pugi_xml_attribute) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?value@xml_attribute@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_attribute_value(this: *const pugi_xml_attribute) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_string@xml_attribute@pugi@@QBEPBDPBD@Z"]
    pub fn pugi_xml_attribute_as_string(
        this: *const pugi_xml_attribute,
        def: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_int@xml_attribute@pugi@@QBEHH@Z"]
    pub fn pugi_xml_attribute_as_int(
        this: *const pugi_xml_attribute,
        def: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_uint@xml_attribute@pugi@@QBEII@Z"]
    pub fn pugi_xml_attribute_as_uint(
        this: *const pugi_xml_attribute,
        def: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_double@xml_attribute@pugi@@QBENN@Z"]
    pub fn pugi_xml_attribute_as_double(this: *const pugi_xml_attribute, def: f64) -> f64;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_float@xml_attribute@pugi@@QBEMM@Z"]
    pub fn pugi_xml_attribute_as_float(this: *const pugi_xml_attribute, def: f32) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_bool@xml_attribute@pugi@@QBE_N_N@Z"]
    pub fn pugi_xml_attribute_as_bool(this: *const pugi_xml_attribute, def: bool) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_name@xml_attribute@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_attribute_set_name(
        this: *mut pugi_xml_attribute,
        rhs: *const pugi_char_t,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_attribute_set_value(
        this: *mut pugi_xml_attribute,
        rhs: *const pugi_char_t,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QAE_NH@Z"]
    pub fn pugi_xml_attribute_set_value1(
        this: *mut pugi_xml_attribute,
        rhs: ::std::os::raw::c_int,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QAE_NI@Z"]
    pub fn pugi_xml_attribute_set_value2(
        this: *mut pugi_xml_attribute,
        rhs: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QAE_NN@Z"]
    pub fn pugi_xml_attribute_set_value3(this: *mut pugi_xml_attribute, rhs: f64) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_attribute@pugi@@QAE_N_N@Z"]
    pub fn pugi_xml_attribute_set_value4(this: *mut pugi_xml_attribute, rhs: bool) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?next_attribute@xml_attribute@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_attribute_next_attribute(this: *const pugi_xml_attribute)
        -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?previous_attribute@xml_attribute@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_attribute_previous_attribute(
        this: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?hash_value@xml_attribute@pugi@@QBEIXZ"]
    pub fn pugi_xml_attribute_hash_value(this: *const pugi_xml_attribute) -> usize;
}
extern "thiscall" {
    #[link_name = "\u{1}?internal_object@xml_attribute@pugi@@QBEPAUxml_attribute_struct@2@XZ"]
    pub fn pugi_xml_attribute_internal_object(
        this: *const pugi_xml_attribute,
    ) -> *mut pugi_xml_attribute_struct;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_attribute@pugi@@QAE@XZ"]
    pub fn pugi_xml_attribute_xml_attribute(this: *mut pugi_xml_attribute);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_attribute@pugi@@QAE@PAUxml_attribute_struct@1@@Z"]
    pub fn pugi_xml_attribute_xml_attribute1(
        this: *mut pugi_xml_attribute,
        attr: *mut pugi_xml_attribute_struct,
    );
}
impl pugi_xml_attribute {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_attribute_empty(self)
    }
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xml_attribute_name(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> *const pugi_char_t {
        pugi_xml_attribute_value(self)
    }
    #[inline]
    pub unsafe fn as_string(&self, def: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_attribute_as_string(self, def)
    }
    #[inline]
    pub unsafe fn as_int(&self, def: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        pugi_xml_attribute_as_int(self, def)
    }
    #[inline]
    pub unsafe fn as_uint(&self, def: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        pugi_xml_attribute_as_uint(self, def)
    }
    #[inline]
    pub unsafe fn as_double(&self, def: f64) -> f64 {
        pugi_xml_attribute_as_double(self, def)
    }
    #[inline]
    pub unsafe fn as_float(&self, def: f32) -> f32 {
        pugi_xml_attribute_as_float(self, def)
    }
    #[inline]
    pub unsafe fn as_bool(&self, def: bool) -> bool {
        pugi_xml_attribute_as_bool(self, def)
    }
    #[inline]
    pub unsafe fn set_name(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_attribute_set_name(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_attribute_set_value(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value1(&mut self, rhs: ::std::os::raw::c_int) -> bool {
        pugi_xml_attribute_set_value1(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value2(&mut self, rhs: ::std::os::raw::c_uint) -> bool {
        pugi_xml_attribute_set_value2(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value3(&mut self, rhs: f64) -> bool {
        pugi_xml_attribute_set_value3(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value4(&mut self, rhs: bool) -> bool {
        pugi_xml_attribute_set_value4(self, rhs)
    }
    #[inline]
    pub unsafe fn next_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_attribute_next_attribute(self)
    }
    #[inline]
    pub unsafe fn previous_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_attribute_previous_attribute(self)
    }
    #[inline]
    pub unsafe fn hash_value(&self) -> usize {
        pugi_xml_attribute_hash_value(self)
    }
    #[inline]
    pub unsafe fn internal_object(&self) -> *mut pugi_xml_attribute_struct {
        pugi_xml_attribute_internal_object(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_xml_attribute(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(attr: *mut pugi_xml_attribute_struct) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_xml_attribute1(__bindgen_tmp.as_mut_ptr(), attr);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node {
    pub _root: *mut pugi_xml_node_struct,
}
pub type pugi_xml_node_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_node)>;
pub type pugi_xml_node_attribute_iterator = pugi_xml_attribute_iterator;
#[test]
fn bindgen_test_layout_pugi_xml_node() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_node>(),
        4usize,
        concat!("Size of: ", stringify!(pugi_xml_node))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_node>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node),
            "::",
            stringify!(_root)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?empty@xml_node@pugi@@QBE_NXZ"]
    pub fn pugi_xml_node_empty(this: *const pugi_xml_node) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?type@xml_node@pugi@@QBE?AW4xml_node_type@2@XZ"]
    pub fn pugi_xml_node_type(this: *const pugi_xml_node) -> pugi_xml_node_type;
}
extern "thiscall" {
    #[link_name = "\u{1}?name@xml_node@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_node_name(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?value@xml_node@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_node_value(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?first_attribute@xml_node@pugi@@QBE?AVxml_attribute@2@XZ"]
    pub fn pugi_xml_node_first_attribute(this: *const pugi_xml_node) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?last_attribute@xml_node@pugi@@QBE?AVxml_attribute@2@XZ"]
    pub fn pugi_xml_node_last_attribute(this: *const pugi_xml_node) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?first_child@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_first_child(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?last_child@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_last_child(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?next_sibling@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_next_sibling(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?previous_sibling@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_previous_sibling(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?parent@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_parent(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?root@xml_node@pugi@@QBE?AV12@XZ"]
    pub fn pugi_xml_node_root(this: *const pugi_xml_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?text@xml_node@pugi@@QBE?AVxml_text@2@XZ"]
    pub fn pugi_xml_node_text(this: *const pugi_xml_node) -> pugi_xml_text;
}
extern "thiscall" {
    #[link_name = "\u{1}?child@xml_node@pugi@@QBE?AV12@PBD@Z"]
    pub fn pugi_xml_node_child(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?attribute@xml_node@pugi@@QBE?AVxml_attribute@2@PBD@Z"]
    pub fn pugi_xml_node_attribute(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?next_sibling@xml_node@pugi@@QBE?AV12@PBD@Z"]
    pub fn pugi_xml_node_next_sibling1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?previous_sibling@xml_node@pugi@@QBE?AV12@PBD@Z"]
    pub fn pugi_xml_node_previous_sibling1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?child_value@xml_node@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_node_child_value(this: *const pugi_xml_node) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?child_value@xml_node@pugi@@QBEPBDPBD@Z"]
    pub fn pugi_xml_node_child_value1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_name@xml_node@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_node_set_name(this: *mut pugi_xml_node, rhs: *const pugi_char_t) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set_value@xml_node@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_node_set_value(this: *mut pugi_xml_node, rhs: *const pugi_char_t) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?append_attribute@xml_node@pugi@@QAE?AVxml_attribute@2@PBD@Z"]
    pub fn pugi_xml_node_append_attribute(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?prepend_attribute@xml_node@pugi@@QAE?AVxml_attribute@2@PBD@Z"]
    pub fn pugi_xml_node_prepend_attribute(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_attribute_after@xml_node@pugi@@QAE?AVxml_attribute@2@PBDABV32@@Z"]
    pub fn pugi_xml_node_insert_attribute_after(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_attribute_before@xml_node@pugi@@QAE?AVxml_attribute@2@PBDABV32@@Z"]
    pub fn pugi_xml_node_insert_attribute_before(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?append_copy@xml_node@pugi@@QAE?AVxml_attribute@2@ABV32@@Z"]
    pub fn pugi_xml_node_append_copy(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?prepend_copy@xml_node@pugi@@QAE?AVxml_attribute@2@ABV32@@Z"]
    pub fn pugi_xml_node_prepend_copy(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_copy_after@xml_node@pugi@@QAE?AVxml_attribute@2@ABV32@0@Z"]
    pub fn pugi_xml_node_insert_copy_after(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_copy_before@xml_node@pugi@@QAE?AVxml_attribute@2@ABV32@0@Z"]
    pub fn pugi_xml_node_insert_copy_before(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?append_child@xml_node@pugi@@QAE?AV12@W4xml_node_type@2@@Z"]
    pub fn pugi_xml_node_append_child(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?prepend_child@xml_node@pugi@@QAE?AV12@W4xml_node_type@2@@Z"]
    pub fn pugi_xml_node_prepend_child(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_child_after@xml_node@pugi@@QAE?AV12@W4xml_node_type@2@ABV12@@Z"]
    pub fn pugi_xml_node_insert_child_after(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_child_before@xml_node@pugi@@QAE?AV12@W4xml_node_type@2@ABV12@@Z"]
    pub fn pugi_xml_node_insert_child_before(
        this: *mut pugi_xml_node,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?append_child@xml_node@pugi@@QAE?AV12@PBD@Z"]
    pub fn pugi_xml_node_append_child1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?prepend_child@xml_node@pugi@@QAE?AV12@PBD@Z"]
    pub fn pugi_xml_node_prepend_child1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_child_after@xml_node@pugi@@QAE?AV12@PBDABV12@@Z"]
    pub fn pugi_xml_node_insert_child_after1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_child_before@xml_node@pugi@@QAE?AV12@PBDABV12@@Z"]
    pub fn pugi_xml_node_insert_child_before1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?append_copy@xml_node@pugi@@QAE?AV12@ABV12@@Z"]
    pub fn pugi_xml_node_append_copy1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?prepend_copy@xml_node@pugi@@QAE?AV12@ABV12@@Z"]
    pub fn pugi_xml_node_prepend_copy1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_copy_after@xml_node@pugi@@QAE?AV12@ABV12@0@Z"]
    pub fn pugi_xml_node_insert_copy_after1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?insert_copy_before@xml_node@pugi@@QAE?AV12@ABV12@0@Z"]
    pub fn pugi_xml_node_insert_copy_before1(
        this: *mut pugi_xml_node,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove_attribute@xml_node@pugi@@QAE_NABVxml_attribute@2@@Z"]
    pub fn pugi_xml_node_remove_attribute(
        this: *mut pugi_xml_node,
        a: *const pugi_xml_attribute,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove_attribute@xml_node@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_node_remove_attribute1(
        this: *mut pugi_xml_node,
        name: *const pugi_char_t,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove_child@xml_node@pugi@@QAE_NABV12@@Z"]
    pub fn pugi_xml_node_remove_child(this: *mut pugi_xml_node, n: *const pugi_xml_node) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?remove_child@xml_node@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_node_remove_child1(this: *mut pugi_xml_node, name: *const pugi_char_t) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?find_child_by_attribute@xml_node@pugi@@QBE?AV12@PBD00@Z"]
    pub fn pugi_xml_node_find_child_by_attribute(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?find_child_by_attribute@xml_node@pugi@@QBE?AV12@PBD0@Z"]
    pub fn pugi_xml_node_find_child_by_attribute1(
        this: *const pugi_xml_node,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?path@xml_node@pugi@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@D@Z"]
    pub fn pugi_xml_node_path(this: *const pugi_xml_node, delimiter: pugi_char_t) -> pugi_string_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?first_element_by_path@xml_node@pugi@@QBE?AV12@PBDD@Z"]
    pub fn pugi_xml_node_first_element_by_path(
        this: *const pugi_xml_node,
        path: *const pugi_char_t,
        delimiter: pugi_char_t,
    ) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?traverse@xml_node@pugi@@QAE_NAAVxml_tree_walker@2@@Z"]
    pub fn pugi_xml_node_traverse(
        this: *mut pugi_xml_node,
        walker: *mut pugi_xml_tree_walker,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?select_single_node@xml_node@pugi@@QBE?AVxpath_node@2@PBDPAVxpath_variable_set@2@@Z"]
    pub fn pugi_xml_node_select_single_node(
        this: *const pugi_xml_node,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?select_single_node@xml_node@pugi@@QBE?AVxpath_node@2@ABVxpath_query@2@@Z"]
    pub fn pugi_xml_node_select_single_node1(
        this: *const pugi_xml_node,
        query: *const pugi_xpath_query,
    ) -> pugi_xpath_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?select_nodes@xml_node@pugi@@QBE?AVxpath_node_set@2@PBDPAVxpath_variable_set@2@@Z"]
    pub fn pugi_xml_node_select_nodes(
        this: *const pugi_xml_node,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node_set;
}
extern "thiscall" {
    #[link_name = "\u{1}?select_nodes@xml_node@pugi@@QBE?AVxpath_node_set@2@ABVxpath_query@2@@Z"]
    pub fn pugi_xml_node_select_nodes1(
        this: *const pugi_xml_node,
        query: *const pugi_xpath_query,
    ) -> pugi_xpath_node_set;
}
extern "thiscall" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QBEXAAVxml_writer@2@PBDIW4xml_encoding@2@I@Z"]
    pub fn pugi_xml_node_print(
        this: *const pugi_xml_node,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QBEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDIW4xml_encoding@2@I@Z"]
    pub fn pugi_xml_node_print1(
        this: *const pugi_xml_node,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?print@xml_node@pugi@@QBEXAAV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@PBDII@Z"]
    pub fn pugi_xml_node_print2(
        this: *const pugi_xml_node,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?begin@xml_node@pugi@@QBE?AVxml_node_iterator@2@XZ"]
    pub fn pugi_xml_node_begin(this: *const pugi_xml_node) -> pugi_xml_node_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?end@xml_node@pugi@@QBE?AVxml_node_iterator@2@XZ"]
    pub fn pugi_xml_node_end(this: *const pugi_xml_node) -> pugi_xml_node_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?attributes_begin@xml_node@pugi@@QBE?AVxml_attribute_iterator@2@XZ"]
    pub fn pugi_xml_node_attributes_begin(
        this: *const pugi_xml_node,
    ) -> pugi_xml_node_attribute_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?attributes_end@xml_node@pugi@@QBE?AVxml_attribute_iterator@2@XZ"]
    pub fn pugi_xml_node_attributes_end(
        this: *const pugi_xml_node,
    ) -> pugi_xml_node_attribute_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?children@xml_node@pugi@@QBE?AV?$xml_object_range@Vxml_node_iterator@pugi@@@2@XZ"]
    pub fn pugi_xml_node_children(
        this: *const pugi_xml_node,
    ) -> pugi_xml_object_range<pugi_xml_node_iterator>;
}
extern "thiscall" {
    #[link_name = "\u{1}?children@xml_node@pugi@@QBE?AV?$xml_object_range@Vxml_named_node_iterator@pugi@@@2@PBD@Z"]
    pub fn pugi_xml_node_children1(
        this: *const pugi_xml_node,
        name: *const pugi_char_t,
    ) -> pugi_xml_object_range<pugi_xml_named_node_iterator>;
}
extern "thiscall" {
    #[link_name = "\u{1}?attributes@xml_node@pugi@@QBE?AV?$xml_object_range@Vxml_attribute_iterator@pugi@@@2@XZ"]
    pub fn pugi_xml_node_attributes(
        this: *const pugi_xml_node,
    ) -> pugi_xml_object_range<pugi_xml_attribute_iterator>;
}
extern "thiscall" {
    #[link_name = "\u{1}?offset_debug@xml_node@pugi@@QBEHXZ"]
    pub fn pugi_xml_node_offset_debug(this: *const pugi_xml_node) -> isize;
}
extern "thiscall" {
    #[link_name = "\u{1}?hash_value@xml_node@pugi@@QBEIXZ"]
    pub fn pugi_xml_node_hash_value(this: *const pugi_xml_node) -> usize;
}
extern "thiscall" {
    #[link_name = "\u{1}?internal_object@xml_node@pugi@@QBEPAUxml_node_struct@2@XZ"]
    pub fn pugi_xml_node_internal_object(this: *const pugi_xml_node) -> *mut pugi_xml_node_struct;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_node@pugi@@QAE@XZ"]
    pub fn pugi_xml_node_xml_node(this: *mut pugi_xml_node);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_node@pugi@@QAE@PAUxml_node_struct@1@@Z"]
    pub fn pugi_xml_node_xml_node1(this: *mut pugi_xml_node, p: *mut pugi_xml_node_struct);
}
impl pugi_xml_node {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_node_empty(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xml_node_type {
        pugi_xml_node_type(self)
    }
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xml_node_name(self)
    }
    #[inline]
    pub unsafe fn value(&self) -> *const pugi_char_t {
        pugi_xml_node_value(self)
    }
    #[inline]
    pub unsafe fn first_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_node_first_attribute(self)
    }
    #[inline]
    pub unsafe fn last_attribute(&self) -> pugi_xml_attribute {
        pugi_xml_node_last_attribute(self)
    }
    #[inline]
    pub unsafe fn first_child(&self) -> pugi_xml_node {
        pugi_xml_node_first_child(self)
    }
    #[inline]
    pub unsafe fn last_child(&self) -> pugi_xml_node {
        pugi_xml_node_last_child(self)
    }
    #[inline]
    pub unsafe fn next_sibling(&self) -> pugi_xml_node {
        pugi_xml_node_next_sibling(self)
    }
    #[inline]
    pub unsafe fn previous_sibling(&self) -> pugi_xml_node {
        pugi_xml_node_previous_sibling(self)
    }
    #[inline]
    pub unsafe fn parent(&self) -> pugi_xml_node {
        pugi_xml_node_parent(self)
    }
    #[inline]
    pub unsafe fn root(&self) -> pugi_xml_node {
        pugi_xml_node_root(self)
    }
    #[inline]
    pub unsafe fn text(&self) -> pugi_xml_text {
        pugi_xml_node_text(self)
    }
    #[inline]
    pub unsafe fn child(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_child(self, name)
    }
    #[inline]
    pub unsafe fn attribute(&self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_attribute(self, name)
    }
    #[inline]
    pub unsafe fn next_sibling1(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_next_sibling1(self, name)
    }
    #[inline]
    pub unsafe fn previous_sibling1(&self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_previous_sibling1(self, name)
    }
    #[inline]
    pub unsafe fn child_value(&self) -> *const pugi_char_t {
        pugi_xml_node_child_value(self)
    }
    #[inline]
    pub unsafe fn child_value1(&self, name: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_node_child_value1(self, name)
    }
    #[inline]
    pub unsafe fn set_name(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_node_set_name(self, rhs)
    }
    #[inline]
    pub unsafe fn set_value(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_node_set_value(self, rhs)
    }
    #[inline]
    pub unsafe fn append_attribute(&mut self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_append_attribute(self, name)
    }
    #[inline]
    pub unsafe fn prepend_attribute(&mut self, name: *const pugi_char_t) -> pugi_xml_attribute {
        pugi_xml_node_prepend_attribute(self, name)
    }
    #[inline]
    pub unsafe fn insert_attribute_after(
        &mut self,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_attribute_after(self, name, attr)
    }
    #[inline]
    pub unsafe fn insert_attribute_before(
        &mut self,
        name: *const pugi_char_t,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_attribute_before(self, name, attr)
    }
    #[inline]
    pub unsafe fn append_copy(&mut self, proto: *const pugi_xml_attribute) -> pugi_xml_attribute {
        pugi_xml_node_append_copy(self, proto)
    }
    #[inline]
    pub unsafe fn prepend_copy(&mut self, proto: *const pugi_xml_attribute) -> pugi_xml_attribute {
        pugi_xml_node_prepend_copy(self, proto)
    }
    #[inline]
    pub unsafe fn insert_copy_after(
        &mut self,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_copy_after(self, proto, attr)
    }
    #[inline]
    pub unsafe fn insert_copy_before(
        &mut self,
        proto: *const pugi_xml_attribute,
        attr: *const pugi_xml_attribute,
    ) -> pugi_xml_attribute {
        pugi_xml_node_insert_copy_before(self, proto, attr)
    }
    #[inline]
    pub unsafe fn append_child(&mut self, type_: pugi_xml_node_type) -> pugi_xml_node {
        pugi_xml_node_append_child(self, type_)
    }
    #[inline]
    pub unsafe fn prepend_child(&mut self, type_: pugi_xml_node_type) -> pugi_xml_node {
        pugi_xml_node_prepend_child(self, type_)
    }
    #[inline]
    pub unsafe fn insert_child_after(
        &mut self,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_after(self, type_, node)
    }
    #[inline]
    pub unsafe fn insert_child_before(
        &mut self,
        type_: pugi_xml_node_type,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_before(self, type_, node)
    }
    #[inline]
    pub unsafe fn append_child1(&mut self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_append_child1(self, name)
    }
    #[inline]
    pub unsafe fn prepend_child1(&mut self, name: *const pugi_char_t) -> pugi_xml_node {
        pugi_xml_node_prepend_child1(self, name)
    }
    #[inline]
    pub unsafe fn insert_child_after1(
        &mut self,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_after1(self, name, node)
    }
    #[inline]
    pub unsafe fn insert_child_before1(
        &mut self,
        name: *const pugi_char_t,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_child_before1(self, name, node)
    }
    #[inline]
    pub unsafe fn append_copy1(&mut self, proto: *const pugi_xml_node) -> pugi_xml_node {
        pugi_xml_node_append_copy1(self, proto)
    }
    #[inline]
    pub unsafe fn prepend_copy1(&mut self, proto: *const pugi_xml_node) -> pugi_xml_node {
        pugi_xml_node_prepend_copy1(self, proto)
    }
    #[inline]
    pub unsafe fn insert_copy_after1(
        &mut self,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_copy_after1(self, proto, node)
    }
    #[inline]
    pub unsafe fn insert_copy_before1(
        &mut self,
        proto: *const pugi_xml_node,
        node: *const pugi_xml_node,
    ) -> pugi_xml_node {
        pugi_xml_node_insert_copy_before1(self, proto, node)
    }
    #[inline]
    pub unsafe fn remove_attribute(&mut self, a: *const pugi_xml_attribute) -> bool {
        pugi_xml_node_remove_attribute(self, a)
    }
    #[inline]
    pub unsafe fn remove_attribute1(&mut self, name: *const pugi_char_t) -> bool {
        pugi_xml_node_remove_attribute1(self, name)
    }
    #[inline]
    pub unsafe fn remove_child(&mut self, n: *const pugi_xml_node) -> bool {
        pugi_xml_node_remove_child(self, n)
    }
    #[inline]
    pub unsafe fn remove_child1(&mut self, name: *const pugi_char_t) -> bool {
        pugi_xml_node_remove_child1(self, name)
    }
    #[inline]
    pub unsafe fn find_child_by_attribute(
        &self,
        name: *const pugi_char_t,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_find_child_by_attribute(self, name, attr_name, attr_value)
    }
    #[inline]
    pub unsafe fn find_child_by_attribute1(
        &self,
        attr_name: *const pugi_char_t,
        attr_value: *const pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_find_child_by_attribute1(self, attr_name, attr_value)
    }
    #[inline]
    pub unsafe fn path(&self, delimiter: pugi_char_t) -> pugi_string_t {
        pugi_xml_node_path(self, delimiter)
    }
    #[inline]
    pub unsafe fn first_element_by_path(
        &self,
        path: *const pugi_char_t,
        delimiter: pugi_char_t,
    ) -> pugi_xml_node {
        pugi_xml_node_first_element_by_path(self, path, delimiter)
    }
    #[inline]
    pub unsafe fn traverse(&mut self, walker: *mut pugi_xml_tree_walker) -> bool {
        pugi_xml_node_traverse(self, walker)
    }
    #[inline]
    pub unsafe fn select_single_node(
        &self,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node {
        pugi_xml_node_select_single_node(self, query, variables)
    }
    #[inline]
    pub unsafe fn select_single_node1(&self, query: *const pugi_xpath_query) -> pugi_xpath_node {
        pugi_xml_node_select_single_node1(self, query)
    }
    #[inline]
    pub unsafe fn select_nodes(
        &self,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    ) -> pugi_xpath_node_set {
        pugi_xml_node_select_nodes(self, query, variables)
    }
    #[inline]
    pub unsafe fn select_nodes1(&self, query: *const pugi_xpath_query) -> pugi_xpath_node_set {
        pugi_xml_node_select_nodes1(self, query)
    }
    #[inline]
    pub unsafe fn print(
        &self,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print(self, writer, indent, flags, encoding, depth)
    }
    #[inline]
    pub unsafe fn print1(
        &self,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print1(self, os, indent, flags, encoding, depth)
    }
    #[inline]
    pub unsafe fn print2(
        &self,
        os: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        depth: ::std::os::raw::c_uint,
    ) {
        pugi_xml_node_print2(self, os, indent, flags, depth)
    }
    #[inline]
    pub unsafe fn begin(&self) -> pugi_xml_node_iterator {
        pugi_xml_node_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> pugi_xml_node_iterator {
        pugi_xml_node_end(self)
    }
    #[inline]
    pub unsafe fn attributes_begin(&self) -> pugi_xml_node_attribute_iterator {
        pugi_xml_node_attributes_begin(self)
    }
    #[inline]
    pub unsafe fn attributes_end(&self) -> pugi_xml_node_attribute_iterator {
        pugi_xml_node_attributes_end(self)
    }
    #[inline]
    pub unsafe fn children(&self) -> pugi_xml_object_range<pugi_xml_node_iterator> {
        pugi_xml_node_children(self)
    }
    #[inline]
    pub unsafe fn children1(
        &self,
        name: *const pugi_char_t,
    ) -> pugi_xml_object_range<pugi_xml_named_node_iterator> {
        pugi_xml_node_children1(self, name)
    }
    #[inline]
    pub unsafe fn attributes(&self) -> pugi_xml_object_range<pugi_xml_attribute_iterator> {
        pugi_xml_node_attributes(self)
    }
    #[inline]
    pub unsafe fn offset_debug(&self) -> isize {
        pugi_xml_node_offset_debug(self)
    }
    #[inline]
    pub unsafe fn hash_value(&self) -> usize {
        pugi_xml_node_hash_value(self)
    }
    #[inline]
    pub unsafe fn internal_object(&self) -> *mut pugi_xml_node_struct {
        pugi_xml_node_internal_object(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_xml_node(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(p: *mut pugi_xml_node_struct) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_xml_node1(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_text {
    pub _root: *mut pugi_xml_node_struct,
}
pub type pugi_xml_text_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xml_text)>;
#[test]
fn bindgen_test_layout_pugi_xml_text() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_text> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_text>(),
        4usize,
        concat!("Size of: ", stringify!(pugi_xml_text))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_text>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_text))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_text),
            "::",
            stringify!(_root)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?empty@xml_text@pugi@@QBE_NXZ"]
    pub fn pugi_xml_text_empty(this: *const pugi_xml_text) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?get@xml_text@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_text_get(this: *const pugi_xml_text) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_string@xml_text@pugi@@QBEPBDPBD@Z"]
    pub fn pugi_xml_text_as_string(
        this: *const pugi_xml_text,
        def: *const pugi_char_t,
    ) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_int@xml_text@pugi@@QBEHH@Z"]
    pub fn pugi_xml_text_as_int(
        this: *const pugi_xml_text,
        def: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_uint@xml_text@pugi@@QBEII@Z"]
    pub fn pugi_xml_text_as_uint(
        this: *const pugi_xml_text,
        def: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_double@xml_text@pugi@@QBENN@Z"]
    pub fn pugi_xml_text_as_double(this: *const pugi_xml_text, def: f64) -> f64;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_float@xml_text@pugi@@QBEMM@Z"]
    pub fn pugi_xml_text_as_float(this: *const pugi_xml_text, def: f32) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?as_bool@xml_text@pugi@@QBE_N_N@Z"]
    pub fn pugi_xml_text_as_bool(this: *const pugi_xml_text, def: bool) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xml_text_set(this: *mut pugi_xml_text, rhs: *const pugi_char_t) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QAE_NH@Z"]
    pub fn pugi_xml_text_set1(this: *mut pugi_xml_text, rhs: ::std::os::raw::c_int) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QAE_NI@Z"]
    pub fn pugi_xml_text_set2(this: *mut pugi_xml_text, rhs: ::std::os::raw::c_uint) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QAE_NN@Z"]
    pub fn pugi_xml_text_set3(this: *mut pugi_xml_text, rhs: f64) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xml_text@pugi@@QAE_N_N@Z"]
    pub fn pugi_xml_text_set4(this: *mut pugi_xml_text, rhs: bool) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?data@xml_text@pugi@@QBE?AVxml_node@2@XZ"]
    pub fn pugi_xml_text_data(this: *const pugi_xml_text) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_text@pugi@@QAE@XZ"]
    pub fn pugi_xml_text_xml_text(this: *mut pugi_xml_text);
}
impl pugi_xml_text {
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xml_text_empty(self)
    }
    #[inline]
    pub unsafe fn get(&self) -> *const pugi_char_t {
        pugi_xml_text_get(self)
    }
    #[inline]
    pub unsafe fn as_string(&self, def: *const pugi_char_t) -> *const pugi_char_t {
        pugi_xml_text_as_string(self, def)
    }
    #[inline]
    pub unsafe fn as_int(&self, def: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        pugi_xml_text_as_int(self, def)
    }
    #[inline]
    pub unsafe fn as_uint(&self, def: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint {
        pugi_xml_text_as_uint(self, def)
    }
    #[inline]
    pub unsafe fn as_double(&self, def: f64) -> f64 {
        pugi_xml_text_as_double(self, def)
    }
    #[inline]
    pub unsafe fn as_float(&self, def: f32) -> f32 {
        pugi_xml_text_as_float(self, def)
    }
    #[inline]
    pub unsafe fn as_bool(&self, def: bool) -> bool {
        pugi_xml_text_as_bool(self, def)
    }
    #[inline]
    pub unsafe fn set(&mut self, rhs: *const pugi_char_t) -> bool {
        pugi_xml_text_set(self, rhs)
    }
    #[inline]
    pub unsafe fn set1(&mut self, rhs: ::std::os::raw::c_int) -> bool {
        pugi_xml_text_set1(self, rhs)
    }
    #[inline]
    pub unsafe fn set2(&mut self, rhs: ::std::os::raw::c_uint) -> bool {
        pugi_xml_text_set2(self, rhs)
    }
    #[inline]
    pub unsafe fn set3(&mut self, rhs: f64) -> bool {
        pugi_xml_text_set3(self, rhs)
    }
    #[inline]
    pub unsafe fn set4(&mut self, rhs: bool) -> bool {
        pugi_xml_text_set4(self, rhs)
    }
    #[inline]
    pub unsafe fn data(&self) -> pugi_xml_node {
        pugi_xml_text_data(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_text_xml_text(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_node_iterator {
    pub _wrap: pugi_xml_node,
    pub _parent: pugi_xml_node,
}
pub type pugi_xml_node_iterator_difference_type = isize;
pub type pugi_xml_node_iterator_value_type = pugi_xml_node;
pub type pugi_xml_node_iterator_pointer = *mut pugi_xml_node;
pub type pugi_xml_node_iterator_reference = *mut pugi_xml_node;
pub type pugi_xml_node_iterator_iterator_category = std_bidirectional_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_node_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_node_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_node_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_node_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_node_iterator>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_node_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node_iterator),
            "::",
            stringify!(_wrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_node_iterator),
            "::",
            stringify!(_parent)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_node_iterator@pugi@@QAE@XZ"]
    pub fn pugi_xml_node_iterator_xml_node_iterator(this: *mut pugi_xml_node_iterator);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_node_iterator@pugi@@QAE@ABVxml_node@1@@Z"]
    pub fn pugi_xml_node_iterator_xml_node_iterator1(
        this: *mut pugi_xml_node_iterator,
        node: *const pugi_xml_node,
    );
}
impl pugi_xml_node_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_iterator_xml_node_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_node_iterator_xml_node_iterator1(__bindgen_tmp.as_mut_ptr(), node);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_attribute_iterator {
    pub _wrap: pugi_xml_attribute,
    pub _parent: pugi_xml_node,
}
pub type pugi_xml_attribute_iterator_difference_type = isize;
pub type pugi_xml_attribute_iterator_value_type = pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_pointer = *mut pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_reference = *mut pugi_xml_attribute;
pub type pugi_xml_attribute_iterator_iterator_category = std_bidirectional_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_attribute_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_attribute_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_attribute_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_attribute_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_attribute_iterator>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_attribute_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute_iterator),
            "::",
            stringify!(_wrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_attribute_iterator),
            "::",
            stringify!(_parent)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_attribute_iterator@pugi@@QAE@XZ"]
    pub fn pugi_xml_attribute_iterator_xml_attribute_iterator(
        this: *mut pugi_xml_attribute_iterator,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_attribute_iterator@pugi@@QAE@ABVxml_attribute@1@ABVxml_node@1@@Z"]
    pub fn pugi_xml_attribute_iterator_xml_attribute_iterator1(
        this: *mut pugi_xml_attribute_iterator,
        attr: *const pugi_xml_attribute,
        parent: *const pugi_xml_node,
    );
}
impl pugi_xml_attribute_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_iterator_xml_attribute_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(attr: *const pugi_xml_attribute, parent: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_attribute_iterator_xml_attribute_iterator1(
            __bindgen_tmp.as_mut_ptr(),
            attr,
            parent,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_named_node_iterator {
    pub _node: pugi_xml_node,
    pub _name: *const pugi_char_t,
}
pub type pugi_xml_named_node_iterator_difference_type = isize;
pub type pugi_xml_named_node_iterator_value_type = pugi_xml_node;
pub type pugi_xml_named_node_iterator_pointer = *mut pugi_xml_node;
pub type pugi_xml_named_node_iterator_reference = *mut pugi_xml_node;
pub type pugi_xml_named_node_iterator_iterator_category = std_forward_iterator_tag;
#[test]
fn bindgen_test_layout_pugi_xml_named_node_iterator() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_named_node_iterator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_named_node_iterator>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_named_node_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_named_node_iterator>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_named_node_iterator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_named_node_iterator),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_named_node_iterator),
            "::",
            stringify!(_name)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_named_node_iterator@pugi@@QAE@XZ"]
    pub fn pugi_xml_named_node_iterator_xml_named_node_iterator(
        this: *mut pugi_xml_named_node_iterator,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_named_node_iterator@pugi@@QAE@ABVxml_node@1@PBD@Z"]
    pub fn pugi_xml_named_node_iterator_xml_named_node_iterator1(
        this: *mut pugi_xml_named_node_iterator,
        node: *const pugi_xml_node,
        name: *const pugi_char_t,
    );
}
impl pugi_xml_named_node_iterator {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_named_node_iterator_xml_named_node_iterator(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node, name: *const pugi_char_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_named_node_iterator_xml_named_node_iterator1(
            __bindgen_tmp.as_mut_ptr(),
            node,
            name,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct pugi_xml_tree_walker__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_tree_walker {
    pub vtable_: *const pugi_xml_tree_walker__bindgen_vtable,
    pub _depth: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pugi_xml_tree_walker() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_tree_walker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_tree_walker>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xml_tree_walker))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_tree_walker>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_tree_walker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_tree_walker),
            "::",
            stringify!(_depth)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?depth@xml_tree_walker@pugi@@IBEHXZ"]
    pub fn pugi_xml_tree_walker_depth(this: *const pugi_xml_tree_walker) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_tree_walker@pugi@@QAE@XZ"]
    pub fn pugi_xml_tree_walker_xml_tree_walker(this: *mut pugi_xml_tree_walker);
}
impl pugi_xml_tree_walker {
    #[inline]
    pub unsafe fn depth(&self) -> ::std::os::raw::c_int {
        pugi_xml_tree_walker_depth(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_tree_walker_xml_tree_walker(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "thiscall" {
    #[link_name = "\u{1}??1xml_tree_walker@pugi@@UAE@XZ"]
    pub fn pugi_xml_tree_walker_xml_tree_walker_destructor(this: *mut pugi_xml_tree_walker);
}
extern "thiscall" {
    #[link_name = "\u{1}?begin@xml_tree_walker@pugi@@UAE_NAAVxml_node@2@@Z"]
    pub fn pugi_xml_tree_walker_begin(
        this: *mut ::std::os::raw::c_void,
        node: *mut pugi_xml_node,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?end@xml_tree_walker@pugi@@UAE_NAAVxml_node@2@@Z"]
    pub fn pugi_xml_tree_walker_end(
        this: *mut ::std::os::raw::c_void,
        node: *mut pugi_xml_node,
    ) -> bool;
}
pub const pugi_xml_parse_status_status_ok: pugi_xml_parse_status = 0;
pub const pugi_xml_parse_status_status_file_not_found: pugi_xml_parse_status = 1;
pub const pugi_xml_parse_status_status_io_error: pugi_xml_parse_status = 2;
pub const pugi_xml_parse_status_status_out_of_memory: pugi_xml_parse_status = 3;
pub const pugi_xml_parse_status_status_internal_error: pugi_xml_parse_status = 4;
pub const pugi_xml_parse_status_status_unrecognized_tag: pugi_xml_parse_status = 5;
pub const pugi_xml_parse_status_status_bad_pi: pugi_xml_parse_status = 6;
pub const pugi_xml_parse_status_status_bad_comment: pugi_xml_parse_status = 7;
pub const pugi_xml_parse_status_status_bad_cdata: pugi_xml_parse_status = 8;
pub const pugi_xml_parse_status_status_bad_doctype: pugi_xml_parse_status = 9;
pub const pugi_xml_parse_status_status_bad_pcdata: pugi_xml_parse_status = 10;
pub const pugi_xml_parse_status_status_bad_start_element: pugi_xml_parse_status = 11;
pub const pugi_xml_parse_status_status_bad_attribute: pugi_xml_parse_status = 12;
pub const pugi_xml_parse_status_status_bad_end_element: pugi_xml_parse_status = 13;
pub const pugi_xml_parse_status_status_end_element_mismatch: pugi_xml_parse_status = 14;
pub type pugi_xml_parse_status = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xml_parse_result {
    pub status: pugi_xml_parse_status,
    pub offset: isize,
    pub encoding: pugi_xml_encoding,
}
#[test]
fn bindgen_test_layout_pugi_xml_parse_result() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_parse_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_parse_result>(),
        12usize,
        concat!("Size of: ", stringify!(pugi_xml_parse_result))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_parse_result>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_parse_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_parse_result),
            "::",
            stringify!(encoding)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?description@xml_parse_result@pugi@@QBEPBDXZ"]
    pub fn pugi_xml_parse_result_description(
        this: *const pugi_xml_parse_result,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_parse_result@pugi@@QAE@XZ"]
    pub fn pugi_xml_parse_result_xml_parse_result(this: *mut pugi_xml_parse_result);
}
impl pugi_xml_parse_result {
    #[inline]
    pub unsafe fn description(&self) -> *const ::std::os::raw::c_char {
        pugi_xml_parse_result_description(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_parse_result_xml_parse_result(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xml_document {
    pub _base: pugi_xml_node,
    pub _buffer: *mut pugi_char_t,
    pub _memory: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout_pugi_xml_document() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xml_document> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xml_document>(),
        200usize,
        concat!("Size of: ", stringify!(pugi_xml_document))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xml_document>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xml_document))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_document),
            "::",
            stringify!(_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xml_document),
            "::",
            stringify!(_memory)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?reset@xml_document@pugi@@QAEXXZ"]
    pub fn pugi_xml_document_reset(this: *mut pugi_xml_document);
}
extern "thiscall" {
    #[link_name = "\u{1}?reset@xml_document@pugi@@QAEXABV12@@Z"]
    pub fn pugi_xml_document_reset1(this: *mut pugi_xml_document, proto: *const pugi_xml_document);
}
extern "thiscall" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QAE?AUxml_parse_result@2@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@IW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load(
        this: *mut pugi_xml_document,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QAE?AUxml_parse_result@2@AAV?$basic_istream@_WU?$char_traits@_W@std@@@std@@I@Z"]
    pub fn pugi_xml_document_load1(
        this: *mut pugi_xml_document,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDI@Z"]
    pub fn pugi_xml_document_load2(
        this: *mut pugi_xml_document,
        contents: *const pugi_char_t,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_file(
        this: *mut pugi_xml_document,
        path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load_file@xml_document@pugi@@QAE?AUxml_parse_result@2@PB_WIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_file1(
        this: *mut pugi_xml_document,
        path: *const u16,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load_buffer@xml_document@pugi@@QAE?AUxml_parse_result@2@PBXIIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer(
        this: *mut pugi_xml_document,
        contents: *const ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load_buffer_inplace@xml_document@pugi@@QAE?AUxml_parse_result@2@PAXIIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer_inplace(
        this: *mut pugi_xml_document,
        contents: *mut ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?load_buffer_inplace_own@xml_document@pugi@@QAE?AUxml_parse_result@2@PAXIIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_load_buffer_inplace_own(
        this: *mut pugi_xml_document,
        contents: *mut ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QBEXAAVxml_writer@2@PBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save(
        this: *const pugi_xml_document,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QBEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save1(
        this: *const pugi_xml_document,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?save@xml_document@pugi@@QBEXAAV?$basic_ostream@_WU?$char_traits@_W@std@@@std@@PBDI@Z"]
    pub fn pugi_xml_document_save2(
        this: *const pugi_xml_document,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?save_file@xml_document@pugi@@QBE_NPBD0IW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save_file(
        this: *const pugi_xml_document,
        path: *const ::std::os::raw::c_char,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?save_file@xml_document@pugi@@QBE_NPB_WPBDIW4xml_encoding@2@@Z"]
    pub fn pugi_xml_document_save_file1(
        this: *const pugi_xml_document,
        path: *const u16,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?document_element@xml_document@pugi@@QBE?AVxml_node@2@XZ"]
    pub fn pugi_xml_document_document_element(this: *const pugi_xml_document) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xml_document@pugi@@QAE@XZ"]
    pub fn pugi_xml_document_xml_document(this: *mut pugi_xml_document);
}
extern "thiscall" {
    #[link_name = "\u{1}??1xml_document@pugi@@QAE@XZ"]
    pub fn pugi_xml_document_xml_document_destructor(this: *mut pugi_xml_document);
}
impl pugi_xml_document {
    #[inline]
    pub unsafe fn reset(&mut self) {
        pugi_xml_document_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(&mut self, proto: *const pugi_xml_document) {
        pugi_xml_document_reset1(self, proto)
    }
    #[inline]
    pub unsafe fn load(
        &mut self,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load(self, stream, options, encoding)
    }
    #[inline]
    pub unsafe fn load1(
        &mut self,
        stream: *mut u8,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load1(self, stream, options)
    }
    #[inline]
    pub unsafe fn load2(
        &mut self,
        contents: *const pugi_char_t,
        options: ::std::os::raw::c_uint,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load2(self, contents, options)
    }
    #[inline]
    pub unsafe fn load_file(
        &mut self,
        path: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_file(self, path, options, encoding)
    }
    #[inline]
    pub unsafe fn load_file1(
        &mut self,
        path: *const u16,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_file1(self, path, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer(
        &mut self,
        contents: *const ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer_inplace(
        &mut self,
        contents: *mut ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer_inplace(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn load_buffer_inplace_own(
        &mut self,
        contents: *mut ::std::os::raw::c_void,
        size: usize,
        options: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> pugi_xml_parse_result {
        pugi_xml_document_load_buffer_inplace_own(self, contents, size, options, encoding)
    }
    #[inline]
    pub unsafe fn save(
        &self,
        writer: *mut pugi_xml_writer,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) {
        pugi_xml_document_save(self, writer, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save1(
        &self,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) {
        pugi_xml_document_save1(self, stream, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save2(
        &self,
        stream: *mut u8,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
    ) {
        pugi_xml_document_save2(self, stream, indent, flags)
    }
    #[inline]
    pub unsafe fn save_file(
        &self,
        path: *const ::std::os::raw::c_char,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool {
        pugi_xml_document_save_file(self, path, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn save_file1(
        &self,
        path: *const u16,
        indent: *const pugi_char_t,
        flags: ::std::os::raw::c_uint,
        encoding: pugi_xml_encoding,
    ) -> bool {
        pugi_xml_document_save_file1(self, path, indent, flags, encoding)
    }
    #[inline]
    pub unsafe fn document_element(&self) -> pugi_xml_node {
        pugi_xml_document_document_element(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xml_document_xml_document(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xml_document_xml_document_destructor(self)
    }
}
pub const pugi_xpath_value_type_xpath_type_none: pugi_xpath_value_type = 0;
pub const pugi_xpath_value_type_xpath_type_node_set: pugi_xpath_value_type = 1;
pub const pugi_xpath_value_type_xpath_type_number: pugi_xpath_value_type = 2;
pub const pugi_xpath_value_type_xpath_type_string: pugi_xpath_value_type = 3;
pub const pugi_xpath_value_type_xpath_type_boolean: pugi_xpath_value_type = 4;
pub type pugi_xpath_value_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_parse_result {
    pub error: *const ::std::os::raw::c_char,
    pub offset: isize,
}
#[test]
fn bindgen_test_layout_pugi_xpath_parse_result() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_parse_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_parse_result>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xpath_parse_result))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_parse_result>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_parse_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_parse_result),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_parse_result),
            "::",
            stringify!(offset)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?description@xpath_parse_result@pugi@@QBEPBDXZ"]
    pub fn pugi_xpath_parse_result_description(
        this: *const pugi_xpath_parse_result,
    ) -> *const ::std::os::raw::c_char;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_parse_result@pugi@@QAE@XZ"]
    pub fn pugi_xpath_parse_result_xpath_parse_result(this: *mut pugi_xpath_parse_result);
}
impl pugi_xpath_parse_result {
    #[inline]
    pub unsafe fn description(&self) -> *const ::std::os::raw::c_char {
        pugi_xpath_parse_result_description(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_parse_result_xpath_parse_result(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_variable {
    pub _type: pugi_xpath_value_type,
    pub _next: *mut pugi_xpath_variable,
}
#[test]
fn bindgen_test_layout_pugi_xpath_variable() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_variable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_variable>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xpath_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_variable>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_variable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable),
            "::",
            stringify!(_next)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?name@xpath_variable@pugi@@QBEPBDXZ"]
    pub fn pugi_xpath_variable_name(this: *const pugi_xpath_variable) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?type@xpath_variable@pugi@@QBE?AW4xpath_value_type@2@XZ"]
    pub fn pugi_xpath_variable_type(this: *const pugi_xpath_variable) -> pugi_xpath_value_type;
}
extern "thiscall" {
    #[link_name = "\u{1}?get_boolean@xpath_variable@pugi@@QBE_NXZ"]
    pub fn pugi_xpath_variable_get_boolean(this: *const pugi_xpath_variable) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?get_number@xpath_variable@pugi@@QBENXZ"]
    pub fn pugi_xpath_variable_get_number(this: *const pugi_xpath_variable) -> f64;
}
extern "thiscall" {
    #[link_name = "\u{1}?get_string@xpath_variable@pugi@@QBEPBDXZ"]
    pub fn pugi_xpath_variable_get_string(this: *const pugi_xpath_variable) -> *const pugi_char_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?get_node_set@xpath_variable@pugi@@QBEABVxpath_node_set@2@XZ"]
    pub fn pugi_xpath_variable_get_node_set(
        this: *const pugi_xpath_variable,
    ) -> *const pugi_xpath_node_set;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QAE_N_N@Z"]
    pub fn pugi_xpath_variable_set(this: *mut pugi_xpath_variable, value: bool) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QAE_NN@Z"]
    pub fn pugi_xpath_variable_set1(this: *mut pugi_xpath_variable, value: f64) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QAE_NPBD@Z"]
    pub fn pugi_xpath_variable_set2(
        this: *mut pugi_xpath_variable,
        value: *const pugi_char_t,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable@pugi@@QAE_NABVxpath_node_set@2@@Z"]
    pub fn pugi_xpath_variable_set3(
        this: *mut pugi_xpath_variable,
        value: *const pugi_xpath_node_set,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_variable@pugi@@IAE@XZ"]
    pub fn pugi_xpath_variable_xpath_variable(this: *mut pugi_xpath_variable);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_variable@pugi@@IAE@ABV01@@Z"]
    pub fn pugi_xpath_variable_xpath_variable1(
        this: *mut pugi_xpath_variable,
        arg1: *const pugi_xpath_variable,
    );
}
impl pugi_xpath_variable {
    #[inline]
    pub unsafe fn name(&self) -> *const pugi_char_t {
        pugi_xpath_variable_name(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xpath_value_type {
        pugi_xpath_variable_type(self)
    }
    #[inline]
    pub unsafe fn get_boolean(&self) -> bool {
        pugi_xpath_variable_get_boolean(self)
    }
    #[inline]
    pub unsafe fn get_number(&self) -> f64 {
        pugi_xpath_variable_get_number(self)
    }
    #[inline]
    pub unsafe fn get_string(&self) -> *const pugi_char_t {
        pugi_xpath_variable_get_string(self)
    }
    #[inline]
    pub unsafe fn get_node_set(&self) -> *const pugi_xpath_node_set {
        pugi_xpath_variable_get_node_set(self)
    }
    #[inline]
    pub unsafe fn set(&mut self, value: bool) -> bool {
        pugi_xpath_variable_set(self, value)
    }
    #[inline]
    pub unsafe fn set1(&mut self, value: f64) -> bool {
        pugi_xpath_variable_set1(self, value)
    }
    #[inline]
    pub unsafe fn set2(&mut self, value: *const pugi_char_t) -> bool {
        pugi_xpath_variable_set2(self, value)
    }
    #[inline]
    pub unsafe fn set3(&mut self, value: *const pugi_xpath_node_set) -> bool {
        pugi_xpath_variable_set3(self, value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_xpath_variable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const pugi_xpath_variable) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_xpath_variable1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_variable_set {
    pub _data: [*mut pugi_xpath_variable; 64usize],
}
#[test]
fn bindgen_test_layout_pugi_xpath_variable_set() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_variable_set> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_variable_set>(),
        256usize,
        concat!("Size of: ", stringify!(pugi_xpath_variable_set))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_variable_set>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_variable_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_variable_set),
            "::",
            stringify!(_data)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?add@xpath_variable_set@pugi@@QAEPAVxpath_variable@2@PBDW4xpath_value_type@2@@Z"]
    pub fn pugi_xpath_variable_set_add(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        type_: pugi_xpath_value_type,
    ) -> *mut pugi_xpath_variable;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QAE_NPBD_N@Z"]
    pub fn pugi_xpath_variable_set_set(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: bool,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QAE_NPBDN@Z"]
    pub fn pugi_xpath_variable_set_set1(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: f64,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QAE_NPBD0@Z"]
    pub fn pugi_xpath_variable_set_set2(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: *const pugi_char_t,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?set@xpath_variable_set@pugi@@QAE_NPBDABVxpath_node_set@2@@Z"]
    pub fn pugi_xpath_variable_set_set3(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
        value: *const pugi_xpath_node_set,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?get@xpath_variable_set@pugi@@QAEPAVxpath_variable@2@PBD@Z"]
    pub fn pugi_xpath_variable_set_get(
        this: *mut pugi_xpath_variable_set,
        name: *const pugi_char_t,
    ) -> *mut pugi_xpath_variable;
}
extern "thiscall" {
    #[link_name = "\u{1}?get@xpath_variable_set@pugi@@QBEPBVxpath_variable@2@PBD@Z"]
    pub fn pugi_xpath_variable_set_get1(
        this: *const pugi_xpath_variable_set,
        name: *const pugi_char_t,
    ) -> *const pugi_xpath_variable;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_variable_set@pugi@@QAE@XZ"]
    pub fn pugi_xpath_variable_set_xpath_variable_set(this: *mut pugi_xpath_variable_set);
}
extern "thiscall" {
    #[link_name = "\u{1}??1xpath_variable_set@pugi@@QAE@XZ"]
    pub fn pugi_xpath_variable_set_xpath_variable_set_destructor(
        this: *mut pugi_xpath_variable_set,
    );
}
impl pugi_xpath_variable_set {
    #[inline]
    pub unsafe fn add(
        &mut self,
        name: *const pugi_char_t,
        type_: pugi_xpath_value_type,
    ) -> *mut pugi_xpath_variable {
        pugi_xpath_variable_set_add(self, name, type_)
    }
    #[inline]
    pub unsafe fn set(&mut self, name: *const pugi_char_t, value: bool) -> bool {
        pugi_xpath_variable_set_set(self, name, value)
    }
    #[inline]
    pub unsafe fn set1(&mut self, name: *const pugi_char_t, value: f64) -> bool {
        pugi_xpath_variable_set_set1(self, name, value)
    }
    #[inline]
    pub unsafe fn set2(&mut self, name: *const pugi_char_t, value: *const pugi_char_t) -> bool {
        pugi_xpath_variable_set_set2(self, name, value)
    }
    #[inline]
    pub unsafe fn set3(
        &mut self,
        name: *const pugi_char_t,
        value: *const pugi_xpath_node_set,
    ) -> bool {
        pugi_xpath_variable_set_set3(self, name, value)
    }
    #[inline]
    pub unsafe fn get(&mut self, name: *const pugi_char_t) -> *mut pugi_xpath_variable {
        pugi_xpath_variable_set_get(self, name)
    }
    #[inline]
    pub unsafe fn get1(&self, name: *const pugi_char_t) -> *const pugi_xpath_variable {
        pugi_xpath_variable_set_get1(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_variable_set_xpath_variable_set(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_variable_set_xpath_variable_set_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_query {
    pub _impl: *mut ::std::os::raw::c_void,
    pub _result: pugi_xpath_parse_result,
}
pub type pugi_xpath_query_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xpath_query)>;
#[test]
fn bindgen_test_layout_pugi_xpath_query() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_query> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_query>(),
        12usize,
        concat!("Size of: ", stringify!(pugi_xpath_query))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_query>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_query))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._impl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_query),
            "::",
            stringify!(_impl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_query),
            "::",
            stringify!(_result)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?return_type@xpath_query@pugi@@QBE?AW4xpath_value_type@2@XZ"]
    pub fn pugi_xpath_query_return_type(this: *const pugi_xpath_query) -> pugi_xpath_value_type;
}
extern "thiscall" {
    #[link_name = "\u{1}?evaluate_boolean@xpath_query@pugi@@QBE_NABVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_boolean(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?evaluate_number@xpath_query@pugi@@QBENABVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_number(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> f64;
}
extern "thiscall" {
    #[link_name = "\u{1}?evaluate_string@xpath_query@pugi@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_string(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> pugi_string_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?evaluate_string@xpath_query@pugi@@QBEIPADIABVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_string1(
        this: *const pugi_xpath_query,
        buffer: *mut pugi_char_t,
        capacity: usize,
        n: *const pugi_xpath_node,
    ) -> usize;
}
extern "thiscall" {
    #[link_name = "\u{1}?evaluate_node_set@xpath_query@pugi@@QBE?AVxpath_node_set@2@ABVxpath_node@2@@Z"]
    pub fn pugi_xpath_query_evaluate_node_set(
        this: *const pugi_xpath_query,
        n: *const pugi_xpath_node,
    ) -> pugi_xpath_node_set;
}
extern "thiscall" {
    #[link_name = "\u{1}?result@xpath_query@pugi@@QBEABUxpath_parse_result@2@XZ"]
    pub fn pugi_xpath_query_result(this: *const pugi_xpath_query)
        -> *const pugi_xpath_parse_result;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_query@pugi@@QAE@PBDPAVxpath_variable_set@1@@Z"]
    pub fn pugi_xpath_query_xpath_query(
        this: *mut pugi_xpath_query,
        query: *const pugi_char_t,
        variables: *mut pugi_xpath_variable_set,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??1xpath_query@pugi@@QAE@XZ"]
    pub fn pugi_xpath_query_xpath_query_destructor(this: *mut pugi_xpath_query);
}
impl pugi_xpath_query {
    #[inline]
    pub unsafe fn return_type(&self) -> pugi_xpath_value_type {
        pugi_xpath_query_return_type(self)
    }
    #[inline]
    pub unsafe fn evaluate_boolean(&self, n: *const pugi_xpath_node) -> bool {
        pugi_xpath_query_evaluate_boolean(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_number(&self, n: *const pugi_xpath_node) -> f64 {
        pugi_xpath_query_evaluate_number(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_string(&self, n: *const pugi_xpath_node) -> pugi_string_t {
        pugi_xpath_query_evaluate_string(self, n)
    }
    #[inline]
    pub unsafe fn evaluate_string1(
        &self,
        buffer: *mut pugi_char_t,
        capacity: usize,
        n: *const pugi_xpath_node,
    ) -> usize {
        pugi_xpath_query_evaluate_string1(self, buffer, capacity, n)
    }
    #[inline]
    pub unsafe fn evaluate_node_set(&self, n: *const pugi_xpath_node) -> pugi_xpath_node_set {
        pugi_xpath_query_evaluate_node_set(self, n)
    }
    #[inline]
    pub unsafe fn result(&self) -> *const pugi_xpath_parse_result {
        pugi_xpath_query_result(self)
    }
    #[inline]
    pub unsafe fn new(query: *const pugi_char_t, variables: *mut pugi_xpath_variable_set) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_query_xpath_query(__bindgen_tmp.as_mut_ptr(), query, variables);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_query_xpath_query_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pugi_xpath_node {
    pub _node: pugi_xml_node,
    pub _attribute: pugi_xml_attribute,
}
pub type pugi_xpath_node_unspecified_bool_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut *mut *mut pugi_xpath_node)>;
#[test]
fn bindgen_test_layout_pugi_xpath_node() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_node>(),
        8usize,
        concat!("Size of: ", stringify!(pugi_xpath_node))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_node>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node),
            "::",
            stringify!(_attribute)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?node@xpath_node@pugi@@QBE?AVxml_node@2@XZ"]
    pub fn pugi_xpath_node_node(this: *const pugi_xpath_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?attribute@xpath_node@pugi@@QBE?AVxml_attribute@2@XZ"]
    pub fn pugi_xpath_node_attribute(this: *const pugi_xpath_node) -> pugi_xml_attribute;
}
extern "thiscall" {
    #[link_name = "\u{1}?parent@xpath_node@pugi@@QBE?AVxml_node@2@XZ"]
    pub fn pugi_xpath_node_parent(this: *const pugi_xpath_node) -> pugi_xml_node;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QAE@XZ"]
    pub fn pugi_xpath_node_xpath_node(this: *mut pugi_xpath_node);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QAE@ABVxml_node@1@@Z"]
    pub fn pugi_xpath_node_xpath_node1(this: *mut pugi_xpath_node, node: *const pugi_xml_node);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node@pugi@@QAE@ABVxml_attribute@1@ABVxml_node@1@@Z"]
    pub fn pugi_xpath_node_xpath_node2(
        this: *mut pugi_xpath_node,
        attribute: *const pugi_xml_attribute,
        parent: *const pugi_xml_node,
    );
}
impl pugi_xpath_node {
    #[inline]
    pub unsafe fn node(&self) -> pugi_xml_node {
        pugi_xpath_node_node(self)
    }
    #[inline]
    pub unsafe fn attribute(&self) -> pugi_xml_attribute {
        pugi_xpath_node_attribute(self)
    }
    #[inline]
    pub unsafe fn parent(&self) -> pugi_xml_node {
        pugi_xpath_node_parent(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(node: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node1(__bindgen_tmp.as_mut_ptr(), node);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(attribute: *const pugi_xml_attribute, parent: *const pugi_xml_node) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_xpath_node2(__bindgen_tmp.as_mut_ptr(), attribute, parent);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct pugi_xpath_node_set {
    pub _type: pugi_xpath_node_set_type_t,
    pub _storage: pugi_xpath_node,
    pub _begin: *mut pugi_xpath_node,
    pub _end: *mut pugi_xpath_node,
}
pub const pugi_xpath_node_set_type_t_type_unsorted: pugi_xpath_node_set_type_t = 0;
pub const pugi_xpath_node_set_type_t_type_sorted: pugi_xpath_node_set_type_t = 1;
pub const pugi_xpath_node_set_type_t_type_sorted_reverse: pugi_xpath_node_set_type_t = 2;
pub type pugi_xpath_node_set_type_t = ::std::os::raw::c_int;
pub type pugi_xpath_node_set_const_iterator = *const pugi_xpath_node;
#[test]
fn bindgen_test_layout_pugi_xpath_node_set() {
    const UNINIT: ::std::mem::MaybeUninit<pugi_xpath_node_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pugi_xpath_node_set>(),
        20usize,
        concat!("Size of: ", stringify!(pugi_xpath_node_set))
    );
    assert_eq!(
        ::std::mem::align_of::<pugi_xpath_node_set>(),
        4usize,
        concat!("Alignment of ", stringify!(pugi_xpath_node_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._storage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._begin) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pugi_xpath_node_set),
            "::",
            stringify!(_end)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?type@xpath_node_set@pugi@@QBE?AW4type_t@12@XZ"]
    pub fn pugi_xpath_node_set_type(this: *const pugi_xpath_node_set)
        -> pugi_xpath_node_set_type_t;
}
extern "thiscall" {
    #[link_name = "\u{1}?size@xpath_node_set@pugi@@QBEIXZ"]
    pub fn pugi_xpath_node_set_size(this: *const pugi_xpath_node_set) -> usize;
}
extern "thiscall" {
    #[link_name = "\u{1}?begin@xpath_node_set@pugi@@QBEPBVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_begin(
        this: *const pugi_xpath_node_set,
    ) -> pugi_xpath_node_set_const_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?end@xpath_node_set@pugi@@QBEPBVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_end(
        this: *const pugi_xpath_node_set,
    ) -> pugi_xpath_node_set_const_iterator;
}
extern "thiscall" {
    #[link_name = "\u{1}?sort@xpath_node_set@pugi@@QAEX_N@Z"]
    pub fn pugi_xpath_node_set_sort(this: *mut pugi_xpath_node_set, reverse: bool);
}
extern "thiscall" {
    #[link_name = "\u{1}?first@xpath_node_set@pugi@@QBE?AVxpath_node@2@XZ"]
    pub fn pugi_xpath_node_set_first(this: *const pugi_xpath_node_set) -> pugi_xpath_node;
}
extern "thiscall" {
    #[link_name = "\u{1}?empty@xpath_node_set@pugi@@QBE_NXZ"]
    pub fn pugi_xpath_node_set_empty(this: *const pugi_xpath_node_set) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QAE@XZ"]
    pub fn pugi_xpath_node_set_xpath_node_set(this: *mut pugi_xpath_node_set);
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QAE@PBVxpath_node@1@0W4type_t@01@@Z"]
    pub fn pugi_xpath_node_set_xpath_node_set1(
        this: *mut pugi_xpath_node_set,
        begin: pugi_xpath_node_set_const_iterator,
        end: pugi_xpath_node_set_const_iterator,
        type_: pugi_xpath_node_set_type_t,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??0xpath_node_set@pugi@@QAE@ABV01@@Z"]
    pub fn pugi_xpath_node_set_xpath_node_set2(
        this: *mut pugi_xpath_node_set,
        ns: *const pugi_xpath_node_set,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}??1xpath_node_set@pugi@@QAE@XZ"]
    pub fn pugi_xpath_node_set_xpath_node_set_destructor(this: *mut pugi_xpath_node_set);
}
impl pugi_xpath_node_set {
    #[inline]
    pub unsafe fn type_(&self) -> pugi_xpath_node_set_type_t {
        pugi_xpath_node_set_type(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> usize {
        pugi_xpath_node_set_size(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> pugi_xpath_node_set_const_iterator {
        pugi_xpath_node_set_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> pugi_xpath_node_set_const_iterator {
        pugi_xpath_node_set_end(self)
    }
    #[inline]
    pub unsafe fn sort(&mut self, reverse: bool) {
        pugi_xpath_node_set_sort(self, reverse)
    }
    #[inline]
    pub unsafe fn first(&self) -> pugi_xpath_node {
        pugi_xpath_node_set_first(self)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        pugi_xpath_node_set_empty(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        begin: pugi_xpath_node_set_const_iterator,
        end: pugi_xpath_node_set_const_iterator,
        type_: pugi_xpath_node_set_type_t,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set1(__bindgen_tmp.as_mut_ptr(), begin, end, type_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(ns: *const pugi_xpath_node_set) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        pugi_xpath_node_set_xpath_node_set2(__bindgen_tmp.as_mut_ptr(), ns);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        pugi_xpath_node_set_xpath_node_set_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct DS_Dictionary {
    pub doc: pugi_xml_document,
    pub dictTree: [u32; 3usize],
    pub compatible: bool,
}
#[test]
fn bindgen_test_layout_DS_Dictionary() {
    const UNINIT: ::std::mem::MaybeUninit<DS_Dictionary> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DS_Dictionary>(),
        216usize,
        concat!("Size of: ", stringify!(DS_Dictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<DS_Dictionary>(),
        4usize,
        concat!("Alignment of ", stringify!(DS_Dictionary))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictTree) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(dictTree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compatible) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(DS_Dictionary),
            "::",
            stringify!(compatible)
        )
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?cleanStringWhiteSpace@DS_Dictionary@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z"]
    pub fn DS_Dictionary_cleanStringWhiteSpace(
        this: *mut DS_Dictionary,
        arg1: *const std_string,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?split@DS_Dictionary@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PADABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z"]
    pub fn DS_Dictionary_split(
        this: *mut DS_Dictionary,
        arg1: *const std_string,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const [u32; 3usize],
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?splitWithForm@DS_Dictionary@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z"]
    pub fn DS_Dictionary_splitWithForm(
        this: *mut DS_Dictionary,
        arg1: *const std_string,
        arg2: *mut [u32; 3usize],
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?rectFromString@DS_Dictionary@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVCCRect@cocos2d@@@Z"]
    pub fn DS_Dictionary_rectFromString(
        this: *mut DS_Dictionary,
        arg1: *const std_string,
        arg2: *mut cocos2d_CCRect,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?vec2FromString@DS_Dictionary@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVCCPoint@cocos2d@@@Z"]
    pub fn DS_Dictionary_vec2FromString(
        this: *mut DS_Dictionary,
        arg1: *const std_string,
        arg2: *mut cocos2d_CCPoint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?copyFile@DS_Dictionary@@SAXPBD0@Z"]
    pub fn DS_Dictionary_copyFile(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?decodeObjectForKey@DS_Dictionary@@QAEPAVCCObject@cocos2d@@PBD_NH@Z"]
    pub fn DS_Dictionary_decodeObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?loadRootSubDictFromFile@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?loadRootSubDictFromCompressedFile@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromCompressedFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?loadRootSubDictFromString@DS_Dictionary@@QAE_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn DS_Dictionary_loadRootSubDictFromString(
        this: *mut DS_Dictionary,
        arg1: std_string,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?saveRootSubDictToFile@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_saveRootSubDictToFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?saveRootSubDictToCompressedFile@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_saveRootSubDictToCompressedFile(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?saveRootSubDictToString@DS_Dictionary@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"]
    pub fn DS_Dictionary_saveRootSubDictToString(this: *mut DS_Dictionary) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?stepIntoSubDictWithKey@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_stepIntoSubDictWithKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?stepOutOfSubDict@DS_Dictionary@@QAEXXZ"]
    pub fn DS_Dictionary_stepOutOfSubDict(this: *mut DS_Dictionary);
}
extern "thiscall" {
    #[link_name = "\u{1}?stepBackToRootSubDict@DS_Dictionary@@QAEXXZ"]
    pub fn DS_Dictionary_stepBackToRootSubDict(this: *mut DS_Dictionary);
}
extern "thiscall" {
    #[link_name = "\u{1}?getNumKeys@DS_Dictionary@@QAEIXZ"]
    pub fn DS_Dictionary_getNumKeys(this: *mut DS_Dictionary) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?getKey@DS_Dictionary@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z"]
    pub fn DS_Dictionary_getKey(
        this: *mut DS_Dictionary,
        arg1: ::std::os::raw::c_uint,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?getAllKeys@DS_Dictionary@@QAE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ"]
    pub fn DS_Dictionary_getAllKeys(this: *mut DS_Dictionary) -> [u32; 3usize];
}
extern "thiscall" {
    #[link_name = "\u{1}?getIndexOfKey@DS_Dictionary@@QAEIPBD@Z"]
    pub fn DS_Dictionary_getIndexOfKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?getIndexOfKeyWithClosestAlphaNumericalMatch@DS_Dictionary@@QAEIPBD@Z"]
    pub fn DS_Dictionary_getIndexOfKeyWithClosestAlphaNumericalMatch(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "thiscall" {
    #[link_name = "\u{1}?removeKey@DS_Dictionary@@QAEXI@Z"]
    pub fn DS_Dictionary_removeKey(this: *mut DS_Dictionary, arg1: ::std::os::raw::c_uint);
}
extern "thiscall" {
    #[link_name = "\u{1}?removeKey@DS_Dictionary@@QAEXPBD@Z"]
    pub fn DS_Dictionary_removeKey1(this: *mut DS_Dictionary, arg1: *const ::std::os::raw::c_char);
}
extern "thiscall" {
    #[link_name = "\u{1}?removeAllKeys@DS_Dictionary@@QAEXXZ"]
    pub fn DS_Dictionary_removeAllKeys(this: *mut DS_Dictionary);
}
extern "thiscall" {
    #[link_name = "\u{1}?getIntegerForKey@DS_Dictionary@@QAEHPBD@Z"]
    pub fn DS_Dictionary_getIntegerForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "thiscall" {
    #[link_name = "\u{1}?getBoolForKey@DS_Dictionary@@QAE_NPBD@Z"]
    pub fn DS_Dictionary_getBoolForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "thiscall" {
    #[link_name = "\u{1}?getFloatForKey@DS_Dictionary@@QAEMPBD@Z"]
    pub fn DS_Dictionary_getFloatForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> f32;
}
extern "thiscall" {
    #[link_name = "\u{1}?getStringForKey@DS_Dictionary@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z"]
    pub fn DS_Dictionary_getStringForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> std_string;
}
extern "thiscall" {
    #[link_name = "\u{1}?getVec2ForKey@DS_Dictionary@@QAE?AVCCPoint@cocos2d@@PBD@Z"]
    pub fn DS_Dictionary_getVec2ForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> cocos2d_CCPoint;
}
extern "thiscall" {
    #[link_name = "\u{1}?getRectForKey@DS_Dictionary@@QAE?AVCCRect@cocos2d@@PBD@Z"]
    pub fn DS_Dictionary_getRectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> cocos2d_CCRect;
}
extern "thiscall" {
    #[link_name = "\u{1}?getStringArrayForKey@DS_Dictionary@@QAE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z"]
    pub fn DS_Dictionary_getStringArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> [u32; 3usize];
}
extern "thiscall" {
    #[link_name = "\u{1}?getVec2ArrayForKey@DS_Dictionary@@QAE?AV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@PBD@Z"]
    pub fn DS_Dictionary_getVec2ArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> u8;
}
extern "thiscall" {
    #[link_name = "\u{1}?getRectArrayForKey@DS_Dictionary@@QAE?AV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@PBD@Z"]
    pub fn DS_Dictionary_getRectArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> u8;
}
extern "thiscall" {
    #[link_name = "\u{1}?getArrayForKey@DS_Dictionary@@QAEPAVCCArray@cocos2d@@PBD_N@Z"]
    pub fn DS_Dictionary_getArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCArray;
}
extern "thiscall" {
    #[link_name = "\u{1}?getDictForKey@DS_Dictionary@@QAEPAVCCDictionary@cocos2d@@PBD_N@Z"]
    pub fn DS_Dictionary_getDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCDictionary;
}
extern "thiscall" {
    #[link_name = "\u{1}?getObjectForKey@DS_Dictionary@@QAEPAVCCObject@cocos2d@@PBD@Z"]
    pub fn DS_Dictionary_getObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject;
}
extern "thiscall" {
    #[link_name = "\u{1}?setIntegerForKey@DS_Dictionary@@QAEXPBDH@Z"]
    pub fn DS_Dictionary_setIntegerForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setIntegerForKey@DS_Dictionary@@QAEXPBDH_N@Z"]
    pub fn DS_Dictionary_setIntegerForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setBoolForKey@DS_Dictionary@@QAEXPBD_N@Z"]
    pub fn DS_Dictionary_setBoolForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setBoolForKey@DS_Dictionary@@QAEXPBD_N1@Z"]
    pub fn DS_Dictionary_setBoolForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setFloatForKey@DS_Dictionary@@QAEXPBDM@Z"]
    pub fn DS_Dictionary_setFloatForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setFloatForKey@DS_Dictionary@@QAEXPBDM_N@Z"]
    pub fn DS_Dictionary_setFloatForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setStringForKey@DS_Dictionary@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"]
    pub fn DS_Dictionary_setStringForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setStringForKey@DS_Dictionary@@QAEXPBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z"]
    pub fn DS_Dictionary_setStringForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setVec2ForKey@DS_Dictionary@@QAEXPBDABVCCPoint@cocos2d@@@Z"]
    pub fn DS_Dictionary_setVec2ForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setVec2ForKey@DS_Dictionary@@QAEXPBDABVCCPoint@cocos2d@@_N@Z"]
    pub fn DS_Dictionary_setVec2ForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRectForKey@DS_Dictionary@@QAEXPBDABVCCRect@cocos2d@@@Z"]
    pub fn DS_Dictionary_setRectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRectForKey@DS_Dictionary@@QAEXPBDABVCCRect@cocos2d@@_N@Z"]
    pub fn DS_Dictionary_setRectForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setStringArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z"]
    pub fn DS_Dictionary_setStringArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u32; 3usize],
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setStringArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@_N@Z"]
    pub fn DS_Dictionary_setStringArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u32; 3usize],
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setVec2ArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@@Z"]
    pub fn DS_Dictionary_setVec2ArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setVec2ArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@VCCPoint@cocos2d@@V?$allocator@VCCPoint@cocos2d@@@std@@@std@@_N@Z"]
    pub fn DS_Dictionary_setVec2ArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRectArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@@Z"]
    pub fn DS_Dictionary_setRectArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setRectArrayForKey@DS_Dictionary@@QAEXPBDABV?$vector@VCCRect@cocos2d@@V?$allocator@VCCRect@cocos2d@@@std@@@std@@_N@Z"]
    pub fn DS_Dictionary_setRectArrayForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setArrayForKey@DS_Dictionary@@QAEXPBDPAVCCArray@cocos2d@@@Z"]
    pub fn DS_Dictionary_setArrayForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCArray,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setBoolMapForKey@DS_Dictionary@@QAEXPBDABV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@@Z"]
    pub fn DS_Dictionary_setBoolMapForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setSubDictForKey@DS_Dictionary@@QAEXPBD@Z"]
    pub fn DS_Dictionary_setSubDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setSubDictForKey@DS_Dictionary@@QAEXPBD_N1@Z"]
    pub fn DS_Dictionary_setSubDictForKey1(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setDictForKey@DS_Dictionary@@QAEXPBDPAVCCDictionary@cocos2d@@@Z"]
    pub fn DS_Dictionary_setDictForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCDictionary,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?setObjectForKey@DS_Dictionary@@QAEXPBDPAVCCObject@cocos2d@@@Z"]
    pub fn DS_Dictionary_setObjectForKey(
        this: *mut DS_Dictionary,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCObject,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addBoolValuesToMapForKey@DS_Dictionary@@QAEXABV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@PBD_N@Z"]
    pub fn DS_Dictionary_addBoolValuesToMapForKey(
        this: *mut DS_Dictionary,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?addBoolValuesToMapForKeySpecial@DS_Dictionary@@QAEXABV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@std@@@2@@std@@PBD_N@Z"]
    pub fn DS_Dictionary_addBoolValuesToMapForKeySpecial(
        this: *mut DS_Dictionary,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    );
}
extern "thiscall" {
    #[link_name = "\u{1}?checkCompatibility@DS_Dictionary@@QAEXXZ"]
    pub fn DS_Dictionary_checkCompatibility(this: *mut DS_Dictionary);
}
extern "thiscall" {
    #[link_name = "\u{1}??0DS_Dictionary@@QAE@XZ"]
    pub fn DS_Dictionary_DS_Dictionary(this: *mut DS_Dictionary);
}
extern "thiscall" {
    #[link_name = "\u{1}??1DS_Dictionary@@QAE@XZ"]
    pub fn DS_Dictionary_DS_Dictionary_destructor(this: *mut DS_Dictionary);
}
impl DS_Dictionary {
    #[inline]
    pub unsafe fn cleanStringWhiteSpace(&mut self, arg1: *const std_string) -> std_string {
        DS_Dictionary_cleanStringWhiteSpace(self, arg1)
    }
    #[inline]
    pub unsafe fn split(
        &mut self,
        arg1: *const std_string,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const [u32; 3usize],
    ) {
        DS_Dictionary_split(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn splitWithForm(
        &mut self,
        arg1: *const std_string,
        arg2: *mut [u32; 3usize],
    ) -> bool {
        DS_Dictionary_splitWithForm(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn rectFromString(
        &mut self,
        arg1: *const std_string,
        arg2: *mut cocos2d_CCRect,
    ) -> bool {
        DS_Dictionary_rectFromString(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn vec2FromString(
        &mut self,
        arg1: *const std_string,
        arg2: *mut cocos2d_CCPoint,
    ) -> bool {
        DS_Dictionary_vec2FromString(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn copyFile(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) {
        DS_Dictionary_copyFile(arg1, arg2)
    }
    #[inline]
    pub unsafe fn decodeObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: ::std::os::raw::c_int,
    ) -> *mut cocos2d_CCObject {
        DS_Dictionary_decodeObjectForKey(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromFile(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_loadRootSubDictFromFile(self, arg1)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromCompressedFile(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool {
        DS_Dictionary_loadRootSubDictFromCompressedFile(self, arg1)
    }
    #[inline]
    pub unsafe fn loadRootSubDictFromString(&mut self, arg1: std_string) -> bool {
        DS_Dictionary_loadRootSubDictFromString(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToFile(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_saveRootSubDictToFile(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToCompressedFile(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> bool {
        DS_Dictionary_saveRootSubDictToCompressedFile(self, arg1)
    }
    #[inline]
    pub unsafe fn saveRootSubDictToString(&mut self) -> std_string {
        DS_Dictionary_saveRootSubDictToString(self)
    }
    #[inline]
    pub unsafe fn stepIntoSubDictWithKey(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_stepIntoSubDictWithKey(self, arg1)
    }
    #[inline]
    pub unsafe fn stepOutOfSubDict(&mut self) {
        DS_Dictionary_stepOutOfSubDict(self)
    }
    #[inline]
    pub unsafe fn stepBackToRootSubDict(&mut self) {
        DS_Dictionary_stepBackToRootSubDict(self)
    }
    #[inline]
    pub unsafe fn getNumKeys(&mut self) -> ::std::os::raw::c_uint {
        DS_Dictionary_getNumKeys(self)
    }
    #[inline]
    pub unsafe fn getKey(&mut self, arg1: ::std::os::raw::c_uint) -> std_string {
        DS_Dictionary_getKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getAllKeys(&mut self) -> [u32; 3usize] {
        DS_Dictionary_getAllKeys(self)
    }
    #[inline]
    pub unsafe fn getIndexOfKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        DS_Dictionary_getIndexOfKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getIndexOfKeyWithClosestAlphaNumericalMatch(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        DS_Dictionary_getIndexOfKeyWithClosestAlphaNumericalMatch(self, arg1)
    }
    #[inline]
    pub unsafe fn removeKey(&mut self, arg1: ::std::os::raw::c_uint) {
        DS_Dictionary_removeKey(self, arg1)
    }
    #[inline]
    pub unsafe fn removeKey1(&mut self, arg1: *const ::std::os::raw::c_char) {
        DS_Dictionary_removeKey1(self, arg1)
    }
    #[inline]
    pub unsafe fn removeAllKeys(&mut self) {
        DS_Dictionary_removeAllKeys(self)
    }
    #[inline]
    pub unsafe fn getIntegerForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        DS_Dictionary_getIntegerForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getBoolForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> bool {
        DS_Dictionary_getBoolForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getFloatForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> f32 {
        DS_Dictionary_getFloatForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getStringForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> std_string {
        DS_Dictionary_getStringForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getVec2ForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> cocos2d_CCPoint {
        DS_Dictionary_getVec2ForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getRectForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> cocos2d_CCRect {
        DS_Dictionary_getRectForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getStringArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> [u32; 3usize] {
        DS_Dictionary_getStringArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getVec2ArrayForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> u8 {
        DS_Dictionary_getVec2ArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getRectArrayForKey(&mut self, arg1: *const ::std::os::raw::c_char) -> u8 {
        DS_Dictionary_getRectArrayForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn getArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCArray {
        DS_Dictionary_getArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getDictForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
    ) -> *mut cocos2d_CCDictionary {
        DS_Dictionary_getDictForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut cocos2d_CCObject {
        DS_Dictionary_getObjectForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn setIntegerForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) {
        DS_Dictionary_setIntegerForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setIntegerForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: bool,
    ) {
        DS_Dictionary_setIntegerForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setBoolForKey(&mut self, arg1: *const ::std::os::raw::c_char, arg2: bool) {
        DS_Dictionary_setBoolForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setBoolForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    ) {
        DS_Dictionary_setBoolForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setFloatForKey(&mut self, arg1: *const ::std::os::raw::c_char, arg2: f32) {
        DS_Dictionary_setFloatForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setFloatForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: f32,
        arg3: bool,
    ) {
        DS_Dictionary_setFloatForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setStringForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
    ) {
        DS_Dictionary_setStringForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setStringForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_string,
        arg3: bool,
    ) {
        DS_Dictionary_setStringForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setVec2ForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
    ) {
        DS_Dictionary_setVec2ForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setVec2ForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCPoint,
        arg3: bool,
    ) {
        DS_Dictionary_setVec2ForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setRectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
    ) {
        DS_Dictionary_setRectForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setRectForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const cocos2d_CCRect,
        arg3: bool,
    ) {
        DS_Dictionary_setRectForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setStringArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u32; 3usize],
    ) {
        DS_Dictionary_setStringArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setStringArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const [u32; 3usize],
        arg3: bool,
    ) {
        DS_Dictionary_setStringArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setVec2ArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setVec2ArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setVec2ArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    ) {
        DS_Dictionary_setVec2ArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setRectArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setRectArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setRectArrayForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
        arg3: bool,
    ) {
        DS_Dictionary_setRectArrayForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setArrayForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCArray,
    ) {
        DS_Dictionary_setArrayForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setBoolMapForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const u8,
    ) {
        DS_Dictionary_setBoolMapForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setSubDictForKey(&mut self, arg1: *const ::std::os::raw::c_char) {
        DS_Dictionary_setSubDictForKey(self, arg1)
    }
    #[inline]
    pub unsafe fn setSubDictForKey1(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: bool,
        arg3: bool,
    ) {
        DS_Dictionary_setSubDictForKey1(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn setDictForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCDictionary,
    ) {
        DS_Dictionary_setDictForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn setObjectForKey(
        &mut self,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut cocos2d_CCObject,
    ) {
        DS_Dictionary_setObjectForKey(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn addBoolValuesToMapForKey(
        &mut self,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    ) {
        DS_Dictionary_addBoolValuesToMapForKey(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn addBoolValuesToMapForKeySpecial(
        &mut self,
        arg1: *const u8,
        arg2: *const ::std::os::raw::c_char,
        arg3: bool,
    ) {
        DS_Dictionary_addBoolValuesToMapForKeySpecial(self, arg1, arg2, arg3)
    }
    #[inline]
    pub unsafe fn checkCompatibility(&mut self) {
        DS_Dictionary_checkCompatibility(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        DS_Dictionary_DS_Dictionary(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        DS_Dictionary_DS_Dictionary_destructor(self)
    }
}
